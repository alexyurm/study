Chapter1 The World of DataBase Systems

-  DBMS: database management system

-  Two distinct sources of commands to the DBMS:

   1. Conventional users and application programs that ask for data or
      modify data

   2. A database administrator: a person or persons responsible for the
      structure or schema of the database.

Chapter2 The Ralational Model of Data

-  Important Data Models

   A data model is a notation for describing data or information. The description generally consists of three parts(SOC):

   1) Structure of the data
   2) Operations on the data
   3) Constraints on the data

-  Important Data Models

   1. The relational model, including object-relational extensions.

      It is based on tables.

   2. The semistructured-data model, including XML and related standards.

      Semistructured data resembles trees or graphs, rather than tables or
      arrays. The principal manifestation of this viewpoint today is XML.
      Constraints on the structure of data in this model often involve the
      data type of values associated with a tag.

-  Basic of the Relational Model

   -  Schema

      The name of a relationship and the set of attributes for a relation
      is called the schema for that relation. E.g.
      
      Movies(title, year, length, genere). 

      The attributes in a relation schema are a set, not a list.

   -  Tuples

      The rows of a relation, other than the header row containing the 
      attribute names, called tuples. E.g,

      (Gone With the Wind, 1939, 231, drama)

      Note: when a tuple appears in isolation, the attributes do not appear.

   -  Domain

      The relational model requires that each component of each tuple be
      atomic, which must be some elementary type such as integer or string.

      It is further assumed that associated with each attribute of a relation
      is a domain, that is, a particular elementary type. We shall append
      a colon and a type after attributes. E.g.

      Movies(title:string, year:integer, length:integer, genre:string)

   -  Relationship Instances

      We call a set of tuples for a given relation an instance of relation
   
   -  Key Constraints:
      
      A set of attributes forms a key for a relationship if we do not allow two tuples
      in a relationship instance to have the same values in all the attributes of the key.

      We indicate the attribute or attributes that form a key for a relationship by underlining the key
      attribute(s). E.g.

      Movies(title, year, length, genre)
            ------  ----

      While we might be sure that title and year can serve as a key for Movies, many real-world databases use artificial keys, doubting
      that it is safe to make any assumption about the values of attributes outside their control. E.g. Employee's ID, SIN number.

   -  Defining the Relationship Schema in SQL

      SQL is the principle language used to describe and manipulate relationship databases. Most commercial database management systems implement
      something similar, but not identical to the standard SQL, which is SQL99.

      Two aspects to SQL:

      1. The Data-Defition sublanguage for declaring database schemas.
      2. The Data-Manipulation sublanguage for querying (asking questions about) databases and for modifying the database.

   -  Data-Definition

      SQL makes a distinction between three kinds of relationships

      1) Store relationships, which are called tables.

      2) (??)Views, which are relationships defined by a computation. These relationships are not stored, but are constructed, in whole or in part, when needed.

      3) (??)Temporary tables, which are constructed by the SQL language preprocessor when it performs its job of executing queries and data modifications. These
         relationships are then thrown away and not stored.

      -  Primitive Data Type

         1. Character strings of fixed or varying length.

         CHAR(n) denotes a fixed-length string of up to n characters. CHAR implies that short strings are padded to make n characters(what are short strings??).
         VARCHAR(n) denotes a fixed-length of up to n characters. VARCHAR implies that endmarker or string-length is used(??). 

         2. Bit strings of fixed or varying length.

         Those datatypes are analogus to fixed and varying-length strings, but their values are strings of bits rather than characters. The type BIT(n) denotes
         bit strings of length of n, while BIT VARYING(n) denotes bit strings of length up to n.

         3. boolean

         The possible values of BOOLEAN are: TRUE, FALSE and UNKNOWN

         4. INT or INTEGER 

         5. Floating point numbers

         FLOAT or REAL
         DOUBLE: with a higher precision
         DECIMAL(n,d): allows value that consist of n decimal digits, with the decimal point assumed to be d positions from the right. Thus, 0123.45 is a possible value of type
                        DECIMAL(6,2)
         NUMERTC: is almost the same as DECIMAL, although there are possible implementation-dependent differences.
         
         6. Dates and times

         DATA and TIME: These values are essential character strings of a special form.

      -  Simple Table Declarations

            1. Create a new table

            E.g.

            CREATE TABLE MovieStar (
               name CHAR(30),
               address VARCHAR(255),
               gender CHAR(1),
               birthdate DATE
            )
            
            2. Modify relation schemas

               2.1. We can delete a relation R by the SQL statement:
         
                     DROP TABLE R;

                     R is no longer part of the database schema, and we can no longer access any of its tuples.

               2.2   More frequently than we would drop a relation that is part of a long-lived database, we may need to modify the schema of an existing relation:

                     1. ADD followed by an attribute name and its data type.
            
                     2. DROP followed by an attribute name. E.g.

                     ALTER TABLE MovieStar ADD phone CHAR(16); //NULL is set to the newly added attribute phone.

                     ALTER TABLE MovieStar DROP birthdate;

               2.3   Default Values

                     In general, any place we declare an attribute and its data type, we may add the keyword DEFAULT and an appropriate value. That value is either
                     NULL or a constant. Certain other values that are provided by the system, such as the current time, may also be options. E.g.

                     gender CHAR(1) DEFAULT '?',
                     birthdate DATE DEFAULT DATE '0000-00-00'

               2.4   Declaring keys

                     Two ways to declare an attribute or set of attributes to be a key in the CREATE TABLE statement that defines a stored relation.

                     1. We may declare one attribute to be a key when that attribute is listed in the relation schema.
                     2. We may add to the list of items declared in the schema (which so far have only been attributes) an additional declaration that says a particular
                        attribute or set of attributes forms the key.

                     Two declarations are used to indicate keyness:

                     a) PRIMARY KEY, or
                     b) UNIQUE

                     The effect of declaring a set of attributes S to be a key for relation R either using PRIMARY KEY or UNIQUE is the following:
   
                     Two tuples in R cannot agree on all of the attributes in set S, unless one of them is NULL. Any attempt to insert or update a tuple that violates
                     this rule causes the DBMS to reject the action that caused the violation(??).

                     In addition, if PRIMARY KEY is used, then attributes in S are not allowed to have NULL as a value for their components. Again, any attempt to 
                     violate this rule is rejected by the system. NULL is permitted if the set S is declared UNIQUE, however, A DBMS may make other distinctions between
                     the two terms, if it wishes.

                     E.g.

                     CREATE TABLE MovieStar (
                        name CHAR(30) PRIMARY KEY,
                        address VARCHAR(255),
                        gender CHAR(1),
                        birthdate DATE
                     );
                     
                     or:
      
                     CREATE TABLE MovieStar (
                        name CHAR(30)
                        address VARCHAR(255),
                        gender CHAR(1),
                        birthdate DATE,
                        PRIMARY KEY (name)
                     );
                     
                     or:

                     CREATE TABLE Movies (
                        title CHAR(100),
                        year INT,
                        length INT,
                        genre CHAR(10),
                        studioName CHAR(30),
                        productC# INT,
                        PRIMARY KEY(title, year)
                     );

                     Note: UNIQUE can be used to replace PRIMARY KEY.

      -  An Algebraic Query Language

         An algebra, in general, consists of operators and atomic operands. Relational algebra is another example of an algebra. Its atomic operands are:

         1. Variables that stand for relations;
         2. Constants, which are finite relations(??).

         The operations of the tradicional relational algebra fall into 4 broad classes:

         1) The usual set operations - unions, intersection, and difference -- applied to relations.
         2) Operations that remove parts of a relation: "selection" eliminates some rows(tuples), and "projection" eliminates some columns.
         3) Operations that combine the tuples of two relations, including "Cartesian product", which pairs the tuples of two relations in all possible ways,
            and various kinds of "join" operations, which selectively pair tuples from two relations.
         4) An operation called "renaming" that does not affect the tuples of a relation, but changes the relation schema, i.e. the names of the attributes and/or
            the name of the relation itself.

         We generally shall refers to expressions of relational algebra as queries.

         1) Set operations

            union: R U S
            intersection: R n S
            difference: R - S

            Conditions on R and S:

            1) R and S must have schemas with identical sets of attributes, and the types (domains) for each attribute must be the same in R and S.
            2) the columns of R and S must be ordered so that the order of attributes is the same for both relations.

         2) Projection

            The projection operator is used to produce from a relation R a new relation that has only some of R's columns.

         3) Selection

            The selection operator, applied to a relation R, produces a new relation with a subset of R's tuples. The tuples in the resulting relation are those that
            satisfy some condition C that involves the attributes of R.

         4) Cartesian Product(??)

            The Cartesian product (or cross-product, or just product) of two sets of R and S is the set of pairs that can be formed by choosing the first element of
            the pair to be any element of R and the second any element of S. This product is denoted R x S. When R and S are relations, the product is essentially
            the same. The relation schema for the resulting relation is the union of the schemas for R and S. However, if R and S should happen to have some attributes
            in common, then we need to invent new names for at least one of each pair. 

            
            A|B
            ---
            1|2
            3|4

            a) Relation R

            B|C|D
            -----
            2|5|6
            4|7|8
            9|10|11

            b) Rerlation S

            A|R.B|S.B|C|D
            -------------
            1|2  |2  |5|6 
            1|2  |4  |7|8
            1|2  |9  |10|11
            3|4  |2  |5 |6
            3|4  |4  |7 |8
            3|4  |9  |10|11

            c) Result of R X S 
            

         5) Natural Joins(??)

            More often than we want to take the product of two relations, we find a need to join them by pairing only those tuples that match in some way. Let A1, A2,
            ..., An be all the attributes that are in both schema of R and the schema of S. Then a tuple r from R and a tuple s from S are successfully paired if and
            only if r and s agree on each of the attribtes A1, A2, ...An.

         6) Theta-Joins(??)

            Sometimes, it is desirable to pair tuples from two relations on some other basis. for that purposes, we have a related notation called the thetajoin. Historically,
            the "theta" refers to an arbitrary condition, which we shall represent by C rather then @. The result of this operation is constructed as follows:

            1. Take the product of R and S;
            2. Select from the product only those tuples that satisfy the condition C. As with the product operation, the schema for the result is the union of the schemas of 
               R and S, with "R" or "S". prefixed to attributes if necessary to indicate from which schema the attribute came.

            Note: The theta-join contrasts with natural join, since in the latter common attributes are merged into one copy. Why theta-join isn't do so? because there is no
                  guarantee that compared attributes will agree in the result, since they may not compared with ==.

            A|B|C
            -----
            1|2|3
            6|7|8
            9|7|8

            a) Relation U

            B|C|D
            -----
            2|3|4
            2|3|5
            7|8|10

            b) Relation V

            A|B|C|D
            -------
            1|2|3|4
            1|2|3|5
            6|7|8|10
            9|7|8|10

            c) Natural join of relations

            A|U.B|U.C|V.B|V.C|D
            -------------------
            1| 2 | 3 | 2 | 3 |4
            1| 2 | 3 | 2 | 3 |5
            1| 2 | 3 | 7 | 8 |10
            6| 3 | 8 | 7 | 8 |10
            9| 7 | 8 | 7 | 8 |10

            e) Result of theta-join (A<D)
         
            A|U.B|U.C|V.B|V.C|D
            1|2  |3  |7  |8  |10

            e) Result of theta-join(A<D AND U.B != V.B) of relations

         7) Combining Operations to Form Queries

            Like all algebras, relational algebra allows us to form expressions of arbitrary complexity by applying operations to the result of other operations.

            E.g. "What are tht titles and years of movies made by Fox that are at least 100 minutes long?"

            1) Select those movies tuples that have length >= 100.
            2) Select those movies tuples that have studioName = 'Fox'.
            3) Compute the interaction of 1) and 2).
            4) Project the relation from 3) onto attribute title and year.

            pi(title, year) (@length >= 100(Movies) AND @studioName = 'Fox'(Movies))

         8) Naming and Renaming

            In order to control the names of the attributes used for relations that are constructed by applying relational-algebra operations, it is often convinent to 
            use an operator that explicitly renames relations.

            Suppose we want to continue to use the name B for the attribute that comes from R, and we want to use X as the name of the attribute B coming from S. We can
            rename the attributes of S so the first is called X. The result of the expression ps(X,C,D)(S) is a relation named S that looks just like the relationship S
            from Fig.2.14, but its first column has attribute X instead of B.

            A|B|X|C|D
            ---------
            1|2|2|5|6 
            1|2|4|7|8
            1|2|9|10|11
            3|4|2|5 |6
            3|4|4|7 |8
            3|4|9|10|11

            a) R X ps(X,C,D)(S)

            As an alternative, we could take the product without renaming, and then rename the result. The expression

            pRS(A, B, X, C, D)(R x S)

         9) Relationships Among Operations

            Please see the paper notebook.

         10) A Linear Notation for Algebraic Expressions

            Please see the paper notebook.
         
         11) Constraints on Relations

            Please read the book.

Chapter 3:  Design Theory for Relational Databases

3.1      -  Functional Dependencies

            -  Definition

               A functional dependency(FD) on a relation R is a statement of the form "If two tuples of R agree on all of the attributes A1, A2,..., An", then they must
               also agree on all of another list of attributes B1, B2, ..., Bm. We write this FD formally as A1A2...An -> B1B2...Bm and say that

               "A1, A2,...,An functionally determine B1,B2...,Bm"

            -  It is important what when we say that R satisfies an FD f, we are asserting a constraint on R, not just saying something about one particular instance of R.
               It means that the FD says something about all possible instances of the relation, not about one of its instances. 

         -  Keys of Relationships.

            We say that a set of one or more attributes {A1, A2,..., An} is a key for a relation R if (why one or more?? Resolved.because sometimes a relation has more than one key):

            1. Those attributes functionally determine all other attributes of the relation. That is, it is impossible for two distinct tuples of R to agree on all of A1, A2, ...
               An.

            2. No proper subset of {A1, A2, ...An} functionally determines all other attributes of R; i.e., a key must be minimal.

            Sometimes a relation has more than one key and we choose one of the keys as the primary key(!!).

         -  Superkeys

            A set of attributes that contains a key is called a superkey.

3.2   Rules about Functional Dependencies

         -  Two sets of FD's S and T are equilvalent if the set of relation instances satisfying S is exactly the same as the set of relation instances satisfying T(??).

         -  More generally, a set of FD's S follows from a set of FD's T if every relation instance that satisfies all the FD's in T also satifies all the FD's in S(??).
      
      The Spliting/Combining Rule

         -  We can replace an FD A1A2...An -> B1B2...Bm by a set of FD's A1A2...An -> Bi for i=1, 2, ...m. This transformation we call the splitting rule.
         
         -  We can replace a set of FD's A1A2...Am -> Bi for i = 1, 2, ...m by the single FD A1A2...An -> B1B2...Bm. We call this transformation the combining rule.

         Note: there is no splitting rule for left side.

      Trivial Functional Dependencies

         A constraint of any kind on a relation is said to be trivial if it holds for every instance of the relation, regardless of what other constraints are assumed(??).
         When the constraints are FD's, it is easy to tell whether an FD is trivial. They are the FD's A1A2...An -> B1B2...Bm such that 

         {B1, B2, ..., Bm} belongs to {A1, A2, ..., An}

         That is a trivial FD has a right side that is a subset of its left side. For example
         
         title year -> title

         is a trivial FD, as is 

         title -> title.

      Computing the Closure of Attributes

         -  Suppose {A1, A2,..., An} is a set of attributes and S is a set of FD's. The closure of {A1, A2, ..., An} under the FD's in S is the set of attribute B such that
            every relation that satisfies all the FD's in set S also satifies A1A2...An -> B. That is, A1A2...An -> B follows from the FD's of S. 

            We denote the closure of a set of attributes A1A2...An by {A1, A2, ..., An}+. 

            Algorithm 3.7: Closure of a Set of Attributes.

            Input: A set of attributes {A1, A2, ..., An} and a set of FD's S.
            Output: The closure {A1, A2, ..., An} +.

            1. If necessary, split the FD's of S, so each FD in S has a single attribute on the right.

            2. Let X be a set of attributes that eventually will become the closure. Initialize X to be {A1, A2, ..., An}.

            3. Repeatedly search for some FD

               B1B2...Bm -> C

               such that all of B1, B2, ..., Bm are in the set of attributes X, but C is not. Add C to the set X and repeat the search. Since X can only glow, and the number of
               attributes of any relation schema must be finite, eventually nothing more can be added to X, and this step ends.

            4. The set X, after no more attributes can be added to it, is the correct value of {A1, A2, ..., An}+

            E.g. A relation with attributes A, B, C, D, E, and F. Suppose that this relation has the FD's AB->C, BC->AD, D->E, and CF->B. What is the closure of {A,B}, that is {A,B}+

            Step1: We split BC->AD into BC->A and BC->D.

            Step2: Start with X ={A,B}. 

            Step3: Since we have: AB->C, We add C to X, now X={A, B, C}
                  
                   BC-> and BC->D, then we have X={A, B, C, D}

                   D->E, we have X={A, B, C, D, E}
               
                   CF->B cannot be used, because its left side never becomes contained in X. Thus, {A, B}+ = {A, B, C, D, E}

      Why the Closure Algorithm works? ----> Skip

      The Transtitive Rule

      -  The transtitive rule lets us cascade two FD's, and generalizes the observation of Example 3.4.

         If A1A2...An -> B1B2...Bm and B1B2...Bm -> C1C2...Ck hold in relation R, then A1A2...An -> C1C2...Ck also holds in R.

Questions:

1. Login MySQL with the root user

   mysql -u root --password=<root user password>

   if you don't want others see your password, try this:

   mysql -u root -p
   Enter password:

2. Simple mysql commands:

   USE name_of_database;            //Choose the database "name_of_database"
   SELECT DATABASE();               //Check which database you have been using
   SHOW TABLES;                     //Explore what tables make up the database
   SHOW COLUMNS FROM name_of_table  //To explore the table "name_of_table"
   DESC name_of_table               //the same as the above command

-  Modeling and Designing Databases

   There are three major stages in database design, each producing a progressively lower-level description:

   1. Requirement analysis

   We need to determine and write down what exactly the database is needed for. Some questions you need to ask for yourself?

   What data will be stored?
   How the data items relate to each other
   
   2. Conceptual design

   3. Logical design

   Finally, we map the database design onto an actual database management system and database tables;

-  The Entity Relationship Model

   At a basic level, databases store information about distinct object, or entities, and the associations, or relationships, between these entities. 

   Entity set - it is represented by a rectangle containing the entity name. 
   Attributes - the certain characteristics or the entities. An attribute may be formed from smaller parts; for example, a postal address is composed of a street
                number, city, ZIP code, and country. We classify attributes as composite if they're composed of smaller parts in this way.
                Clearly, there may be several possible keys that could be used to identify an entity; we choose one of the alternative, or candidate, keys to be
                our main, or primary key. You usually make this choice based on how confident you are that the attribute will be non-empty and unique for each
                individual entity.  In the ER diagram, attributes are represented as labeled ovals and are connected to their owning entity. For some applications,
                no combination of attributes can uniquely identify an entity(or it would be too unwieldy to use a large composite key), so we create an artificial
                attribute that's defined to be unique and can therefore be used as a keyl student number, Social Security numbers, driver's license number...
  Relstionships - We represent a relationship set with a named diamond. 

-  Representing Relationships

   many-to-many relationship (M:N)
   one-to-many relationship (1:N)
   many-to-one relationship (N:1)
   one-to-one relationship (1:1)
   
-  The SELECT Statement and Basic Querying Techniques:

   Single Table SELECTs

   SELECT * FROM artist;

   A simple SELECT statement has four components:

   1. The keyword SELECT.
   2. The columns to be displayed. In our first example, we asked for all columns by using the asterisk(*) symbol as a wildcard character.
   3. The keyword FROM.
   4. The table name; in this example, the table name is artist.

   -  Choose columns

   mysql> SELECT artist_name FROM artist;
   
   mysql> SELECT artist_name and, artist_id FROM artist;
   
   You can even list columns more than once:

   mysql> SELECT artist_id, artist_id FROM artist;

   You can specify databases, tables, and column names in a SELECT statement. This allows you to avoid the USE command and work with any database and table
   with SELECT. Consider an example: you want to retrieve the album_name column from the album table in the music database. You can do this with the following
   command:

   mysql> SELECT album_name FROM music.album;

-  Choosing Rows with the WHERE Clause.

   Consider an example where we want to find out the details of the artist with the name "New Order." Here's what you type:

   mysql > SELECT * FROM artist WHERE artist_name = "New Order"

   Another example:

   mysql > SELECT artist_name FROM artist WHERE artist_id=4;

   This example chooses one column and one row.

   If a match matches more than one row, the results will contain all matches.

   In a range:
      
   mysql> SELECT artist_name FROM artist WHERE artist_id < 5

   Consider that if you want to find all albums that don't have an album_id of 2, you'd type:

   mysql> SELECT album_name FROM album WHERE album_id <> 2;

   You can also list all artists whose name appears earlier alphabetically than (is less than) 'M', use:

   mysql> SELECT artist_name FROM artist WHERE artist_name < 'M';

   (by default, MySQL doesn't care about case)

   Another very common task you'll want to perform with strings is to find matches that begin with prefix, contain a string, or end in a suffix. For example, 
   you might want to find all album names beginning with the word "Retro". Do this with the LIKE operator in a WHERE clause:

   mysql> SELECT album_name FROM album WHERE album_name LIKE "Retro%"

   The above example shows that the wildcard character "%" matches all possible strings. You can also do:

   "%ing" - a string that ends in a suffix.
   "%ing%" - matches all strings that have "ing" in them.

   If you want to match exactly one wildcard character in a LIKE clause, you use the underscore character (_). For example, if you want all tracks that begin
   with a three letter word that starts with 'R', you use:
   
   mysql> SELECT * FROM track WHERE track_name LIKE "R__%"

-  Combining conditions with AND, OR, NOT, and XOR

   Use two or more conditions using the Boolean operators AND, OR, NOT, and XOR.

   mysql> SELECT album_name FROM album WHERE
       -> album_name > "C" AND album_name < "M";

   mysql> SELECT album_name FROM album WHERE
      -> album_name LIKE "L%" OR
      -> (album_name LIKE "S%" AND album_name LIKE "%g")

   It is recommended that you use parentheses whenever there is a chance the intention could be misinterrupted.

   The unary NOT operator negates a Boolean statement. Suppose that you want a list of all albums except the ones having an album_id of 1 or 3. You'd write the query:

   mysql> SELECT * FROM album WHERE NOT(album_id = 1 OR album_id = 3);

   You can combine the NOT operation with LIKE. Suppose you want all albums that don't begin with an L; To do this, type:

   mysql> SELECT album_name FROM album WHERE album_name NOT LIKE "L%"

-  ORDER by Clauses

   There is no intrinsic order between the rows, and so we have to ask MySQL to sort the result if we want them in a particular order. Suppose you want to return a list
   of the artists in the music database, sorted in alphabetical order by the artist_name. Here's what you'd type.

   mysql> SELECT * FROM artist ORDER BY artist_name;

   The default sort is case-insensitive and in ascending order. The way strings are sorted is determined by the character set and collation order that are being used(discussed
   later).

   In the following example, when the track times are the same, we'll sort the answers alphabetically by track_name. 

   mysql> SELECT time, track_name FROM track ORDER BY time, track_name;

   | 2.90 | I Just Want To See His Face
   | 2.97 | Sweet Black Angel
   ...
   | 3.40 | Under The Influence Of Love
   | 3.40 | Ventilator Blues
   ...

   Notice that there's a collision of track times where the length is 3.40. In this case, the second sort key, track_name is used to resolve the collisons so that "Under The 
   Influence Of Love" appears before "Ventilator Blues".

   Also, you can sort in descending order:

   mysql> SELECT artist_name FROM artist ORDER by artist_name DESC;

   You can also use a mixture of ascending and descending orders when multiple sort keys are used. E.g.

   mysql> SELECT time, track_name FROM track
         -> WHERE time < 3.6
         -> ORDER BY time DESC, track_name ASC;

   If a collision of values occur, and you don't specify another sort key, the sort order is underfined. A common source of collision is string sorting, where MySQL ignores
   the case of characters. If you do want sorting like ASCII does(WHERE uppercase comes before lowercase), then you can add BINARY keyword to your sort as follows:

   mysql> SELECT * FROM artist ORDER by BINARY artist_name;

   or

   mysql> SELECT track_name FROM track WHERE track_name < BINARY 'b';

   Sorting is performed as appropriate to the column type. For example if you're sorting dates, it organizes the rows in ascending data order. You can force the sort to behave
   differently, using CAST() function and the AS keyword. E.g. if you want to sort the track table by ascending time, but you want the times to be treated as strings. Here's how
   you do it:

   mysql> SELECT time, tracktime FROM track ORDER by CAST(time AS CHAR); The CAST() function forces a column to be treated as a different type. You can specify:

   AS BINARY, to sort as binary, which has the same effect as ORDER BY BINARY
   AS SIGNED, to sort as a signed integer
   AS UNSIGNED, to sort as an unsigned integer
   AS CHAR, to sort as a character string
   AS DATE, to sort as a date
   AS DATETIME, to sort as a date and time
   AS TIME, to sort as a time

-  The LIMIT Clause

   The LIMIT clause is a useful, nonstandard SQL tool that allows you to control which rows are output. E.g. in a web database application, where you want to find the rows
   that match a condition but only want to show the user the first 10 rows in a web page.

   mysql> SELECT track_name FROM track LIMIT 10;

   The above example restricts the output to the first 10 rows. The LIMIT clause can be used to return a fixed number of rows beginning anywhere in the result set. E.g.

   mysql> SELECT track_name FROM track LIMIT 5,5;

   The above example shows that you want 5 rows but you want the first one displayed to be the sixth row of the answer. The output is rows 6 to 10 from the SELECT query.

   You can also write LIMIT 10 OFFSET 5.

-  Joining Two tables;

   mysql> SELECT artist_name, album_name FROM artist INNER JOIN album
         -> USING (artist_id)

   How INNER JOIN works?

   The statement has two parts: first, two table names seperated by the INNER JOIN keywords; second, the USING keyword that indicates which column (or columns) holds
   the relationship between the two tables. Also, the USING clause in the example is USING (artist_id), which tells MySQL that the column that holds the relationship
   between the tables is artist_id; 

   There are a few important issues you need to know about when using the basic INNER JOIN syntax.

   -  It works only when two tables share a column with the same name that you can use as the join condition;
   -  The result rows shown are those where the join column (or columns) match between the tables; rows from one table that don't have a match in the other table are
      ignored. In the previous example, any artist who had no albums would be ignored.
   -  With the exception of the join column or columns after the USING keyword, any columns you specify must be unambiguous. For example, if you want to SELECT the artist_name
      , you must use just artist_name because it exists only in the artist table. However, if you want artist_id, then you need to specify it explicitly as artist.artist_id or
      album.artist_id because both tables have a column of the same name.
   -  don't forget the USING clause. MySQL won't complain if you omit it, but the results won't make sense because you'll get a Cartesian product.
   -  The columns or columns following the USING clause must be surrounded by parentheses. If you want to join on more than one column, seperate the column names with a comma.

      +-----------+-------------+----------+------------------------------------------+
      | artist_id | artist_name | album_id | album_name                               |
      +-----------+-------------+----------+------------------------------------------+
      | 1         | New Order   | 1        | Retro - John McCready FAN                |
      | 1         | New Order   | 2        | Substance (Disc 2)                       |
      | 1         | New Order   | 3        | Retro - Miranda Sawyer POP               |
      | 1         | New Order   | 4        | Retro - New Order / Bobby Gillespie LIVE |
      | 1         | New Order   | 5        | Power, Corruption & Lies                 |
      | 1         | New Order   | 6        | Substance 1987 (Disc 1)                  |
      | 1         | New Order   | 7        | Brotherhood                              |
      +-----------+-------------+----------+------------------------------------------+

   mysql> SELECT album_name, track_name FROM album INNER JOIN track
         -> USING (artist_id, album_id) LIMIT 15;

-  the INSERT Statement

   The Insert statement is used to add new data to tables. There are 2 situations:

   1) bulk-load in a large batch
   2) add data on ad hoc basis

   mysql> INSERT INTO artist VALUES (7, "Barry Adamson")
   
   

-  CREATE clause:

   Creating a database:
   
   mysql> CREATE DATABASE hibernate;

   Creating Tables:

   mysql> DROP DATABASE hibernate;
   
   CREATE TABLE artist (
      -> artist_id SMALLINT(5) NOT NULL DEFAULT 0,
      -> artist_name CHAR(128) DEFAULT NULL,
      -> PRIMARY KEY (artist_id)
      -> );

   Column specifications: name type [NOT NULL | NULL] [DEFAULT value].

   NOT NULL: a row isn't valid without a value for the column.
   NULL or omit the clause: a row can exist without a value for the column.
   DEFAULT: it will be used to populate the column when you don't otherwise provide a data. The value must
            be a constant except if the column is of the type TIMESTAMP.

   -  IF NOT EXISTS keyword phrase when creating a table, and it works much as it does for databases. Here is 
      an example that won't report an error even when the artist table exists.

   
      mysql>
      ->CREATE TABLE IF NOT EXISTS artist (
      ->artist_id SMALLINT(5) NOT NULL DEFAULT 0,
      ->artist_name CHAR(128) DEFAULT NULL,
      ->PRIMARY KEY (artist_id)
      );

      Query OK, o rows affected (0.00sec)

   -  AUTO_INCREMENT feature for numeric columns.

      This feature allows you to automatically create unique identifier for a table.

   -  Column comments;

   -  Foreign key constraints

   -  Creating temporary tables

   You can use SHOW CREATE TABLE statement introduced 

   Built-in functions;
   
   MAX();
   
