Chapter1 The World of DataBase Systems

-  DBMS: database management system

-  Two distinct sources of commands to the DBMS:

   1. Conventional users and application programs that ask for data or
      modify data

   2. A database administrator: a person or persons responsible for the
      structure or schema of the database.

Chapter2 The Ralational Model of Data

-  Important Data Models

   A data model is a notation for describing data or information. The description generally consists of three parts(SOC):

   1) Structure of the data
   2) Operations on the data
   3) Constraints on the data

-  Important Data Models

   1. The relational model, including object-relational extensions.

      It is based on tables.

   2. The semistructured-data model, including XML and related standards.

      Semistructured data resembles trees or graphs, rather than tables or
      arrays. The principal manifestation of this viewpoint today is XML.
      Constraints on the structure of data in this model often involve the
      data type of values associated with a tag.

-  Basic of the Relational Model

   -  Schema

      The name of a relationship and the set of attributes for a relation
      is called the schema for that relation. E.g.
      
      Movies(title, year, length, genere). 

      The attributes in a relation schema are a set, not a list.

   -  Tuples

      The rows of a relation, other than the header row containing the 
      attribute names, called tuples. E.g,

      (Gone With the Wind, 1939, 231, drama)

      Note: when a tuple appears in isolation, the attributes do not appear.

   -  Domain

      The relational model requires that each component of each tuple be
      atomic, which must be some elementary type such as integer or string.

      It is further assumed that associated with each attribute of a relation
      is a domain, that is, a particular elementary type. We shall append
      a colon and a type after attributes. E.g.

      Movies(title:string, year:integer, length:integer, genre:string)

   -  Relationship Instances

      We call a set of tuples for a given relation an instance of relation
   
   -  Key Constraints:
      
      A set of attributes forms a key for a relationship if we do not allow two tuples
      in a relationship instance to have the same values in all the attributes of the key.

      We indicate the attribute or attributes that form a key for a relationship by underlining the key
      attribute(s). E.g.

      Movies(title, year, length, genre)
            ------  ----

      While we might be sure that title and year can serve as a key for Movies, many real-world databases use artificial keys, doubting
      that it is safe to make any assumption about the values of attributes outside their control. E.g. Employee's ID, SIN number.

   -  Defining the Relationship Schema in SQL

      SQL is the principle language used to describe and manipulate relationship databases. Most commercial database management systems implement
      something similar, but not identical to the standard SQL, which is SQL99.

      Two aspects to SQL:

      1. The Data-Defition sublanguage for declaring database schemas.
      2. The Data-Manipulation sublanguage for querying (asking questions about) databases and for modifying the database.

   -  Data-Definition

      SQL makes a distinction between three kinds of relationships

      1) Store relationships, which are called tables.

      2) (??)Views, which are relationships defined by a computation. These relationships are not stored, but are constructed, in whole or in part, when needed.

      3) (??)Temporary tables, which are constructed by the SQL language preprocessor when it performs its job of executing queries and data modifications. These
         relationships are then thrown away and not stored.

      -  Primitive Data Type

         1. Character strings of fixed or varying length.

         CHAR(n) denotes a fixed-length string of up to n characters. CHAR implies that short strings are padded to make n characters.
         VARCHAR(n) denotes a fixed-length of up to n characters. VARCHAR implies that endmarker or string-length is used(??). 

         2. Bit strings of fixed or varying length.

         Those datatypes are analogus to fixed and varying-length strings, but their values are strings of bits rather than characters. The type BIT(n) denotes
         bit strings of length of n, while BIT VARYING(n) denotes bit strings of length up to n.

         3. boolean

         The possible values of BOOLEAN are: TRUE, FALSE and UNKNOWN

         4. INT or INTEGER 

         5. Floating point numbers

         FLOAT or REAL
         DOUBLE: with a higher precision
         DECIMAL(n,d): allows value that consist of n decimal digits, with the decimal point assumed to be d positions from the right. Thus, 0123.45 is a possible value of type
                        DECIMAL(6,2)
         NUMERTC: is almost the same as DECIMAL, although there are possible implementation-dependent differences.
         
         6. Dates and times

         DATA and TIME: These values are essential character strings of a special form.

      -  Simple Table Declarations

            1. Create a new table

            E.g.

            CREATE TABLE MovieStar (
               name CHAR(30),
               address VARCHAR(255),
               gender CHAR(1),
               birthdate DATE
            )
            
            2. Modify relation schemas

               2.1. We can delete a relation R by the SQL statement:
         
                     DROP TABLE R;

                     R is no longer part of the database schema, and we can no longer access any of its tuples.

               2.2   More frequently than we would drop a relation that is part of a long-lived database, we may need to modify the schema of an existing relation:

                     1. ADD followed by an attribute name and its data type.
            
                     2. DROP followed by an attribute name. E.g.

                     ALTER TABLE MovieStar ADD phone CHAR(16); //NULL is set to the newly added attribute phone.

                     ALTER TABLE MovieStar DROP birthdate;

               2.3   Default Values

                     In general, any place we declare an attribute and its data type, we may add the keyword DEFAULT and an appropriate value. That value is either
                     NULL or a constant. Certain other values that are provided by the system, such as the current time, may also be options. E.g.

                     gender CHAR(1) DEFAULT '?',
                     birthdate DATE DEFAULT DATE '0000-00-00'

               2.4   Declaring keys

                     Two ways to declare an attribute or set of attributes to be a key in the CREATE TABLE statement that defines a stored relation.

                     1. We may declare one attribute to be a key when that attribute is listed in the relation schema.
                     2. We may add to the list of items declared in the schema (which so far have only been attributes) an additional declaration that says a particular
                        attribute or set of attributes forms the key.

                     Two declarations are used to indicate keyness:

                     a) PRIMARY KEY, or
                     b) UNIQUE

                     The effect of declaring a set of attributes S to be a key for relation R either using PRIMARY KEY or UNIQUE is the following:
   
                     Two tuples in R cannot agree on all of the attributes in set S, unless one of them is NULL. Any attempt to insert or update a tuple that violates
                     this rule causes the DBMS to reject the action that caused the violation(??).

                     In addition, if PRIMARY KEY is used, then attributes in S are not allowed to have NULL as a value for their components. Again, any attempt to 
                     violate this rule is rejected by the system. NULL is permitted if the set S is declared UNIQUE, however, A DBMS may make other distinctions between
                     the two terms, if it wishes.

                     E.g.

                     CREATE TABLE MovieStar (
                        name CHAR(30) PRIMARY KEY,
                        address VARCHAR(255),
                        gender CHAR(1),
                        birthdate DATE
                     );
                     
                     or:
      
                     CREATE TABLE MovieStar (
                        name CHAR(30)
                        address VARCHAR(255),
                        gender CHAR(1),
                        birthdate DATE,
                        PRIMARY KEY (name)
                     );
                     
                     or:

                     CREATE TABLE Movies (
                        title CHAR(100),
                        year INT,
                        length INT,
                        genre CHAR(10),
                        studioName CHAR(30),
                        productC# INT,
                        PRIMARY KEY(title, year)
                     );

                     Note: UNIQUE can be used to replace PRIMARY KEY.

      -  An Algebraic Query Language

         An algebra, in general, consists of operators and atomic operands. Relational algebra is another example of an algebra. Its atomic operands are:

         1. Variables that stand for relations;
         2. Constants, which are finite relations(??).

         The operations of the tradicional relational algebra fall into 4 broad classes:

         1) The usual set operations - unions, intersection, and difference -- applied to relations.
         2) Operations that remove parts of a relation: "selection" eliminates some rows(tuples), and "projection" eliminates some columns.
         3) Operations that combine the tuples of two relations, including "Cartesian product", which pairs the tuples of two relations in all possible ways,
            and various kinds of "join" operations, which selectively pair tuples from two relations.
         4) An operation called "renaming" that does not affect the tuples of a relation, but changes the relation schema, i.e. the names of the attributes and/or
            the name of the relation itself.

         We generally shall refers to expressions of relational algebra as queries.

         1) Set operations

            union: R U S
            intersection: R n S
            difference: R - S

            Conditions on R and S:

            1) R and S must have schemas with identical sets of attributes, and the types (domains) for each attribute must be the same in R and S.
            2) the columns of R and S must be ordered so that the order of attributes is the same for both relations.

         2) Projection

            The projection operator is used to produce from a relation R a new relation that has only some of R's columns.

         3) Selection

            The selection operator, applied to a relation R, produces a new relation with a subset of R's tuples. The tuples in the resulting relation are those that
            satisfy some condition C that involves the attributes of R.

         4) Cartesian Product(??)

            The Cartesian product (or cross-product, or just product) of two sets of R and S is the set of pairs that can be formed by choosing the first element of
            the pair to be any element of R and the second any element of S. This product is denoted R x S. When R and S are relations, the product is essentially
            the same. The relation schema for the resulting relation is the union of the schemas for R and S. However, if R and S should happen to have some attributes
            in common, then we need to invent new names for at least one of each pair. 

            
            A|B
            ---
            1|2
            3|4

            a) Relation R

            B|C|D
            -----
            2|5|6
            4|7|8
            9|10|11

            b) Rerlation S

            A|R.B|S.B|C|D
            -------------
            1|2  |2  |5|6 
            1|2  |4  |7|8
            1|2  |9  |10|11
            3|4  |2  |5 |6
            3|4  |4  |7 |8
            3|4  |9  |10|11

            c) Result of R X S 
            

         5) Natural Joins(??)

            More often than we want to take the product of two relations, we find a need to join them by pairing only those tuples that match in some way. Let A1, A2,
            ..., An be all the attributes that are in both schema of R and the schema of S. Then a tuple r from R and a tuple s from S are successfully paired if and
            only if r and s agree on each of the attribtes A1, A2, ...An.

         6) Theta-Joins(??)

            Sometimes, it is desirable to pair tuples from two relations on some other basis. for that purposes, we have a related notation called the thetajoin. Historically,
            the "theta" refers to an arbitrary condition, which we shall represent by C rather then @. The result of this operation is constructed as follows:

            1. Take the product of R and S;
            2. Select from the product only those tuples that satisfy the condition C. As with the product operation, the schema for the result is the union of the schemas of 
               R and S, with "R" or "S". prefixed to attributes if necessary to indicate from which schema the attribute came.

            Note: The theta-join contrasts with natural join, since in the latter common attributes are merged into one copy. Why theta-join isn't do so? because there is no
                  guarantee that compared attributes will agree in the result, since they may not compared with ==.

            A|B|C
            -----
            1|2|3
            6|7|8
            9|7|8

            a) Relation U

            B|C|D
            -----
            2|3|4
            2|3|5
            7|8|10

            b) Relation V

            A|B|C|D
            -------
            1|2|3|4
            1|2|3|5
            6|7|8|10
            9|7|8|10

            c) Natural join of relations

            A|U.B|U.C|V.B|V.C|D
            -------------------
            1| 2 | 3 | 2 | 3 |4
            1| 2 | 3 | 2 | 3 |5
            1| 2 | 3 | 7 | 8 |10
            6| 3 | 8 | 7 | 8 |10
            9| 7 | 8 | 7 | 8 |10

            e) Result of theta-join (A<D)
         
            A|U.B|U.C|V.B|V.C|D
            1|2  |3  |7  |8  |10

            e) Result of theta-join(A<D AND U.B != V.B) of relations

         7) Combining Operations to Form Queries

            Like all algebras, relational algebra allows us to form expressions of arbitrary complexity by applying operations to the result of other operations.

            E.g. "What are tht titles and years of movies made by Fox that are at least 100 minutes long?"

            1) Select those movies tuples that have length >= 100.
            2) Select those movies tuples that have studioName = 'Fox'.
            3) Compute the interaction of 1) and 2).
            4) Project the relation from 3) onto attribute title and year.

            pi(title, year) (@length >= 100(Movies) AND @studioName = 'Fox'(Movies))

         8) Naming and Renaming

            In order to control the names of the attributes used for relations that are constructed by applying relational-algebra operations, it is often convinent to 
            use an operator that explicitly renames relations.

            Suppose we want to continue to use the name B for the attribute that comes from R, and we want to use X as the name of the attribute B coming from S. We can
            rename the attributes of S so the first is called X. The result of the expression ps(X,C,D)(S) is a relation named S that looks just like the relationship S
            from Fig.2.14, but its first column has attribute X instead of B.

            A|B|X|C|D
            ---------
            1|2|2|5|6 
            1|2|4|7|8
            1|2|9|10|11
            3|4|2|5 |6
            3|4|4|7 |8
            3|4|9|10|11

            a) R X ps(X,C,D)(S)

            As an alternative, we could take the product without renaming, and then rename the result. The expression

            pRS(A, B, X, C, D)(R x S)

         9) Relationships Among Operations

            Please see the paper notebook.

         10) A Linear Notation for Algebraic Expressions

            Please see the paper notebook.
         
         11) Constraints on Relations

            Please read the book.

Chapter 3:  Design Theory for Relational Databases

3.1      -  Functional Dependencies

            -  Definition

               A functional dependency(FD) on a relation R is a statement of the form "If two tuples of R agree on all of the attributes A1, A2,..., An", then they must
               also agree on all of another list of attributes B1, B2, ..., Bm. We write this FD formally as A1A2...An -> B1B2...Bm and say that

               "A1, A2,...,An functionally determine B1,B2...,Bm"

            -  It is important what when we say that R satisfies an FD f, we are asserting a constraint on R, not just saying something about one particular instance of R.
               It means that the FD says something about all possible instances of the relation, not about one of its instances. 

         -  Keys of Relationships.

            We say that a set of one or more attributes {A1, A2,..., An} is a key for a relation R if (why one or more?? Resolved.because sometimes a relation has more than one key):

            1. Those attributes functionally determine all other attributes of the relation. That is, it is impossible for two distinct tuples of R to agree on all of A1, A2, ...
               An.

            2. No proper subset of {A1, A2, ...An} functionally determines all other attributes of R; i.e., a key must be minimal.

            Sometimes a relation has more than one key and we choose one of the keys as the primary key(!!).

         -  Superkeys

            A set of attributes that contains a key is called a superkey.

3.2   Rules about Functional Dependencies

         -  Two sets of FD's S and T are equilvalent if the set of relation instances satisfying S is exactly the same as the set of relation instances satisfying T(??).

         -  More generally, a set of FD's S follows from a set of FD's T if every relation instance that satisfies all the FD's in T also satifies all the FD's in S(??).
      
      The Spliting/Combining Rule

         -  We can replace an FD A1A2...An -> B1B2...Bm by a set of FD's A1A2...An -> Bi for i=1, 2, ...m. This transformation we call the splitting rule.
         
         -  We can replace a set of FD's A1A2...Am -> Bi for i = 1, 2, ...m by the single FD A1A2...An -> B1B2...Bm. We call this transformation the combining rule.

         Note: there is no splitting rule for left side.

      Trivial Functional Dependencies

         A constraint of any kind on a relation is said to be trivial if it holds for every instance of the relation, regardless of what other constraints are assumed(??).
         When the constraints are FD's, it is easy to tell whether an FD is trivial. They are the FD's A1A2...An -> B1B2...Bm such that 

         {B1, B2, ..., Bm} belongs to {A1, A2, ..., An}

         That is a trivial FD has a right side that is a subset of its left side. For example
         
         title year -> title

         is a trivial FD, as is 

         title -> title.

      Computing the Closure of Attributes

         -  Suppose {A1, A2,..., An} is a set of attributes and S is a set of FD's. The closure of {A1, A2, ..., An} under the FD's in S is the set of attribute B such that
            every relation that satisfies all the FD's in set S also satifies A1A2...An -> B. That is, A1A2...An -> B follows from the FD's of S. 

            We denote the closure of a set of attributes A1A2...An by {A1, A2, ..., An}+. 

            Algorithm 3.7: Closure of a Set of Attributes.

            Input: A set of attributes {A1, A2, ..., An} and a set of FD's S.
            Output: The closure {A1, A2, ..., An} +.

            1. If necessary, split the FD's of S, so each FD in S has a single attribute on the right.

            2. Let X be a set of attributes that eventually will become the closure. Initialize X to be {A1, A2, ..., An}.

            3. Repeatedly search for some FD

               B1B2...Bm -> C

               such that all of B1, B2, ..., Bm are in the set of attributes X, but C is not. Add C to the set X and repeat the search. Since X can only glow, and the number of
               attributes of any relation schema must be finite, eventually nothing more can be added to X, and this step ends.

            4. The set X, after no more attributes can be added to it, is the correct value of {A1, A2, ..., An}+

            E.g. A relation with attributes A, B, C, D, E, and F. Suppose that this relation has the FD's AB->C, BC->AD, D->E, and CF->B. What is the closure of {A,B}, that is {A,B}+

            Step1: We split BC->AD into BC->A and BC->D.

            Step2: Start with X ={A,B}. 

            Step3: Since we have: AB->C, We add C to X, now X={A, B, C}
                  
                   BC-> and BC->D, then we have X={A, B, C, D}

                   D->E, we have X={A, B, C, D, E}
               
                   CF->B cannot be used, because its left side never becomes contained in X. Thus, {A, B}+ = {A, B, C, D, E}

      Why the Closure Algorithm works? ----> Skip

      The Transtitive Rule

      -  The transtitive rule lets us cascade two FD's, and generalizes the observation of Example 3.4.

         If A1A2...An -> B1B2...Bm and B1B2...Bm -> C1C2...Ck hold in relation R, then A1A2...An -> C1C2...Ck also holds in R.

Notes from Learning MySQL:

1. Login MySQL with the root user

   mysql -u root --password=<root user password>

   if you don't want others see your password, try this:

   mysql -u root -p
   Enter password:

2. Simple mysql commands:

   USE name_of_database;            //Choose the database "name_of_database"
   SELECT DATABASE();               //Check which database you have been using
   SHOW TABLES;                     //Explore what tables make up the database
   SHOW COLUMNS FROM name_of_table  //To explore the table "name_of_table"
   DESC name_of_table               //the same as the above command

-  Modeling and Designing Databases

   There are three major stages in database design, each producing a progressively lower-level description:

   1. Requirement analysis

   We need to determine and write down what exactly the database is needed for. Some questions you need to ask for yourself?

   What data will be stored?
   How the data items relate to each other
   
   2. Conceptual design

   3. Logical design

   Finally, we map the database design onto an actual database management system and database tables;

-  The Entity Relationship Model

   At a basic level, databases store information about distinct object, or entities, and the associations, or relationships, between these entities. 

   Entity set - it is represented by a rectangle containing the entity name. 
   Attributes - the certain characteristics or the entities. An attribute may be formed from smaller parts; for example, a postal address is composed of a street
                number, city, ZIP code, and country. We classify attributes as composite if they're composed of smaller parts in this way.
                Clearly, there may be several possible keys that could be used to identify an entity; we choose one of the alternative, or candidate, keys to be
                our main, or primary key. You usually make this choice based on how confident you are that the attribute will be non-empty and unique for each
                individual entity.  In the ER diagram, attributes are represented as labeled ovals and are connected to their owning entity. For some applications,
                no combination of attributes can uniquely identify an entity(or it would be too unwieldy to use a large composite key), so we create an artificial
                attribute that's defined to be unique and can therefore be used as a keyl student number, Social Security numbers, driver's license number...
  Relationships - We represent a relationship set with a named diamond. 

-  Representing Relationships

   many-to-many relationship (M:N)
   one-to-many relationship (1:N)
   many-to-one relationship (N:1)
   one-to-one relationship (1:1)
   
-  The SELECT Statement and Basic Querying Techniques:

   Single Table SELECTs

   SELECT * FROM artist;

   A simple SELECT statement has four components:

   1. The keyword SELECT.
   2. The columns to be displayed. In our first example, we asked for all columns by using the asterisk(*) symbol as a wildcard character.
   3. The keyword FROM.
   4. The table name; in this example, the table name is artist.

   -  Choose columns

   mysql> SELECT artist_name FROM artist;
   
   mysql> SELECT artist_name and, artist_id FROM artist;
   
   You can even list columns more than once:

   mysql> SELECT artist_id, artist_id FROM artist;

   You can specify databases, tables, and column names in a SELECT statement. This allows you to avoid the USE command and work with any database and table
   with SELECT. Consider an example: you want to retrieve the album_name column from the album table in the music database. You can do this with the following
   command:

   mysql> SELECT album_name FROM music.album;

-  Choosing Rows with the WHERE Clause.

   Consider an example where we want to find out the details of the artist with the name "New Order." Here's what you type:

   mysql > SELECT * FROM artist WHERE artist_name = "New Order"

   Another example:

   mysql > SELECT artist_name FROM artist WHERE artist_id=4;

   This example chooses one column and one row.

   If a match matches more than one row, the results will contain all matches.

   In a range:
      
   mysql> SELECT artist_name FROM artist WHERE artist_id < 5

   Consider that if you want to find all albums that don't have an album_id of 2, you'd type:

   mysql> SELECT album_name FROM album WHERE album_id <> 2;

   You can also list all artists whose name appears earlier alphabetically than (is less than) 'M', use:

   mysql> SELECT artist_name FROM artist WHERE artist_name < 'M';

   (by default, MySQL doesn't care about case)

   Another very common task you'll want to perform with strings is to find matches that begin with prefix, contain a string, or end in a suffix. For example, 
   you might want to find all album names beginning with the word "Retro". Do this with the LIKE operator in a WHERE clause:

   mysql> SELECT album_name FROM album WHERE album_name LIKE "Retro%"

   The above example shows that the wildcard character "%" matches all possible strings. You can also do:

   "%ing" - a string that ends in a suffix.
   "%ing%" - matches all strings that have "ing" in them.

   If you want to match exactly one wildcard character in a LIKE clause, you use the underscore character (_). For example, if you want all tracks that begin
   with a three letter word that starts with 'R', you use:
   
   mysql> SELECT * FROM track WHERE track_name LIKE "R__%"

-  Combining conditions with AND, OR, NOT, and XOR

   Use two or more conditions using the Boolean operators AND, OR, NOT, and XOR.

   mysql> SELECT album_name FROM album WHERE
       -> album_name > "C" AND album_name < "M";

   mysql> SELECT album_name FROM album WHERE
      -> album_name LIKE "L%" OR
      -> (album_name LIKE "S%" AND album_name LIKE "%g")

   It is recommended that you use parentheses whenever there is a chance the intention could be misinterrupted.

   The unary NOT operator negates a Boolean statement. Suppose that you want a list of all albums except the ones having an album_id of 1 or 3. You'd write the query:

   mysql> SELECT * FROM album WHERE NOT(album_id = 1 OR album_id = 3);

   You can combine the NOT operation with LIKE. Suppose you want all albums that don't begin with an L; To do this, type:

   mysql> SELECT album_name FROM album WHERE album_name NOT LIKE "L%"

-  ORDER by Clauses

   There is no intrinsic order between the rows, and so we have to ask MySQL to sort the result if we want them in a particular order. Suppose you want to return a list
   of the artists in the music database, sorted in alphabetical order by the artist_name. Here's what you'd type.

   mysql> SELECT * FROM artist ORDER BY artist_name;

   The default sort is case-insensitive and in ascending order. The way strings are sorted is determined by the character set and collation order that are being used(discussed
   later).

   In the following example, when the track times are the same, we'll sort the answers alphabetically by track_name. 

   mysql> SELECT time, track_name FROM track ORDER BY time, track_name;

   | 2.90 | I Just Want To See His Face
   | 2.97 | Sweet Black Angel
   ...
   | 3.40 | Under The Influence Of Love
   | 3.40 | Ventilator Blues
   ...

   Notice that there's a collision of track times where the length is 3.40. In this case, the second sort key, track_name is used to resolve the collisons so that "Under The 
   Influence Of Love" appears before "Ventilator Blues".

   Also, you can sort in descending order:

   mysql> SELECT artist_name FROM artist ORDER by artist_name DESC;

   You can also use a mixture of ascending and descending orders when multiple sort keys are used. E.g.

   mysql> SELECT time, track_name FROM track
         -> WHERE time < 3.6
         -> ORDER BY time DESC, track_name ASC;

   If a collision of values occur, and you don't specify another sort key, the sort order is underfined. A common source of collision is string sorting, where MySQL ignores
   the case of characters. If you do want sorting like ASCII does(WHERE uppercase comes before lowercase), then you can add BINARY keyword to your sort as follows:

   mysql> SELECT * FROM artist ORDER by BINARY artist_name;

   or

   mysql> SELECT track_name FROM track WHERE track_name < BINARY 'b';

   Sorting is performed as appropriate to the column type. For example if you're sorting dates, it organizes the rows in ascending data order. You can force the sort to behave
   differently, using CAST() function and the AS keyword. E.g. if you want to sort the track table by ascending time, but you want the times to be treated as strings. Here's how
   you do it:

   mysql> SELECT time, tracktime FROM track ORDER by CAST(time AS CHAR); The CAST() function forces a column to be treated as a different type. You can specify:

   AS BINARY, to sort as binary, which has the same effect as ORDER BY BINARY
   AS SIGNED, to sort as a signed integer
   AS UNSIGNED, to sort as an unsigned integer
   AS CHAR, to sort as a character string
   AS DATE, to sort as a date
   AS DATETIME, to sort as a date and time
   AS TIME, to sort as a time

-  The LIMIT Clause

   The LIMIT clause is a useful, nonstandard SQL tool that allows you to control which rows are output. E.g. in a web database application, where you want to find the rows
   that match a condition but only want to show the user the first 10 rows in a web page.

   mysql> SELECT track_name FROM track LIMIT 10;

   The above example restricts the output to the first 10 rows. The LIMIT clause can be used to return a fixed number of rows beginning anywhere in the result set. E.g.

   mysql> SELECT track_name FROM track LIMIT 5,5;

   The above example shows that you want 5 rows but you want the first one displayed to be the sixth row of the answer. The output is rows 6 to 10 from the SELECT query.

   You can also write LIMIT 10 OFFSET 5.

-  Joining Two tables;

   mysql> SELECT artist_name, album_name FROM artist INNER JOIN album
         -> USING (artist_id)

   How INNER JOIN works?

   The statement has two parts: first, two table names seperated by the INNER JOIN keywords; second, the USING keyword that indicates which column (or columns) holds
   the relationship between the two tables. Also, the USING clause in the example is USING (artist_id), which tells MySQL that the column that holds the relationship
   between the tables is artist_id; 

   There are a few important issues you need to know about when using the basic INNER JOIN syntax.

   -  It works only when two tables share a column with the same name that you can use as the join condition;
   -  The result rows shown are those where the join column (or columns) match between the tables; rows from one table that don't have a match in the other table are
      ignored. In the previous example, any artist who had no albums would be ignored.
   -  With the exception of the join column or columns after the USING keyword, any columns you specify must be unambiguous. For example, if you want to SELECT the artist_name
      , you must use just artist_name because it exists only in the artist table. However, if you want artist_id, then you need to specify it explicitly as artist.artist_id or
      album.artist_id because both tables have a column of the same name.
   -  don't forget the USING clause. MySQL won't complain if you omit it, but the results won't make sense because you'll get a Cartesian product.
   -  The columns or columns following the USING clause must be surrounded by parentheses. If you want to join on more than one column, seperate the column names with a comma.

      +-----------+-------------+----------+------------------------------------------+
      | artist_id | artist_name | album_id | album_name                               |
      +-----------+-------------+----------+------------------------------------------+
      | 1         | New Order   | 1        | Retro - John McCready FAN                |
      | 1         | New Order   | 2        | Substance (Disc 2)                       |
      | 1         | New Order   | 3        | Retro - Miranda Sawyer POP               |
      | 1         | New Order   | 4        | Retro - New Order / Bobby Gillespie LIVE |
      | 1         | New Order   | 5        | Power, Corruption & Lies                 |
      | 1         | New Order   | 6        | Substance 1987 (Disc 1)                  |
      | 1         | New Order   | 7        | Brotherhood                              |
      +-----------+-------------+----------+------------------------------------------+

   mysql> SELECT album_name, track_name FROM album INNER JOIN track
         -> USING (artist_id, album_id) LIMIT 15;

-  the INSERT Statement

    -   Basics:

    The Insert statement is used to add new data to tables. There are 2 situations:

    1) bulk-load in a large batch

    Example:

    mysql> INSERT INTO artist VALUES (7, "Barry Adamson")
    
    2) add data on ad hoc basis

    mysql> INSERT INTO track VALUES (1, "Diamonds", 7, 1, 4.10),
    -> (2, "Boppin Out / Eternal Morning", 7, 1, 3.22),
    -> (3, "Splat Goes the Cat", 7, 1, 1.39),
    -> (4, "From Rusholme With Love", 7, 1, 3.59);
    Query OK, 4 rows affected (0.00 sec)
    Records: 4 Duplicates: 0 Warnings: 0

    -   Alternative Syntaxes:

    1. Three disadvantages of the VALUES syntax we've shown you.

    -   First, you need to remember the order of the columns;
    -   Second, you need to provide a value for each colummn;
    -   Last, it’s closely tied to the underlying table structure: if you change the table’s
        structure, you need to change the INSERT statements, and the function of the INSERT
        statement isn’t obvious unless you have the table structure at hand.

    Suppose you know that the album table has three columns and you recall their names, but you forget their order, you can use the following approach:

    mysql> INSERT INTO album (artist_id, album_id, album_name)
    -> VALUES (7, 2, "Oedipus Schmoedipus");
    Query OK, 1 row affected (0.00 sec)

    The disadvantage of this approach are that you can accidentally omit values for columns, and you need to remember and type column names. The omitted columns will
    be set to the default values.

    2.  The () syntax is used to represent that all columns and values are to be set to their defaults. E.g.

    mysql> INSERT INTO played () VALUES ();
    Query OK, 1 row affected (0.00 sec)

    3.  

    mysql> INSERT INTO played VALUES (7, 1, 2, DEFAULT);
    Query OK, 1 row affected (0.00 sec)

    The advantage of this approach is that you can use the bulk-insert feature with default values, and you can never accidentlly omit a column.

    4.  

    mysql> INSERT INTO played
    -> SET artist_id = 7, album_id = 1, track_id = 1;
    Query OK, 1 row affected (0.00 sec)

    In this approach, you list the column name and value together, giving the advantage that you don’t have to mentally map the list
    of values to the earlier list of columns. A significant additional disadvantage is that you can’t use this method for bulk insertion.

-   The DELETE Statement

    -   Basics

    The Delete statement s used to remove one or more rows from a database. Remember that DELETE doesn't remove the table itself. To reset or modify
    a vale in a row, you can use the UPDATE statement.

    1) Remove all rows in a table:

    mysql> DELETE FROM played;

    2) To remove one or more rows but not all rows, use the WHERE clause:

    mysql> DELETE FROM played WHERE played < "2006-08-15"

    another example:

    mysql> SELECT artist_id FROM artist WHERE artist_name = "Miles Davis";

    +-----------+
    | artist_id |
    +-----------+
    |         3 |
    +-----------+
    1 row in set (0.00 sec)
    
    mysql> DELETE FROM artist WHERE artist_id=3;

    3) You can use ORDER BY and LIMIT clauses with DELETE. You usually want to do this when you want to limit the number of rows deleted.

    Suppose you played table contains 10,528 rows, but you want to have at most 10,000 rows. In this situation, it may make sense to remove the 528 oldest rows, 
    and you can do this with the following statement:

    mysql> DELETE FROM played ORDER BY played LIMIT 528;
    Query OK, 528 rows affected (0.23 sec)

    The query sorts the rows by ascending play date and then deletes at most 528 rows, starting with the oldest.

    Typically, when you’re deleting, you use LIMIT and ORDER BY together; it usually doesn’t make sense to use them separately.

-   TRUNCATE Statement:

    By using the TRUNCATE TABLE statement, MySQL takes the shortcut of dropping the table—that is, removing the table structures and then re-creating them.
    When there are many rows in a table, this is much faster.

    1) Remove all rows in a table:

    mysql> TRUNCATE TABLE played;
    Query OK, 0 rows affected (0.00 sec)

    The TRUNCATE TABLE statement has two other limitations:
    • It’s actually identical to DELETE if you use InnoDB tables.
    • It does not work with locking or transactions(??).

-   UPDATE Statement

    The UPDATE statement is used to change data.

    -   Change all rows in a table:

    example 1: change the artist names to uppercase.

    mysql> UPDATE artist SET artist_name=UPPER(artist_name);

    Note: the UPPER function returns the uppercase version of the text passed as the parameter; the function LOWER performs the reverse.

    example 2: set columns a single value. 

    mysql> UPDATE played SET played = NULL;
    
    Note: since the default value of the played column is CURRENT_TIMESTAMP, passing a NULL value causes the current date and time to be stored instead.

    example 3: use SELECT clause:
    
    mysql> SELECT * FROM album WHERE album_name LIKE ->
    "Substance%";

    example 4: use the ORDER and LIMIT clauses:

    mysql> UPDATE played SET played = NULL ORDER BY played DESC LIMIT 10;

    -   More description of the UPDATE statement:

    There are two phases: 1) a matching phase; 2) modification phase

    1) matching phase:

    where rows are found that match with the "WHERE" clause or "ORDER BY" clauses;

    2) modification phase:

    where the rows that need changing are updated.

-  CREATE clause:

   Creating a database:
   
   mysql> CREATE DATABASE hibernate;

   Creating Tables:

   mysql> DROP DATABASE hibernate;
   
   CREATE TABLE artist (
      -> artist_id SMALLINT(5) NOT NULL DEFAULT 0,
      -> artist_name CHAR(128) DEFAULT NULL,
      -> PRIMARY KEY (artist_id)
      -> );

   Column specifications: name type [NOT NULL | NULL] [DEFAULT value].

   NOT NULL: a row isn't valid without a value for the column.
   NULL or omit the clause: a row can exist without a value for the column.
   DEFAULT: it will be used to populate the column when you don't otherwise provide a data. The value must
            be a constant except if the column is of the type TIMESTAMP.

   -  IF NOT EXISTS keyword phrase when creating a table, and it works much as it does for databases. Here is 
      an example that won't report an error even when the artist table exists.

   
      mysql>
      ->CREATE TABLE IF NOT EXISTS artist (
      ->artist_id SMALLINT(5) NOT NULL DEFAULT 0,
      ->artist_name CHAR(128) DEFAULT NULL,
      ->PRIMARY KEY (artist_id)
      );

      Query OK, o rows affected (0.00sec)

   -  AUTO_INCREMENT feature for numeric columns.

      This feature allows you to automatically create unique identifier for a table.

   -  Column comments;

   -  Foreign key constraints

   -  Creating temporary tables

   -  SHOW CREATE TABLE

   You can use SHOW CREATE TABLE statement for a table using the SHOW CREATE TABLE statement introduced in Chapter 5. This often shows you output that include some of the
   advanced features we just discussed.

-   ALTER statement

    -   You can use the ALTER TABLE statement to add new columns to a table, removing existing columns, and change column names, types, and lengths.

        example1: Change the column named "played" to "last_played"

        mysql> ALTER TABLE played CHANGE played last_played TIMESTAMP;

        Note: you have to provide 4 parameters:

        table name
        old column name
        new column name
        type of the new column

        example 2: rename the artist_name column to artist-name:

        mysql> ALTER TABLE artist CHANGE artist_name artist-name CHAR(128) DEFAULT NULL;

        example 3: if you want to modify the type and clauses(??) of a column, use MODIFY statement.

        mysql> ALTER TABLE artist MODIFY artist_name CHAR(64) DEFAULT "Unknown";

        or can use the CHANGE keyword but add twice of the column name:

        ALTER TABLE artist CHANGE artist_name artist_name CHAR(64) DEFAULT "Unknown";

    -   Warning!!

        1) Don’t use incompatible types, since you’re relying on MySQL to successfully con-
        vert data from one format to another (for example, converting an INT column to a
        DATETIME column isn’t likely to do what you hoped).

        2) Don’t truncate the data unless that’s what you want. If you reduce the size of a
        type, the values will be edited to match the new width, and you can lose data.

    -   Continue examples...

        example 4: Add an extra column into an existing table:

        mysql> ALTER TABLE artist ADD formed YEAR;

        Note, by default, the new column is added at the end of the table, if you want to insert it to the top, use the FIRST keyword:

        mysql> ALTER TABLE artist ADD formed YEAR FIRST;

        or if you want to add to a specified position, use the AFTER keyword:

        mysql> ALTER TABLE artist ADD formed YEAR AFTER artist_id;

        example 5: to remove a column, use the DROP keyword:

        mysql> ALTER TABLE artist DROP formed;

        Note: can't do this if the column you trying to delete is the only column in the table.

        example 6: specify multiple alterations in a single ALTER clause:

        mysql> ALTER TABLE artist ADD formed YEAR, MODIFY artist_name char(256);

    -   Adding, Removing and Changing indexes.

        example 7: add a new index:

        mysql> ALTER TABLE artist ADD INDEX by_name (artist_name);

        Note: 

        1) "by_name" is the name of the index you're trying to add:
        2) You can use the terms "KEY" and "INDEX" interchangeably. Remember to check the results with the SHOW CREATE TABLE.

        example 8: Specify a primary key for a table after it's create.

        mysql> ALTER TABLE artist ADD PRIMARY KEY(artist_id);

        example 8: remove a non-primary-key(??why it must be a non-primary key) index:

        mysql> ALTER TABLE artist DROP INDEX by_name;

        example 9: drop a primary-key index:

        mysql> ALTER TABLE artist DROP PRIMARY KEY;

        Note: MySQL won’t allow you to have multiple primary keys in a table. If you want to change
        the primary key, you’ll have to remove the existing index before adding the new one.

        example 10: You cannot modify index once it's been created. But if you want to for example to
        reduce the number of characters indexed from a column:

        For example, suppose you decide that you want the by_name index to include only the first 10 characters of the
        artist_name. Simply do the following: or add another column to the index. The best method to do this is to drop the index
        and then create it again with the new specification. 

        mysql> ALTER TABLE artist DROP INDEX by_name;
        mysql> ALTER TABLE artist ADD INDEX by_name (artist_name(10));

    -   Renaming Tables and Altering Other Structures

        mysql> ALTER TABLE played RENAME TO playlist;

        The To keyword is optional

        You can do lot more shits with ALTER statement:

        1) Change the default character set and collation order for a database, a table, or a
        column.

        2) Change the order of the rows in a table. This is useful only if you know you want
           to access the rows in a particular order and you want to help get the data into or
           near that order.

        3) Manage and change constraints. For example, you can add and remove foreign keys.
    
-   DROP statement

    -   The following shows you how to remove databases and tables. Previously, we have shown the how to remove columns

        Example1: drop the whole database:

        mysql> DROP DATABASE music;

        Example2: To avoid database non-existing error.

        mysql> DROP DATABASE IF EXISTS music;

        Example 3: Remove tables:

        mysql> DROP TABLE temp;

        or 

        mysql> DROP TABLE IF EXISTS temp;

-   Aliases

    -   Column Aliases
        
    Column aliases are useful for improving the expression of your queries, reducing the
    number of characters you need to type, and making it easier to work with languages
    such as PHP.

    example 1:

    mysql> SELECT CONCAT(artist_name, " recorded ", album_name) AS recording
    -> FROM artist INNER JOIN album USING (artist_id)
    -> ORDER BY recording;

    +-------------------------------------------------------------+
    | recording
    |
    +-------------------------------------------------------------+
    | Kylie Minogue recorded Light Years
    |
    | Miles Davis recorded In A Silent Way
    |
    | Miles Davis recorded Live Around The World
    |
    | New Order recorded Brotherhood
    |
    | New Order recorded Power, Corruption & Lies
    |
    | New Order recorded Retro - John McCready FAN
    |
    | New Order recorded Retro - Miranda Sawyer POP
    |
    | New Order recorded Retro - New Order / Bobby Gillespie LIVE |
    | New Order recorded Substance (Disc 2)
    |
    | New Order recorded Substance 1987 (Disc 1)
    |
    | Nick Cave & The Bad Seeds recorded Let Love In
    |
    | The Rolling Stones recorded Exile On Main Street
    |
    | The Stone Roses recorded Second Coming
    |
    +-------------------------------------------------------------+

    Note: The MySQL function CONCAT() concatenates together the strings that are parameters 
    —in this case, the artist_name, a constant string recorded, and the album_name to give
    output such as New Order recorded Brotherhood. We’ve added an alias to the function,
    AS recording, so that we can refer to it easily as recording throughout the query. You
    can see that we do this in the ORDER BY clause, where we ask MySQL to sort the output
    by ascending recording value. This is much better than the unaliased alternative, which
    requires you to write out the CONCAT( ) function again(??):

    mysql> SELECT CONCAT(artist_name, "recorded ", album_name)
    -> FROM artist INNER JOIN album USING (artist_id)
    -> ORDER BY CONCAT(artist_name, " recorded ", album_name)

    -   Restrictions

    You can't use them in a WHERE clause, or in the USING and ON clauses that we discuss later in this chapter. This means that
    you can't write a query such as:

    mysql> SELECT artist_name AS a FROM artist WHERE a = "New Order";
    ERROR 1054 (42S22): Unknown column 'a' in 'where clause'

    You can't do this because MySQL doesn't always know the column values before it executes the WHERE clause. However, you can use
    column alias in the ORDER BY clause, and in the GROUP BY and HAVING clauses discussed later in this chapter.

    -   Table Aliases

    Example: 

    mysql> SELECT ar.artist_id, al.album_name, ar.artist_name FROM
    -> album AS al INNER JOIN artist AS ar
    -> USING (artist_id) WHERE al.album_name = "Brotherhood";

    al: album's alias
    ar: artist's alias

    Notice that you can use table alias in the WHERE clause, unlike column aliases, there are no restrictions on where table aliases 
    can be used in queries.

    Example: How to use one single query to know if two albums have the same name. 

    mysql> SELECT * FROM WHERE album_name = album_name; (wrong!!)

    This doesn't make sense since an album has the same name as itself. so it just produces all albums as output:

    The key is to give the table two different aliases:
    
    mysql> SELECT a1.artist_id, a2.album_id
    -> FROM album AS a1, album AS a2 WHERE
    -> a1.album_name = a2.album_name; (wrong!!)

    Why it still doesn't work? The reason is that an album still matches itself because it occurs in both aliased tables.

    mysql> SELECT a1.artist_id, a2.album_id
    -> FROM album AS a1, album AS a2 WHERE
    -> a1.album_name = a2.album_name
    -> AND a1.album_id != a2.album_id;

-   Aggregating Data

    Aggregate functions allow you to discover the properties of a group of rows. For what purposes such as?

    1) Discovering how many rows there are in a table?
    2) Discovering how many rows in a table share a property (such as having the same name or date of birth)
    3) Finding averages (such as average temperature in November)
    4) Finding the max/min value of rows that meet some conditions (such as finding the coldest day in August)

    -   The DISTINCT Clause

    This isn't really an aggregate function, but more of a post-processing filter that allows you to remove duplicates. We've added
    it into this section because, like aggregate functions, it's concerned with picking examples from the output of a query, rather
    than processing individual rows.

    mysql> SELECT DISTINCT artist_name FROM
    -> artist INNER JOIN album USING (artist_id);

    
    +---------------------------+
    | artist_name               |
    |                           |
    +---------------------------+
    | New Order                 |
    |                           |
    | Nick Cave & The Bad Seeds |
    | Miles Davis               |
    |                           |
    | The Rolling Stones        |
    |                           |
    | The Stone Roses           |
    |                           |
    | Kylie Minogue             |
    |                           |
    +---------------------------+

    If you remove "DISTINCT", you get:

    
    +---------------------------+
    | artist_name               |
    |                           |
    +---------------------------+
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | Nick Cave & The Bad Seeds |
    | Miles Davis               |
    |                           |
    | Miles Davis               |
    |                           |
    | The Rolling Stones        |
    |                           |
    | The Stone Roses           |   
    |                           |
    | Kylie Minogue             |
    |                           |
    +---------------------------+

    So, the DISTINCT clause helps get a summary.

    The DISTINCT clause applies to the query output and removes rows that have identical values in the columns selected for output in the query.

    -   GROUP BY clause
    
    The GROUP BY clause sorts data into groups for the purpose of aggregation

    It’s similar to ORDER BY, but it occurs much earlier in the query process: GROUP BY is used to organize
    the data before other clauses—such as WHERE, ORDER BY, and functions—are applied. In contrast, ORDER BY 
    is applied last—after the query has been resolved—to reorganize the query output for display.

    Example: Suppose you want to know how many albums we own by each artist. 

    mysql> SELECT artist_name FROM
    -> artist INNER JOIN album USING (artist_id)
    -> ORDER BY artist_name;

    +---------------------------+
    | artist_name               |
    |                           |
    +---------------------------+
    | Kylie Minogue             |
    |                           |
    | Miles Davis               |
    |                           |
    | Miles Davis               |
    |                           |
    | New Order                 |   
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | New Order                 |
    |                           |
    | Nick Cave & The Bad Seeds |
    | The Rolling Stones        |
    |                           |
    | The Stone Roses           |
    |                           |
    +---------------------------+
    13 rows in set (0.00 sec)

    It is easy to count how many albums we've got by each artist: one by Kylie, two by Miles and 7 by New Order and so on.

    The GROUP BY clause can help automate this process by grouping the albums by artist; We can use the COUNT() function to count 
    off the number of albums in each group. Here is the query:

    mysql> SELECT artist_name, COUNT(artist_name) FROM
    -> artist INNER JOIN album USING (artist_id)
    -> GROUP BY artist_name;
    

    +---------------------------+--------------------+
    | artist_name               |                    |   
    | COUNT(artist_name)        |                    |   
    +---------------------------+--------------------+
    | Kylie Minogue             |                    |
    |                           |                    |
    1                           |                    |
    | Miles Davis               |                    |
    |                           |                    |
    2                           |                    |
    | New Order                 |                    |
    |                           |                    |
    7                           |                    |
    | Nick Cave & The Bad Seeds |                    |
    1                           |                    |
    | The Rolling Stones        |                    |
    |                           |                    |
    1                           |                    |
    | The Stone Roses           |                    |
    |                           |                    |
    1                           |                    |
    +---------------------------+--------------------+
    6 rows in set (0.01 sec)

    We are telling MySQL that the ways to group rows is by artist_name. The result is that rows for artists with the same name from a cluster - that is, each distinct
    name becomes one group. Once the rows are grouped, they're treated in the rest of the query as if they're one row.

    
            
        

        

    
    
    
            
        

    -  Column Types

       -  INT(width) [UNSIGNED] [ZEROFILL]
       -  DECIMAL[width[,decimals])]  [UNSIGNED] [ZEROFILL]

      A commonly used numeric type. Stores a fixed-point number such as a salary or distance. with a total of width of which some smaller number are decimals that follow a decimal
      point. For example, a column declared as price DECIMAL(4,2) should be used to store values in the range -99.99 to 99.99. if you try to store a value that is outside this range,
      it will be stored as the closet value in the allowed range. For example, 100 should be stored as 99.99, -100 would be stored as -99.99.

   -  DATE

      Stores and displays a date in the format YYYY-MM-DD for the range 1000-01-01 to 9999-12-31

   -  TIME

      Stores a time in the format HHH:MM:SS for the range -838:59:59 to 838:59:59

   -  TIMESTAMP

      Stores and display a date and a time pair in the format: YYYY-MM-DD HH:MM for the range 1970-01-01 00:00:00 to sometime in 2037. The key features of TIMESTAMP column are twofold:

      1) Assign NULL to set to the current date and time.
      2) A developer-selected TIMESTAMP column in a table can be automatically updated to the current date and time when a row is inserted or updated.
      
      If you specify DEFAULT NULL for a TIMESTAMP column, it will be interpreted differently depending on whether there are any other TIMESTAMP before it in the table. 
      DEFAULT NULL is handled.

      - The automatic-update feature in detail:

        0) Only one TIMESTAMP column per table can be automatically set to the current date and time on insert or update. You can contrl this by following following steps:

        1) Choose the column you want to automatically update

        2) If you have other TIMESTAMP columns in the table, set the ones that precede the selected column in the CREATE TABLE statement to have a constant default (such
            as DEFAULT 0).

        3) For the automatically updating column, decide which behavior you want:

        a.  If you want the timestamp to be set only when a new row is inserted into the table, add DEFAULT CURRENT_TIMESTAMP to the end of the column dec-laration.
        b.  If you don’t want a default timestamp but want the current time to be used whenever the data in a row is updated, add ON UPDATE CURRENT_TIMESTAMP to the 
            end of the column declaration.
        c.  If you want both of the above—that is, you want the timestamp to be set to the current time in each new row or whenever an existing row is modi-fied— add 
            DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP to the end of the column declaration.

        E.g.

        mysql> CREATE TABLE mytime(id INT NOT NULL,
                            -> changetime TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                            -> );

    -   CHAR[(width)]

        1) If the width is not provided, CHAR(1) is assumed;
        2) Define a special CHAR(0) NULL column that takes up only one bit of storage. Two handy features with these approaches:

            -   It allows you to include a dummy column in a table that doesn't do anything.
            -   It allows you to store one of two values: NULL or the empty string '', giving you very compact storage of binary (Boolean) values(??).

            E.g.

            
            mysql> CREATE TABLE bool(id INT, bit CHAR(0) NULL);
            Query OK, 0 rows affected (0.02 sec)

        3)  In all other cases, the CHAR type takes exactly the number of bytes in storage space as the width of the column. Values that are less than width characters
            in length are stored left-aligned in the allocated space, with space character padding on the right side. All trailing spaces are ignored when receiving and
            displaying values, as in this example:

    -   Other integer types

        -   BOOLEAN

        The BOOLEAN type has the synonyms BOOL and BIT. It's equivalent to TINYINT(1), and so requires one byte of storage space; you can achieve more compact, one-bit
        Boolean values by using CHAR(0), as described previously.

        -   TINYINT[width][UNSIGNED][ZEROFILL]

            one byte

            Stores integer (whole number) values in the range -128, 127. When UNSIGNED is used, the range is changed to 0-255
        
        -   SMALLINT[width][UNSIGNED][ZEROFILL]

            two bytes

            Stores integer (whole number) values in the range -32768, 32767. When UNSIGNED is used, the range is changed to 0-65535

        -   MEDIUMINT[width][UNSIGNED][ZEROFILL]

            3 bytes

            Stores integer (whole number) values in the range -8388608, 8388607. When UNSIGNED is used, the range is changed to 0-16777215

        -   BIGINT[width][UNSIGNED][ZEROFILL]

            8 bytes

            Stores integer (whole number) values in the range -9223372036854775808, 89223372036854775807. When UNSIGNED is used, the range is changed to 0-
            18,446,744,073,709,551,615.

    -   Other rational number types

        DOUBLE(also known as REAL)
        FLOAT

        FLOAT[(width, decimals)] [UNSIGNED] [ZEROFILL] or FLOAT[(precision)] [UNSIGNED]
        [ZEROFILL]

        
        DOUBLE[(width, decimals)] [UNSIGNED] [ZEROFILL]

    -   Other date and time types

        YEAR[(digits)]

        DATETIME

    -   Other String types

        VARCHAR(width)

        It stores variable-length strings. The max(width) is 65535

        A VARCHAR type incurs one or two extra bytes of overhead to store the length of the
        string, depending on whether the string is shorter than or longer than 255 characters.
        Trailing spaces are removed when a value is stored; you can use TEXT or BLOB types
        to avoid this behavior(!!).

    -   BINARY(width) and VARBINARY(width)

    -   BLOB

    -   TEXT
        
    -   TINYBLOB and TINYTEXT

    -   MEDIUMBLOB and MEDIUMTEXT

    -   LONGBLOB and LONGTEXT

    -   ENUM('value1'[,'value2'[, ...]]

    -   SET('value1'[,'value2'[, ...]])

-   Keys and Indexes(!!)

    A primary key uniquely identifies each row in a table. When you declare one to MySQL, it increases a new file on disk that stores information, about where
    the data from each row in the table is stored. This information is called index. and its purpose is to speed up searches that use the primary key.

    mysql> show index from artist;
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
    | Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
    | artist |          0 | PRIMARY  |            1 | artist_id   | A         |           3 |     NULL | NULL   |      | BTREE      |         |               |
    +--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
    1 row in set (0.00 sec)

    -   Cardinality: the number of unique values in the index.

    -   Note that all columns that are part of a primary key must be declared as NOT NULL.

    -   You can create other indexes on the data in a table. You can drop the table and modifiy the CREATE TABLE definition to add an extra index. E.g.

        mysql> DROP TABLE artist;
        Query OK, 0 rows affected (0.01 sec)

        
        mysql> CREATE TABLE artist (
        -> artist_id SMALLINT(5) NOT NULL DEFAULT 0,
        -> artist_name CHAR(128) DEFAULT NULL,
        -> PRIMARY KEY (artist_id),
        -> KEY artist_name (artist_name)
        -> );
        Query OK, 0 rows affected (0.06 sec)

        We have used the keyword KEY to tell MySQL that we want an extra index. Following this, we've named the index, in this example, we've named it after the column
        name - and then we've included the column to index in parntheses.You can also add indexes after tables are created - in fact, you can pretty much change anything
        about a table after its creation. 

        You can build an index on more than one column. For example, consider the following customer table:

        mysql> CREATE TABLE customer (
        -> cust_id INT(4) NOT NULL DEFAULT 0,
        -> firstname CHAR(50),
        -> secondname CHAR(50),
        -> surname CHAR(50),
        -> PRIMARY KEY (cust_id),
        -> KEY names (firstname, secondname, surname));
        Query OK, 0 rows affected (0.01 sec)

        Note: we've also added another index - called names that includes firstname, secondname, surname columns in this order.

        So now you can use the names index for fast searching:

        
        mysql> SELECT * FROM customer WHERE
        -> firstname = "Rose" AND
        -> secondname = "Elizabeth" AND
        -> surname = "Williams";

        You can use the "EXPLAIN" statement to check whether what you think should happen is in fact happening:

        mysql> EXPLAIN SELECT * FROM customer WHERE
        -> firstname = "Rose" AND
        -> secondname = "Elizabeth" AND
        -> surname = "Williams";

        ---------------------------------------------------------------------------------------------------------
        Other examples: 

        mysql> desc artist;
        +-------------+-------------+------+-----+---------+-------+
        | Field       | Type        | Null | Key | Default | Extra |
        +-------------+-------------+------+-----+---------+-------+
        | artist_id   | smallint(5) | NO   | PRI | 0       |       |
        | artist_name | char(128)   | YES  |     | NULL    |       |
        +-------------+-------------+------+-----+---------+-------+
        2 rows in set (0.01 sec)
        
        mysql> explain select * from artist where artist_id < 3;
        +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
        | id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
        +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
        |  1 | SIMPLE      | artist | range | PRIMARY       | PRIMARY | 2       | NULL |    2 | Using where |
        +----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
        1 row in set (0.02 sec)

        mysql> explain select * from artist where artist_name="Alex Yu";
        +----+-------------+--------+------+---------------+------+---------+------+------+-------------+
        | id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra       |
        +----+-------------+--------+------+---------------+------+---------+------+------+-------------+
        |  1 | SIMPLE      | artist | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using where |
        +----+-------------+--------+------+---------------+------+---------+------+------+-------------+
        1 row in set (0.00 sec)

        Note: if not index is used in the query, the key shows "NULL".
        ---------------------------------------------------------------------------------------------------------

        But(!!):

        if we do:

        mysql> SELECT * FROM customer WHERE
        -> surname = "Williams" AND
        -> secondname = "Elizabeth";

        The query cannot be indexed for this query because the leftmost column in the index, firstname, does not appear in the query:

        For MySQL to be able to use an index, the query needs to meet both the following
        conditions:

        1.  The leftmost column listed in the KEY (or PRIMARY KEY) clause must be in the query.
        2.  The query must contain no OR clauses for columns that aren’t indexed.

        Here are a few ideas on how to choose and design indexes:
        
        1)  Indexes cost space on disk, and they need to be updated whenever data changes.If your data changes frequently, or lots of data changes 
            when you do make a change, however, SELECT commands are more common than other queries.

        2)  Only add an index that’ll be used frequently. indexes will slow the process down.

        3)  If all columns in an index are used in all queries, list the column with the highest number of duplicates at the left of the KEY clause. This
            minimizes index size.

        4)  The smaller the index, the faster it'll be. If you index large columns, you'll get a larger index. This is a good reason to ensure your columns
            are as small as possible when you design your tables.

        5)  For long columns, you can use only a prefix of the values from a column to create the index. You can do this by adding a value in parentheses after
            the column definition, such as KEY names (firstname(3). secondname(2), surname(10)). This means that only the first three characters of firstname are
            indexed, then the first 2 of secondname, then the first 10 from surname.

-   The AUTO_INCREMENT Feature

    The AUTO_INCREMENT

    keyword tells MySQL that when a value isn’t provided for this column, the value allo-
    cated should be one more than the maximum currently stored in the table. The
    AUTO_INCREMENT sequence begins at 1 for an empty table.
    
    mysql> DROP TABLE artist;
    Query OK, 0 rows affected (0.01 sec)
    mysql>CREATE TABLE artist (
    -> artist_id SMALLINT(5) NOT NULL AUTO_INCREMENT,
    -> artist_name CHAR(128) DEFAULT NULL,
    -> PRIMARY KEY (artist_id)
    -> );

    The AUTO_INCREMENT feature has the following requirements:

    -   The column it is used on must be indexed;
    -   The column that is used on cannot have DEFAULT value;
    -   There can be only one AUTO_INCREMENT column per table.

    While the AUTO_INCREMENT feature is useful, it isn't portable to other database environments, and it hides the logical steps to creating new identifiers,
    It can also lead to ambiguity; for example, dropping or truncating a table will reset the counter, but de-leting selected rows (with a WHERE clause) 
    doesn’t reset the counter.




   Built-in functions;
   
   MAX();
   
