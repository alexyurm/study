Chapter 1 An introduction to Device Drivers

1. The role of a device driver is providing mechanism, not policy.

   Mechanism: what capabilities are to be provided.
   policy: how those capabilities can be used.

2. Policy-free drivers have a number of typical characteristics:

   2.1 support for both synchronous and asynchronous operation;
   2.2 the ability to be opened multiple times;
   2.3 the ability to exploit the full capabilities of the hardware;
   2.4 the lack of software layers to "simplify things" or provide policy-related operations;
   2.5 work better for their end users and easier to write and maintain as well.

3. The kernel role can be split into the following parts:

   3.1 Process management;
   3.2 Memory management;
   3.3 Filesystems;
   3.4 Device control;
   3.5 Networking.

4. Module: Each piece of code that can be added to the kernel at runtime. Linux driver is one of those types. Each module is made up of object
   code (not linked into a complete executable) that can be dynamically linked to the running kernel by the insmod program and cann be unlinked
   by the rmmod program.

5. Device Types

   Three fundamental device types. 1) char modules; 2) block modules; 3) network modules. The division of modules into different types, or classes, is not rigid one; the programmer can choose to build huge modules implementing different
   drivers in a single chunk of code. Good programmers, nonetheless, usually create a different module for each new functionality they implement, because decomposition is a key element of scalability and extendability.

   1) char modules

   It is one that can be accessed as a stream of bytes. It at least supports "open", "close", "read", and "write" system calls. E.g. /dev/console and /dev/ttyS0. In most cases, you cannot move back and forth in char devices since they 
   are just data channels, which you can only access sequentially.

   2) block modules

   A device that can host a filesystem. Linux allows the application to read and write a block device like a char device. It permits the transfer of any number of bytes at a time, whereas Unix can only handle I/O operations that transfer
   one or more blocks, which are usually 512 bytes (or a large power of 2). Block device has completely different interface to the kernel than char devices.

   3) network modules

   A device that is able to exchange data with other hosts. This device is usually hardware device but can be software device as well. E.g. loopback. Network interface has a special name, e.g. eth0. It doesn't have a corresponding entry
   in the filesystem.

   4) Hybrid...

   In addition to device drivers, other functionalities, both hardware and software, are modularized in the kernel. E.g. filesystems. A filesystem type determines how information is organized on a block device in order to present a
   tree of directories and files.

6. Security

   Any security check in the system is enforced by kernel code. If the kernel has security holes, then the system as a whole has holes.

   A system call init_module checks if the invoking process is authorized to load a module into the kernel.

   Normally speaking, security checking is a policy issue that is often best handled at higher levels within the kernel. Unfortunatelly, device access could adversely affect the system as a whole and should provide adequate controls. 
   E.g. device operations that affect global resources (such as setting an interrupt line), which could damage the hardware or that could affect other users. And this check must be made in the driver itself.

   Also, C programming language makes it easy to make several types of errors. E.g., buffer overrun: forget to check how much data is written to a buffer;

   Other security ideas are worth keeping in mind are:

   1) Any input from user processes;
   2) Uninitialized memory;
   3) information leakage (password, data);
   4) If your device interprets data sent to it, be sure the user cannot send anything that could compromise the system;
   5) Operations that format a disk or reload the firmware on an adapter board;
   6) Source code from third parties. Be careful of pre-compiled kernel compiled by an untrusted friend.

   Note that Linux kernel can be compiled to have no module support whatsoever, thus closing any module-related security holes. Thus, all needed drivers must be built directly into the kernel itself. It is also possible, with 2.2 and
   later kernels, to disable the loading of kernel modules after system boot via the capability mechanism.

7. Version Numbering

   1) First of all, note that every software package used in a Linux system has its own release number, and there are often interdependencies across them: you need a particular version of one package to run a particular version of
   another package. Check the file: Documentation/Changes for that matter.
   
   2) 2.6.x  -> 6: even number to indicate this version is stable one
      2.7.x  -> 7: odd number to indicate this version is dev snapshot 

   3) Keep in mind that APIs change among different versions of kernels. Programmers wanting to keep up with kernel programming changes are encouraged to join the mailing lists. There is also a web page maintained at:

   http://lwn.net/Articles/2.6-kernel-api/

8. License Terms

   Linux is licensed under Version 2 of the GNU General Public License (GPL).

   If you or your employer wish to distribute kernel modules under a nonfree license, you really need to discuss the situation with your legal counsel.

   If you want your code to go into the mainline kernel, or if your code requires patches to the kernel, you must use a GPL-compatible license as soon as you release the code.

   All the programs in this book are available at: ftp://ftp.ora.com/pub/examples/linux/drivers/

9. Mailing list

   The central gathering point for Linux kernel developers is the linux-kernel mailing list. To join, follow the instructions: http://www.tux.org/lkml



