Chapter 2 Building and Running Modules

1. Setting up test system

   Regardless of the origin your kernel, building modules for 2.6.x requires that you have a configured and built kernel tree on your system. This requirement is a change from previous versions of the kernel, where a current set
   of header files are sufficient. 2.6 modules are linked against object files found in the kernel source tree;

2. Hello world example

   #include <linux/init.h>
   #include <linux/module.h>
   MODULE_LICENSE("Dual BSD/GPL");
   static int hello_init(void)
   {
      printk(KERN_ALERT "Hello, world\n");
      return 0;
   }

   static void hello_exit(void)
   {
      printk(KERN_ALERT "Goodbye, cruel world\n");
   }
   module_init(hello_init);
   module_exit(hello_exit);

   module_init and module_exit use special kernel macros to indicate two of these two functions.

   macro MODULE_LICENSE tells this module bears a free license.

   KERN_ALERT is the priority of the message.
  
   the exit function of a module must carefully undo everything the init function built up, or the pieces remain around until the system is rebooted.

   Because no library is linked to modules, source files should never include the usual header files, <stdarg.h> and very special situations being the only exceptions. Anything releated to the kernel is declared in the headers
   found in the kernel source tree. Most of the relevant headers live in include/linux and include/asm.
   
3. Kernel space and User space

   Unix transfers execution from user space to kernel space whenever an application issues a system call or suspended by a hardware interrupt.

   The role of a driver is to perform the tasks: 1) some functions of the module are executed as part of system calls; 2) some are in charge of interrupt handling.

4. Even the simplest kernel modules must be written with the idea that many things can be happening at once.

   Sources of concurrency in kernel programming can be:
   
   Linux kernel code, including driver code, must be reentrant -> it must be capable of running in more than one context at the same time.

   1) More than one processes can be trying to use your driver.

   2) Interrupt handlers run asynchronously and can be invoked at the same time that your driver is trying to do something else.

   3) Several software abstractions such as kernel timers run asynchronously as well.

   4) Linux can run on symmetric multiprocessor (SMP) systems, with the result that your driver could be executing concurrently on more than one CPU.

   5) Kernel 2.6 code has been made preemptible.
   
5. The current process

   The current process can be accessed through the global item current, defined in <asm/current.h>. which yields a pointer task_struct, defined by <linux/sched.h>. The current pointer refers to the process that is currently running. 

   Actually, current is not truly a global variable. The need to support SMP systems forced the kernel developers to develop a mechanism that finds the current process on the relevant CPU. 

   The following statement prints the process ID and the command name of the current process by accessing certain fields in struct task_struct. A device driver can just include <linux/sched.h> and refer to the current process.

   printk(KERN_INFO "The process is \"%s\" (pid %i)\n", current->comm, current->pid);

   The command name stored in current->comm is the base name of the program file (trimmed to 15 characters if need be) that is being executed by the current process.

   
6. A few Other Details

   Kernel programming differs from user-space programming in many ways:

   1) Applications are laid out in virtual memory with a very large stack area, which holds the function call history and all automatic variables created by currently active functions. The kernel instead, has a very small stack. 
   It can be as small as a single 4096-byte page. Your functions must share that stack with the entire kernel-space call chain. Thus, it is never a good idea to declare large
   automatic variables; if you need large structure, you should use heap memory.
   
   2) Functions with names starting with a double underscore (__) are generally a low-level component of the interface and should be used with caution (Be sure what you are doing).

   3) Kernel code cannot do floating point arithmetic. Enabling floating point processor's state on each entry to, and exit from, kernel space--at least on some architecture. Given that there really is not need for floating point
   in kernel code, the extra overhead is not worthwhile.

7. Compiling and Loading

   Compiling Modules: 

   The build process for modules differs significantly from that used for user-space applications. The files found in the Documentation/kbuild directory in the kernel source are required reading for everyone wanting to understand
   all that is really going on beneath the surface.

   Before building kernel, ensure that you have sufficiently current versions of the compiler, module utilities, and other necessary tools. The file Documentation/Changes always lists the required tool versions. Either of the 
   version of tools is too new or too old can be problematic.

   Get a kernel tree and configure/build it. Without the tree, you cannot build loadable modules.

   obj-m :=hello.o

   This states there is one module to be built from the object file file hello.o, and the output of obj-m is hello.ko.

   Instead, if you have a module called module.ko that is generated from two source files, the correct incantation would be:

   obj-m := module.o
   module-objs := file1.o file2.o

   For a makefile like those shown above to work. it must be invoked within the context of the larger kernel build system, if your kernel source tree is located in, say, ~/kernel0.6 directory, the make command would be:

   make -C ~/kernel-2.6 M=`pwd` modules

   -C is used for changing its directory to the kernel source tree. There it finds the kernel's top-level makefile. The M= option causes that makefile to move back into your module source directory before trying to build 
   the modules target. This target, in turn, refers to the list of modules found in obj-m variable.

   (!!)Makefile is more appropriate to do the compiling job:
   
   # If KERNELRELEASE is defined, we've been invoked from the
   # kernel build system and can use its language.
   ifneq ($(KERNELRELEASE),)
      obj-m := hello.o
   # Otherwise we were called directly from the command
   # line; invoke the kernel build system.
   else
      KERNELDIR ?= /lib/modules/$(shell uname -r)/build
      PWD := $(shell pwd)
   default:
      $(MAKE) -C $(KERNELDIR) M=$(PWD) modules
   endif
   
   This makefile is read twice on a typical build. When the makefile is involked from the command line, it notices that the KERNELRELEASE variable has not been set. If not,
   supply KERNELDIR= option on the command line. set the KERNELDIR environment variable, or rewrite the line that sets KERNELDIR in the makefile. 

   Once the kernel source tree has been found, the makefile invokes the default: target, which runs a second make command (parameterized in the makefile as $(MAKE)) to invoke
   the kernel build system as described previously. On the second reading, the makefile sets obj-m, and the kernel makefiles take care of actual building the module (??How).

   2) Loading and Unloading Modules

   insmod does the job of loading the kernel module. It insmod program loads the module code and data into the kernel. Insmod accepts a number of command-line options and can
   assign values to parameters in your module before linking it to the current kernel. This is so called load-time configuration gives the user more flexibility than compile
   time configuration, which is still used sometimes. Load-time configuration is explained in the section "Module parameters".

   insmod relies on a system call defined in kernel/module.c. The function sys_init_module allocates kernel memory to hold a 
   module (this memory is allocated with vmalloc; see the section vmalloc and Friends in Chapter 8); it then copies the module text into that memory
   region, resolves kernel references in the module via the kernel symbol table, and calls the module¡¯s initialization function to get everything going.

   modprobe which looks like insmod, loads a module into the kernel. It differs in that it will look at the module to be loaded to see whether it references any symbols that are not currently defined in the kernel.
   If any such references are found, modprobe looks for other modules in the current module search path that define the relevant symbols. When modprobe finds those modules (which are needed by the module being loaded),
   It loads them into the kernel as well. If you use insmod in this situation instead, the command fails when an "unresolved symbols" message left in the system logfile.

   rmmod is for kernel removal, which may fails if the kernel believes that the module is still in use (It is still possible to configure the kernel to allow "forced " removal of modules).

   lsmod produces the a list of the modules currently loaded in the kernel. lsmod works by reading the /proc/modules virtual file. Information on currently loaded modules can also be found in the sysfs virtual filesystem
   under /sys/module.

8. Version Dependency

   My module's code has to be recompiled for each version of the kernel that it is linked to. This is because modules are strongly tied to the data structures and function prototypes. The kernel does not just assume that
   a given module has been built against the proper kernel version. One of the steps in the build process is to link your module against a file (called vermagic.o) from the current tree. This object contains a fair 
   amount of information about the kernel the module was built for:

   1) the target kernel version;
   2) compiler version;
   3) the settings of a number of important configuration variables.

   If things don't match, the module is not loaded; instead, you see something like:

   # insmod hello.ko
   Error inserting './hello.ko': -1 Invalid module format

   A look in the system log file (/var/log/messages or whatever your system is configured to use) will reveal the specific problem that caused the module to fail to load.

   If you want to work with multiple versions of the kernel, I would need to make use of macro and #ifdef constructs. to make my code build properly. In such cases, you want to make use of the definitions found in linux/version.h
   The header file, automatically included by linux/module.h, defines the following macros:

   1) LINUX_VERSION_CODE

   This macro expands to the binary representation of the kernel version, one byte for each part of the version release number. E.g. 132632 = 0x20618 (hex) = 2.6.18

   2) KERNEL_VERSION(major,minor,release) or KERNEL_VERSION(a,b,c)

   (((a) << 16) + ((b) << 8) + (c))

   This macro is very useful when you need to compare the current version and a known checkpoint.

   Version dependency should, however, not clutter driver code with hairy #ifdef conditionals; the best way to deal with incompatibilities is by confining them to a specific header
   file. As a general rule, code which is explicitly version (or platform) dependent should be hidden behind a low-level macro or function. High-level code can then just call those 
   functions without concern for the low-level details. Code written in this way tends to be easier to read and more robust.


9. Platform Dependency

   Unlike application developers, who must link their code with precompiled libraries and stick to conventions on parameter passing, kernel developers can dedicate some processor registers to 
   specific roles, and they have done so. Moreover, kernel code can be optimized for a specific processor in a CPU family to get the best from the target platform: unlike applications that are often distributed 
   in binary format, a custom compilation of the kernel can be optimized for a specific computer set.

   The vermagic.o object (??where this file can be found) comes in play when a module is loaded to the kernel. This is to ensure the module must be built with the same understanding of the target processor as that kernel was. 
   If the kernel was compiled with different options, it is not loaded.

10.Kernel Symbol Table

   The table contains the addresses of global kernel items - functions and variables (symbols). When a module is loaded into the kernel, any symbols exported by the module become part of the kernel symbol table.

   New modules can use symbols exported by your module, and you can stack new modules on top of other modules.E.g. ecan input USB device module stacks on the usbcore and input modules.

   Module stacking is useful in complex projects. It might offer a plug for hardware-specific implementations. E.g. The video-for-linux set of drivers is split into a generic that exports symbols used by lower-level device drivers
   for specific hardware. Spliting modules into multiple layers can help reduce development time by simplifying each layer.

   The Linux kernel header files provide a convinent way to manage the visibility of your symbols, thus reducing namespace pollution(filling the namespace with names that may conflict with those elsewhere in the kernel).

   EXPORT_SYMBOL(name);
   EXPORT_SYMBOL_GPL(name); ---> It makes the symbol available to GPL-licensed modules only.

-  Symbols must be exported in the global part of the module's file, outside of any function, because the macros expand to the declaration of a special-purpose variable 
   that is expected to be accessible globally. This variable is stored in a special part of the module executible (an "ELF section") that is used by the kernel at load 
   time to find the variables exported by the modules. You can access the file <linux/module.h> for more detail.

11.preliminaries

   There are a few header files that are specific to modules, and must be appear in every loadable module:

   <linux/module.h> -> contains many definitions of symbols and functions
   <linux/init.h> -> needed to specify your initilization and cleanup functions.
   moduleparam.h  -> most of modules use it to enable the passing of parameters to the module at load time
   
   Not necessary but should specify which license applies to its code:
   
   MODULE_LICENSE("GPL");

   Some other definitions are also useful:

   MODULE_AUTHOR, MODULE_DESCRIPTION, MODULE_VERSION(please see the comments in <linux/module.h>), MODULE_ALIAS, and MODULE_DEVICE_TABLE(to tell user space about which devices 
   the module support)

   A relatively recent convention in kernel code, however, is to put these declarations at the end of the file.

12.Initialization and Shutdown
   
   The actual definition of the initialization function always looks like:

   static int __init initialization_function(void)
   {
      /*    Initialization code here */
   }
   module_init(initialization_function);
   
   init function must be decleared as static since no one outside should use it(there is no hard rule thourgh).

   (!!)"__init" token is a hint to the kernel that the given function is used only at initialization time. The module loader drops the initialization function after the module
   is loaded, making its memory available for other uses. A similar tag (__initdata) for data used only during initizlization. Don't use __init for any functions you will be
   using after initizlization is complete. These translate to __init and __initdata only if the kernel has not been configuraed for hotplugable devices.

   The use of module_init is mandatory. This macro adds a special section to the module's object code starting where the module init function to be found.

   (!!)Modules can register many different types of facilities: devices (diff kind of), cryptographic transofrms(??) and filesystems. The kernel registration functions is 
   used to accomplishi this registration. The arguments passed to the kernel registration functions are usually pointers to data structure describing the new facility and
   the name of the facility being registered. The data structure usually contains pointers to module functions, which is how functions in the module body get called.

13.The clean-up function

   static void __exit cleanup_function(void)
   {
      /* Cleanup code here */
   }
   module_exit(cleanup_function);

   (!!)The __exit modifier marks the code as being for module unload only (by causing the compiler to place it in a special ELF section). If your module is built directly
   into the kernel, of if your kernel is configured to disallow the unloading of modules, functions marked __exit are simply discarded. Once again, the module_exit declaraion
   is necessary to enable to kernel to find your cleanup function.

14.Error Handling during Initialization

   If it turns out that your module simply cannot load after a particular type of failure, you must undo any registration activities performed before the failure. Linux doesn't
   keep a per-module registry of facilities that have been registered, so the module must back out of everything itself if initialization fails at some point.

   Use goto statement (usually we hate it). In the kernel, goto is often used as shown here to deal with errors.

   int __init my_init_function(void)
   {
      int err;
      /* registration takes a pointer and a name */
      err = register_this(ptr1, "skull");
      if (err) goto fail_this;
      err = register_that(ptr2, "skull");
      if (err) goto fail_that;
      err = register_those(ptr3, "skull");
      if (err) goto fail_those;
      
      return 0; /* success */
      fail_those: unregister_that(ptr2, "skull");
      fail_that: unregister_this(ptr1, "skull");
      fail_this: return err; /* propagate the error */
   }

   Another option is keeping track of what has been successfully registered and calling your module's cleanup function in case of any error. This way requires more code and
   more CPU time though.

   All errors codes (return value) are negative numbers belonging to the set defined in <linux/errno.h>.

   If your initialization and cleanup are more complex than dealing with a few items, goto item is more difficult to manage. Here is another method:

   void my_cleanup(void)
   {
      if (item1)
      release_thing(item1);
      if (item2)
      release_thing2(item2);
      if (stuff_ok)
      unregister_stuff( );
      return;
   }

   int __init my_init(void)
   {
      int err = -ENOMEM;
      item1 = allocate_thing(arguments);
      item2 = allocate_thing2(arguments2);
      if (!item2 || !item2)
      goto fail;
      err = register_stuff(item1, item2);
      if (!err)
         stuff_ok = 1;
      else
         goto fail;
      
      return 0; /* success */
      
      fail:
      my_cleanup( );
      return err;
   }

15.Module-Loading Races

   It is entirely possible that the kernel will make calls into your module while your initialization function is still running. Do not register any facility until all
   of your internal initialization to support that facility has been completed.

   When Initialization function is decided to fail but some part of the kernel is already making use of a facility your module has registered. In that situation, you should
   seriously consider not failing the initialization at all. If initialization must fail, it must carefully step around any possible operations going on elsewhere in the
   kernel until those operations complete.

16.Module parameters

   Different drivers parse different parameters. These can vary from the device number to use to numerous aspects of how the driver should operate. E.g. IDE drivers allow
   user control of DMA operations. These parameter values can be assigned at load time by insmod and modprobe; the later can also read parameter assignment from its
   configuration file /etc/modprobe.conf.

   Before insmod can change module parameters, the module must make them available. Parameters are declared with the module_param macros, which is defined in moduleparam.h. 
   module_param takes three parameter: 1) the name of the varialbe; 2) its type; 3) a permission mask to be used for an accompanying sysfs entry. The macros should be placed 
   outside of any function and is typically found near the head of the source file.

   Numerous types are supported for module parameters:

   bool
   invbool(??)  
   charp
   int
   long
   short
   uint
   ulong
   ushort
   
   Array parameters, where the values are supplied as a comma-sperated list, are also supported by the module loader:

   module_param_array(name,type,num,perm);

   name: name of my array
   type: type of the array elements
   num:  an integer variable (it is set to the number of values supplied, if the array parameter is set at load time)
   perm: the usual permission value.

   There are hooks in the module code that allow you to define them if you really need a type that does not appear the list above. See moduleparam.h for details how to do that.

   (??)The final module_param field is a permission value; you should use the definitions found in <linux/stat.h>. The value controls who can access the representation of the module parameter in sysfs. If perm is set to
   0, there is no sysfs entry at all; otherwise, it appears under /sys/module with the given set of permission. Use S_IRUGO for a parameter that can be read by the world but cannot be changed; S_IRUGO|S_IWUSR allows 
   root to change the parameter.

17.Doing it in User Space

   Sometime it's good to write user-space drivers:

   •  The full C library can be linked in. The driver can perform many exotic tasks without resorting to external programs (the utility programs implementing usage policies that are usually distributed 
      along with the driver itself).
   •  The programmer can run a conventional debugger on the driver code without having to go through contortions to debug a running kernel.
   •  If a user-space driver hangs, you can simply kill it. Problems with the driver are unlikely to hang the entire system, unless the hardware being controlled is really misbehaving.
   •  User memory is swappable, unlike kernel memory. An infrequently used device with a huge driver won’t occupy RAM that other programs could be using, except when it is actually in use.
   •  A well-designed driver program can still, like kernel-space drivers, allow concur-rent access to a device.
   •  If you must write a closed-source driver, the user-space option makes it easier for you to avoid ambiguous licensing situations and problems with changing kernel interfaces.

   Some drawbacks are:

   •  Interrupts are not available in user space. There are workarounds for this limita- tion on some platforms, such as the vm86 system call on the IA32 architecture.
   •  Direct access to memory is possible only by mmapping /dev/mem, and only a privileged user can do that.
   •  Access to I/O ports is available only after calling ioperm or iopl. Moreover, not all platforms support these system calls, and access to /dev/port can be too slow to be effective. 
      Both the system calls and the device file are reserved to a privileged user.
   •  Response time is slower, because a context switch is required to transfer information or actions between the client and the hardware.
   •  Worse yet, if the driver has been swapped to disk, response time is unacceptably long. Using the mlock system call might help, but usually you’ll need to lock many memory pages, because 
      a user-space program depends on a lot of library code. mlock, too, is limited to privileged users.
   •  The most important devices can’t be handled in user space, including, but not limited to, network interfaces and block devices.



