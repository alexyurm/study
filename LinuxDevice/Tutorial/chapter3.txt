Chapter3 Char driver

-  scull(Simple Character Utility for Loading Localities) is a char driver that acts on a memory area as though it were a device. It isn't hardware dependent and just acts
   on memory, allocated from the kernel. This device doesn't do anything "useful" other than demonstrate the interface between the kernel and char drivers and allow the user
   to run some tests.

-  The scull source implements the following devices. Each kind of device implemented by the module is referred to as a type:

   1) scull0 to scull3

   Four devices that consist of a memory area that is both global and persistent.

   Global: if the device is opened multiple times, the data contained within the device is shared by all the file descriptors that opened it.
   Persistent: if the device is closed and reopened, data isn't lost.

   2) scullpipe0 to scullpipe3

   Four FIFO devices, which act like pipes. One process reads what another process writes. If multiple processes read the same device, they contend for data.
   The internals of scullpipe will show how blocking and nonblocking read and write can be implemented without having to resort to interrupts (Although real
   drivers synchronize with their devices using hardware interrupts).

   3) scullsingle, scullpriv, sculluid, scullwuid

   These devies are similar to scull0 but with some limitations on when an open is permitted.

   scullsingle: allow one process at a time to use the driver.

   scullpriv: is private to each virtual console (or X terminal session) because processes on each console/X terminal get different memory areas(really??).

   sculluid: can be opened multiple times, but only by one user at a time. returns error "Device Busy" if another is locking the device.

   scullwuid: the same as sculluid except it implements blocking open (??what is blocking open)

-  Char driver is identified by 'c' in /dev. E.g. ls -l

   crw------- 1 root root 4, 1 Oct 28 03:04 tty1
                          |  |
                          |  |                           
                          |  |---> minor number: used by the kernel to determine exactly which device is being referred to.
                          |
                          |---> Major number: identifies the driver associated with the device. Here the device is managed by driver 4. Modern Linux kernels allow
                                              multiple drivers to share major number, but most of devices that you will see are still organized on the one-major-one
                                              principle (??What is one-major-one) 

-  The Internal Representation of Device Numbers

   dev_t type (32 bit with 12 bits set aside for Major and 20 more minor defined in <linux/types.h>) is used to hold device numbers.
   
   To make sure the device number, use a set of macros in <linux/kdev_t.h>
   
   MAJOR(dev_t dev);
   MINOR(dev_t dev);

   If you have the major and minor number, use the following to turn them into a device number:

   MKDEV(int major, int minor);

-  Allocating and Freeing Device Numbers

   The first thing I need to do when writing a char driver is to obtain one or more device numbers to work with:

   1) register_chrdev_region is declared in <linux/fs.h>:

   int register_chrdev_region(dev_t first, unsigned int count, char *name);

   first: the beginning device number of the range you would like to allocate.
   count: the total number of contiguous device numbers you are requesting. if count is large, the range you request could spill over to the next major number
   name: the is the name of the device that you should be associated with this number range; it will appear in /proc/devices and sysfs.

   2) There is another function which can do dynamiclly-allocated device numbers:

   int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);

   dev: an output-only parameter that will, on successfully completion, hold the first number in your allocated range.
   firstminor: the requested first minor number to use; it is usually 0.
   count and name are the same as the previous command.

   3) Regardless how you allocate your device numbers, you should free them when they are no longer in use (the usual place that in the module's cleanup function):

   void unregister_chrdev_region(dev_t first, unsigned int count);

-  Dynamic Allocation of Major Numbers

   (!!)Some major device numbers are statically assigned to the most common devices. A list of those devices can be found in Documentation/devices.txt within the kernel
   source tree. It is strongly recommanded to use dynamic allocation to obtain your major number (alloc_chrdev_region) in order to avoid number conflict. Once the number 
   has been assigned, you can read it from /proc/devices. Even better device information can usually be obtained from sysfs.

   We can use a script called scull_load to load a module:

   #!/bin/sh
   module="scull"
   device="scull"
   mode="664"
   # invoke insmod with all arguments we got
   # and use a pathname, as newer modutils don't look in . by default
   #/sbin/insmod ./$module.ko $* || exit 1
   # remove stale nodes
   rm -f /dev/${device}[0-3]
   major=$(awk "\\$2= =\"$module\" {print \\$1}" /proc/devices)
   #??What is major
   mknod /dev/${device}0 c $major 0
   mknod /dev/${device}1 c $major 1
   mknod /dev/${device}2 c $major 2
   mknod /dev/${device}3 c $major 3
   # give appropriate group/permissions, and change the group.
   # Not all distributions have staff, some have "wheel" instead.
   group="staff"
   grep -q '^staff:' /etc/group || group="wheel"
   chgrp $group /dev/${device}[0-3]
   chmod $mode /dev/${device}[0-3]

   A scull_unload is required to clean up /dev directory. As an alternative to using a pair of scripts for loading and unloading, you could write an init script which accepts the conventional arguments such as
   start, stop, and restart.

   The best way to assign major numbers is by defaulting to dynamic allocation while leaving yourself the option of specifying the major number at load time or even at compile time

   if (scull_major) {
      dev = MKDEV(scull_major, scull_minor);
      result = register_chrdev_region(dev, scull_nr_devs, "scull");
   } else {
      result = alloc_chrdev_region(&dev, scull_minor, scull_nr_devs, "scull");
      scull_major = MAJOR(dev);
   }
   if (result < 0) {
      printk(KERN_WARNING "scull: can't get major %d\n", scull_major);
      return result;
   }
   
   scull_major is a global variable which is initialized to SCULL_MAJOR defined in scull.h. The default value of SCULL_MAJOR is 0, which means "use dynamic assignment".

-  Some Important Data Structure.

   1) file_operations
   2) file
   3) inode

   The file_operations structure is how a char driver sets up this connection to any device numbers. The structure is defined in <linux/fs.h> which is a collection of function pointers. Each open file is associated with its own
   set of functions (by including a field called f_op that points to a file_operation structure). 

   Conventionally, a file_operations strucrure or a pointer to one is called fops (or some variation thereof). Each field in the structure must point to the function in the driver that implements a specific operation, or be left
   NULL for unsupported operations. The following list introduces all the operations that an application can invoke on a device. As you read through, you will note that a number of parameters include the string __user. This anno-
   tation is a form of documentation, noting that a pointer is a userspace address that cannot be directly dereferenced(??). 

   1) struct module *owner

   It is a pointer to the module that "owns" the structure. This field is used to prevent the module from being unloaded while its operations are in use. Almost all the time, it is simply initialized to THIS_MODULE, a macro defined
   in <linux/module.h>

   2) loff_t (*llseek) (struct file *, loff_t, int); <--??Why the parameters look like these?

   The llseek method is used to change the current read/write position in a file, and the new position is returned as a (positive) return value. 

   3) ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);

   Used to retrieve data from device. A null pointer in this position causes the read system call to fail with -EINVAL("Invalid argument").

   4) ssize_t (*aio_read)(struct kiocb *, char __user *, size_t, loff_t);

   Initiates an asynchronous read: a read operation that might not be complete before the function returns. 

   5) ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);

   Send data to device. 

   6) ssize_t (*aio_write)(struct kiocb *, const char __user *, size_t, loff_t *);
   
   Initiates an asychronous write operation on the device.

   7) int (*readdir) (struct file *, void *, filldir_t);
   
   This field should be NULL for device files; it is used for reading directories and is useful only for filesystems.

   8) unsigned int (*poll) (struct file *, struct poll_table_struct *);

   The poll method is the back end of three system calls: poll, epoll, and select, all of which are used to query whether a read or write to one or more file descriptors would block. The poll method should return a bit mask
   indicating whether non-blocking reads or writes are possible, and possibly, provide the kernel with information that can be used to put the calling process to sleep until I/O become possible. If a driver leaves its poll
   method NULL, the device is assumed to be both readable and writable without blocking.

   9) int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);

   It offers a way to issue device-specific commands. A few ioctl commands are recognized by the kernel without referring to the fops table (??what is fops table). If the device doesn't provide an ioctl method, the system
   call returns an error for any request that isn't predefined ("-ENOTTY, no such ioctl for device").

   10)int (*mmap) (struct file *, struct vm_area_struct *);

   It is used to request a mapping of device memory to a process's address space(??). If the method is NULL, the mmap system call returns -ENODEV

   11)int (*open) (struct inode *, struct file *);

   If this entry is NULL, opening the device always succeeds, but your driver isn't notified. 

   12) int (*flush) (struct file *);

   The flush operation is involked when a process closes its copy of a file descriptor for a device. E.g. SCSI tape driver uses it to ensure that all data written makes it to the tape before the device is closed. 

   13)  int (*release) (struct inode *, struct file *)

   This operation is involked when the file structure is being released. Like open, release can be NULL.

   14)  int (*fsync) (struct file *, struct dentry *, int);

   This method is the back end of the fsync system call, which a user calls to flushany pending data. If this pointer is NULL, the system call returns -EINVAL.

   15)  int (*aio_fsync)(struct kiocb *, int);

   This is the asynchronous version of the fsync method.

   16)  int (*fasync) (int, struct file *, int);

   This operation is used to notify the device of a change in its FASYNC flag. Asynchronous notification is an advanced topic.

   17)  int (*lock) (struct file *, int, struct file_lock *); 

   The lock method is used to implement file locking; locking is an indispensable feature for regular files but is almost never implemented by device drivers.

   18)   ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
         ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);

   These methods implement scatter/gather read and write operations. Applications occasionally need to do a single read/write operation involing multiple memory areas. If these function pointers are null, the read/write
   methods are called instead. 

   19)  ssize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);

   This method implements the read side of the sendfile system call, which moves the data from one file descriptor to 

   20)  ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);

   sendpage is the other half of sendfile; it is called by the kernel to send data; one page at a time, to the corresponding file. Device drivers do not usually implement sendpage.
  
   21) unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);

   The purpose of this method is to find a suitable location in the process's address space to map in a memory segment on the underlying device. 

   22) int (*check_flags)(int)

   This method allows a module to check the flags passed to fcntl(F_SETFL...)call.

   23) int (*dir_notify)(struct file *, unsigned long);

   This method is involked when an application uses fcntl to requrest directory change notifications. It is useful only to filesystems; drivers need not implement dir_notify.

   The scull device driver implements only the most important device methods. Its
   file_operations structure is initialized as follows(so called C tagged structure initialization syntax):

      struct file_operations scull_fops = {
      .owner   =  THIS_MODULE,
      .llseek  =  scull_llseek,
      .read    =  scull_read,
      .write   =  scull_write,
      .ioctl   =  scull_ioctl,
      .open    =  scull_open,
      .release =  scull_release,
   };

-  The file Structure

   struct file, defined in (linux/fs.h) is the second most important data structure used in device drivers. Please don't confuse this with the FILE pointers of user-space programs which never appears in kernel code.
   On the other hand, a kernal structure never appears in user programs.

   The file structure represents an open file. It is created by the kernel on open and is passed to any function that operates on the file, until the last close. After all instances of the file are closed, the kernel
   releases the data structure(??).

   1) mode_t f_mode;
   
   The file mode identifies the file as either readable or writable or both. By means of the bits FMODE_READ and FMODE_WRITE. 

   2) loff_t f_pos;

   The current reading or writing position. loff_t is a 64-bit value on all platforms. 

   3) unsigned int f_flags; 

   These are file flags, such as O_RDONLY, O_NONBLOCK, and O_SYNC. A driver should check the O_NONBLOCK flag to see if nonblocking operation has been requested(O_RDONLY and O_SYNC flags are selcom used ). 
   In particular, read/write permission should be checked using f_mode rather than f_flags. All the flags are defined in the header <linux/fcntl.h> (!!)

   4) struct file_operations *f_op;

   The operations associated with the file. The value in filp->f_op is never saved by the kernel by later references.(??) this means that you can change the file operations associated with your file, and
   the new methods will be effective after you return to the caller. E.g. the code for open associated with major number 1 (/dev/null, /dev/zero, and so on) substitutes the operations in flip->f_op depending
   on the minor number being opened(??).

   5) void *private_data;

   The open system call sets this pointer to NULL before calling open method for this driver. You are free to make its own use of the field or ignore it; if you use the field to point to allocated data, but then
   you must remember to free that memory in the release method before the file structure is destroyed by the kernel. private_data is a useful resource for preserving state information across system calls and is
   used by most of our sample modules.

   6) struct dentry *f_dentry;

   The directory entry (dentry) structure associated with the file. Device driver writers normally need not concern themselves with dentry structures, other than to access the inode structure as flip->f_dentry->d_inode.

-  The inode Structure

   The inode structure is used by the kernel internally to represent files. Whereas file structure represents as an open file descriptor. That means numerous file structures representing multiple open descriptors on a
   single file, but they all point to a single inode structure.

   inode contains a great deal of information about the file. As a general rule, only two fields of this structure are of interest for writing driver code;

   1) dev_t i_rdev;

   For inodes that represent device files, this field contains the actual device number 

   2) struct cdev *i_cdev;

   struct cdev is the kernel's internal structure that represents char drivers; this field contains a pointer to that structure when inode refers to a char device file.

-  Char Device Registration

   The kernel uses structures of type struct cdev to represent char device internally. Before the kernel invokes your device's operations, you must allocate and register one or more of these structures. To do so, your code
   should include <linux/cdev.h>

   There are two ways of allocating and initializing one of these structures. If you with to obtain a standalone cdev structure at runtime, 

   struct cdev *my_dev = cdev_alloc();
   my_cdev->ops = &my_fops;

   Chances are. however, that you will want to embed the cdev structure within a device-specific structure of your own (??). This is how scull does. In this case, you should initialize the structure that you have already
   allocated with:

   void cdev_init(struct cdev *cdev, struct file_operations *fops);

   Either way there is one other struct cdev field that you need to initialize. Like the file_operations structure, struct cdev has an owner field that should be set to THIS_MODULE.

   Once the cdev is setup, the final step is to tell the kernel about it with a call to:

   int cdev_add(struct cdev *dev, dev_t num, unsigned int count);

   dev: cdev structure;
   num: the first device number to which this device responds;
   count: the number of device numbers that should be associated with the device(usually it is one).

   As soon as cdev_add returns, your device is "live" and its operations can be called by the kernel. You should not call cdev_add until your driver is completely ready to handle operations on the device.

   To remove a char device from the system, call: 

   void cdev_del(struct cdev *dev);

-  Device Registration in scull

   Internally, scull represents each device with a structure of type struct scull_dev. This structure is defined as:;

   struct scull_dev {
   struct scull_qset *data; /* Pointer to first quantum set */
   int quantum;
   /* the current quantum size */
   int qset;
   /* the current array size */
   unsigned long size;
   /* amount of data stored here */
   unsigned int access_key; /* used by sculluid and scullpriv */
   struct semaphore sem; /* mutual exclusion semaphor */
   struct cdev cdev; /* Char device structure */
   };

   Let's focus on cdev, the struct dev that interfaces our device to the kernel. This structure must be initialized and added to the system as descrived above; the scull code that handles this task is:

   static void scull_setup_cdev(struct scull_dev *dev, int index)
   {
      int err, devno = MKDEV(scull_major, scull_minor + index);
      cdev_init(&dev->cdev, &scull_fops);
      dev->cdev.owner = THIS_MODULE;
      dev->cdev.ops = &scull_fops;
      err = cdev_add (&dev->cdev, devno, 1);
      /* Fail gracefully if need be */
      if (err)
      printk(KERN_NOTICE "Error %d adding scull%d", err, index);
  }

   Since the cdev structure is embedded within struct scull_dev, cdev_init must be called to perform the initialization of that structure.

-  The older way

   The way using cdev is the old way. The new way should not use it. The classic way to register a char device driver is with:

   int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);

   Here, major is the major number of interest, name is the name of the driver (it appears in /proc/devices), and fops is the 
   default file_operations structure. A call to register_chrdev registers minor numbers 0â€“255 for the given major, and sets up a
   default cdev structure for each. Devices using this interface must be prepared to handle open calls on all 256 minor numbers(whether
   they correspond to real devices or not??), and they cannot use major or minor numbers greater than 255.

   To unregister, call the following and pass the same major number(if not the same major number, the call will fail):

   int unregister_chrdev(unsigned int major, const char *name);

-  Open and release

   - The open method:

   The open method is provided for a driver to do any initialization in preparation for later operations. In most drivers, open should perform the following tasks:

   1) Check for device-specific errors(such as device-not-ready or similar hardware problems;

   2) Initialize the device if it is being opened for the first time;

   3) Update the f_op pointer, if necessary;

   4) Allocate and fill any data structure to be put in flip->private_data.

   The first business is usually to identify which device is being opened. Remember that the prototype for the open method is:

   int (*open)(struct inode *inode, struct file *filp);

   The inode argument has the information we need in the form of its i_cdev field, which contains the cdev structure we setup before. The only problem is that we do not
   normally want the cdev structure itself, we want the scull_dev structure that contains that cdev structure. The C language lets programmers play all sorts of tricks to
   make that kind of conversion and these tricks are error prone. Fortunately, in this case, the kernel hackers have done the tricky stuff for us, in the form of the 
   container_of macro, defined in <linux/kernel.h>

   
