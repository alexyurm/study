-  Differences among the following commands?

   VARIABLE = value
   
   -> Normal setting of a variable - values within it are recursively expanded when the variable is used, not when it's declared.

   VARIABLE := value

   -> Setting of variable with simple expansion of the values inside - values within it are expanded at declaration time.

   VARIABLE ?= value

   -> Setting of a variable only if it doesn't have a value.

   VARIABLE += value

   -> Appending the supplied value to the existing value

Note:

   When you use VARIABLE = value, if value is actually a reference to another variable, then the value is only determined when VARIABLE is used. This is best illustrated with an example:

   VAL = foo
   VARIABLE = $(VAL)
   VAL = bar

   # VARIABLE and VAL will both evaluate to "bar"
   When you use VARIABLE := value, you get the value of value as it is now. For example:

   VAL = foo
   VARIABLE := $(VAL)
   VAL = bar

   # VAL will evaluate to "bar", but VARIABLE will evaluate to "foo" (really??)

- foreach function: 

   E.g. LDX_MAKE_LIB_NAME  =  $(foreach libBase,${1},S(LDX_LIB_ROOT_DIR)/$(libBase)$(LDX_LIB_EXT))

   The foreach function is very different from other functions. It causes one piece of text to be used repeatedlt. The syntax of the foreach function is:

   (foreach var,list,text )

   1. The first two arguments, var and list, are expanded before anything else is done; note that the last argument text is not expanded at the same time.
   2. Then for each word of the expanded value of list, the variable named by the expanded value of var is set to that word, and text is expanded.
   3. The result is that text is expanded as many times as there are whitespace-seperated words in list. The multiple expansions of text are concatenated, with spaces between them, to make the result of foreach.

-  Introduction to Makefile

   target ... : prerequisites ...
   recipe
   ...
   ...
   -  
      
   target:        the name of a file that is generated by a program. Examples can be executable or object files, or the name of an action to carry out, such as 'clean'.
   prerequisite:  files    

-  How make Processes a Makefile

   make starts the default target first. You can override this behavior using the command line or with the .DEFAULT_GOAL 
   special variable.

   edit: main.o kbd.o comand.o display.o \
         insert.o search.o files.o utils.o
         cc -o edit main.o kdb.o command.o display.o \
            insert.o search.o files.o utils.o
   
   main.o: main.c defs.h

   kbd.o :  kbd.c defs.h command.h
      cc -c command.c
   command.o : command.c defs.h command.h 
      cc-c kbd.c
   display.o : display.c defs.h buffer.h
      cc -c display.c
   insert.o : insert.c defs.h buffer.h
      cc -c insert.c
   search.o : search.c defs.h buffer.h
      cc -c search.c
   files.o : files.c defs.h buffer.h command.h
      cc -c fiels.c
   utils.o : utils.c defs.h
      cc -c
   clean : rm edit main.o kbd.o command.o display.o \ 
               insert.o search.o files.o utils.o

   edit : main.o kbd.o command.o display.o \
                  insert.o search.o files.o utils.o
         cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o

   1) the default rule is for relinking 'edit'; but before make can fully process the rule, it must process the rules for 
   the files that 'edit' depends on(in this case, the obj files).

   2) These rules say to update each '.o' file by compiling its source file. The recompilation must be done if the source
   file, or any of the header files named as preauisites, is more recent than the object file, or if the object file does
   not exist.
