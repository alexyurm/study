Chapter 1: Introduction

1.2   Hardware Dependency

      -  in Linux kernel, there is a neat distinction between hardware-dependent and hardware-independent source code. To that end, both the arch and the include directores include 23 subdirectories that correspond to different 
         types of hardware platforms supported. E.g.

         arm:  ARM processor based
         
         um:   User Mode Linux, a virtual platform that allows developers to run kernel in User Mode.

1.3   Linux version

      -  2.6.24.11

         second number: 1) even: stable version; 2) otherwise, development version.

         Those kind of stable/non-stable doesn't exist anymore since 2.6.

1.4   Basic OS Concepts

      -  The operating system must fullfill two main objects:

         1. Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform;
         2. Provide an execution environment to the applications that run on the computer system (the so-called user programs).

      -  1.4.4 Kernel Architecture

         Two different types of kernels:

         1) Microkernel -> it demands a very small set of functions from the kernel, generally including a few synchronization primitives, a simple scheduler, and interprocess communication mechanism.

         2) Monolithic: -> Each kernel layer is integrated into the whole kernel program and run in Kernel Mode. on behalf of the current process.
         
         A module (to advantages of microkernels ) is an object file whose code can be linked to (and unlinked from) the kernel at runtime. The object code usually consists of a set of functions that implements a filesystem, a device
         driver, or other features at the kernel's upper layer. The kernel module, unlike the external layers of microkernel OS, does not run as a specific process. Instead, it is executed in Kernel mode on behalf of the current 
         process, like any other statically linked kernel function.

1.5   Overview of the Unix system

      -  1.5.4 File Descriptor and Inode

         All information needed by the filesystem to handle a file is included in a data structure called inode. inode may include some of the following attributes:

         • File type (see the previous section)
         • Number of hard links associated with the file
         • File length in bytes
         • Device ID (i.e., an identifier of the device containing the file)
         • Inode number that identifies the file within the filesystem
         • UID of the file owner
         • User group ID of the file
         • Several timestamps that specify the inode status change time, the last access time, and the last modify time
         • Access rights and file mode

      -  1.5.5 Access Rights and File Mode

         The potential users of a file fall into three classes:

         1) the user who owns of the file;
         2) The users who belong to the same group as the file, not including the owner;
         3) All remaining users.

         Except for the 9 bit flags (3 bit for each class), we also have suid (Set User ID) , sgid (Set Group ID)

         suid

         A process executing a file normally keeps the User ID (UID) of the process owner. However, if the executable file has the suid flag set, the process gets the UID of the file owner.

         guid
        
         A process executing a file normally keeps the user group ID of the process group. However, if the executable file has the sgid flag set, the process gets the user group ID of the file.

         sticky

         Obsolete: An executable file with the sticky flag set corresponds to a request to the kernel to keep the program in memory after its execution terminates

1.6   An overview of Unix Kernels

      1.6.1. The Process/Kernel Model

      Beside user process, Unix systems include a few privileged processs called kernel threads with the following characteristics:

      • They run in Kernel Mode in the kernel address space.
      • They do not interact with users, and thus do not require terminal devices.
      • They are usually created during system startup and remain alive until the system is shut down.

      Unix kernel do much more that handle system calls; in fact, kernel routines can be activated in serval ways:

      • A process invokes a system call.
      • The CPU executing the process signals an exception, which is an unusual condition such as an invalid instruction. The kernel handles the exception on behalf of the process that caused it.
      • A peripheral device issues an interrupt signal to the CPU to notify it of an event such as a request for attention, a status change, or the completion of an I/O operation. Each interrupt 
        signal is dealt by a kernel program called an interrupt handler. Because peripheral devices operate asynchronously with respect to the CPU, interrupts occur at unpredictable times.
      • A kernel thread is executed. Because it runs in Kernel Mode, the corresponding program must be considered part of the kernel.
 
      1.6.2. Process Implementation

      Each process is represented by a process descriptor that includes info. about the current state of the process.

      • The program counter (PC) and stack pointer (SP) registers
      • The general purpose registers
      • The floating point registers
      • The processor control registers (Processor Status Word) containing information about the CPU state
      • The memory management registers used to keep track of the RAM accessed by the process

      1.6.3 Reentrant Kernel

      Linux kernel is reentrant. That means that serval process may be executing in Kernel Mode at the same time. Two ways to implement Reetrancy:

      1) Reentrant Function: Especially implemented in real time kernel, reentrant functions only modify local variable and do not alter global data structures. 
      2) Non reentrant function: using locking mechanisms to ensure that only one process can execute a nonreentrant function at a time.

      In the simplest case, the CPU executes a kernel control path sequentially from the first instruction to the last. When one of the following evernts occurs, the CPU interleaves the kernel control path:

      • A process executing in User Mode invokes a system call, and corresponding kernel control path verifies that the request cannot be satisfied immediately; it then invokes the scheduler to select a new
        process to run. As a result, a process switch occurs. The first kernel control path is left unfinished, and the CPU resumes the execution of some other kernel control path. In this case, the two control
        paths are executed on behalf of two different processes.

      • The CPU detects an exception for example,  access a page not present in RAM while running a kernel path. The first control path is suspended, and the CPU starts the execution of a suitable procedure. In
        our example, this type of procedure can allocate a new page for the process and read its contents from disk. When procedure terminates, the first control path can be resumed. In this case, the two control
        paths are executed on behalf of the same process.

      • A hardware interrupt occurs while the CPU is running a kernel control path with the interrupts enabled. The first kernel control path is left unfinished, and the CPU starts processing another kernel control
        path to handle the interrupt. The first kernel control path resumes when the interrupt handler terminates. In this case, the two kernel control paths run in the execution context of the same process, and the 
        total system CPU time is accounted to it. However, the interrupt handler doesn't necessarily operate on behalf of the process.

      • An interrupt occurs while the CPU is running with kernel preemption enabled, and a higher priority process is runnable. In this case, the first kernel control path is left unfinished, and the CPU resumes executing
        another kernel control path on behalf of the higher priority process. This occurs only if the kernel has been compiled with kernel prremption support. 

      1.6.4 Process Address Space

      Each process runs in its private address address.

      User Mode: process running in user mode refers to private stack, data, and code areas.
      Kernel Mode: process running in kernel mode addresses the kernel data and code areas and uses another private stack.

      1.6.5 Synchronization and Critical Regions

      Implementing a reentrant kernel requires the use of synchronization. If a kernel control path is suspended while acting on kernel data, no other kernel control path should be allowed to act on the same data structure
      unless it has been reset to a consistent state. Otherwise, the interaction of the two control paths could corrupt the stored information.

      1.6.5.1 Kernel preemption disabling -> Nonprremptability is not enough for multiprocessor systems, because two kernel control paths running on different CPU can concurrently access the same data structure.

      1.6.5.2 disabling hardware interrupt -> it is far from optimal because interrupts can remain disabled for a relatively long time, potentially causing all hardware activities to freeze.

      1.6.5.3 Semaphores -> A semaphore is simply a counter associated with a data structure. it is checked by all kernel threads before they try to access the data structure. Each semaphore maybe viewed as a object composed of:

      1）An integer avalue;
      2) A list of waiting process;
      3) Two atomic methods: up() and down()

      The down() method decreases the value of the semaphore. If the new value is less than 0, the method adds the running process to the semaphore list and then blocks. (e.g. invokes the scheduler). The up() method increases
      the value of the semaphore and, if its new value is greater that or equal to 0, reactivates one or more processes in the semaphore list. The up() method increases the value of the semaphore and, if its new value is greater
      than or equal to 0, reactivates one or more processes in the semaphore list.

      Each data structure to be protected has its own semaphore, which is initialized to 1. When a kernel control path wishes to access the data structure, it executes the down() method on the proper semaphore. If the value of the new
      semaphore isn't negative, access to the data structure is granted. Otherwise, the process that is executing the kernel control path is added to the semaphore list and blocked. When another process executes the up() method on that
      semaphore, one of the processes in the semaphore lists is allowed to proceed.

      1.6.5.5 Avoiding deadlocks

      The simplest case of deadlock occurs when process p1 gains access to data structure a and process p2 gains access to b. but p1 then waits for b and p2 waits for a. How to avoid deadlocks (??)

      1.6.6    Signal and Interprocess Communication

      Unix signals provide a mechanism for notifying processs of system events. Each event has its own signal number, which is usually referred to by a symbolic constant such as SIGTERM. There are two kinds of system events:

      1) Asynchronous notifications

      E.g. A process sends SIGINT to a foreground process by pressing the interrupt keycode (usually Ctrl-C) at the terminal.

      2) Synchronous notifications

      For instance, the kernel sends the signal SIGSEGV to a process when it accesses a memory location at an invalid address.

      In general, a process may react to a signal delivery in two possible ways:

      - Ignore the signal.
      - Asynchronously execute a specified process (the signal handler)

Chapter 2
