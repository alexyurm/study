Chapter 1 

-  In Java, everything goes in class. You'll type your source code file (with java extension), then compile it into a new class file (with a .class extension). When you run your program, you're really running a class.

-  Running a program means telling the Java Virtual Machine to "Load the Hello class then start executing its main()".

Chapter 2 Objects and Classes

-  A class is a blueprint for an object(or instance).

-  Things that an object can do are called methods.

-  As long you're in main(), you are not really in Objectville. It's fine for a test program to run within the main method. But in true OO application, you need objects talling
   to other objects, as opposed to a static main() method creating and testing objects.

-  A real Java application is nothing but objects talking to other objects. In this case, talking means objects calling methods of on one another.

-  Java takes out the garbage:

   Each time an object is created in Java, it goes into an area of memory known The Heap. The Java Heap, which is not like the heap memory in C/C++, is actually a Garbage-Collection
   Heap. When JVM can 'see' that an object can never be used again, that object becomes eligible collection.

-  It would be a big pain to deliver a huge bunch of individual files to your end-users but you won't have to. You can put all of your application files into Java Archive - a .jar file
   that is based on the pkzip format. In the jar file, you can include a simple text file formatted as something called a manifest, that defines which class in that jar holds the main()
   method that should run.

-  A class can inherit instance variables and methods from a more abstract superclass.

Chapter 3  Primitives and References.

-  A primitive variable (int, float...) is full of bits representing the actual value of the variable, an object reference variable is full of bits representing a way to get to 
   the object. Remember again, objects live in one place and one place only - the garbage collectible heap.

-  Dog myDog = new Dog();

   Step1: Dog myDog: Tells the JVM to allocate space for a reference variable and names that variable myDog.

   Question: Where is the space allocated from?

   Step2: new Dog();: Tells the JVM to allocate space for a new Dog object on the heap.

   Step3: Dog myDog = new Dog();: Assigns the new Dog to the reference variable myDog.

-  We cannot do arithmetic on a reference variable, e.g. increment it.

-  An array itself (e.g. int[] and dog[]) is an object.

-  A reference variable has value of null when it is not referencing any object.

-  An array is alwasy an object, even if the array is declared to hold primitives. There is no such thing as a primitive array, only an array that holds primitives.

Chapter 4 How objects behave

-  A class describes what an object knows and what an object does.

-  Java is pass-by-value. That means pass by copy.

-  As the encapsulation starter rule of thumb: mark your instance variables private and provide public getters and setters for access control.

-  You don't have to initialize instance variables, because they always have a default value. Number primitives (including char) get 0, booleans get false, 
   and objects reference variables get null. Remember null just means a remote control that isn't controlling/programmed to anything. A reference, but no actual object.

-  The difference between instance and local variables:

   Instance variables are declared inside a class but not within a method.

   class Horse
   {
      private double height = 15.2;
      private String breed;

      //more code...
   }

   Local variables are declared within a method. Local variables must be initilized before use!

   class Foo
   {
      public void go()
      {
         int x;
         int z = x + 3;  <--- It won't compile!! You declare x without a value, but as soon as you try to use it, the compiler freaks out.
      }
   }

-  Comparing variables.

   == : to know if two primitives are the same.

-  Developing a Class:

   prep code:  A form of pseudocode to help you focus on the logic without stressing about syntax;

   test code: A class or methods that will test the real code and validate that it's doing the right thing;

   real code: The actual implementation of the class.

Chapter 5 Extra-Strength Methods

-  The enhanced for loop

   Beginning with java 5.0(Tiger), the Java language has a second kind of for loop called the "enhanced for", that makes it easier to iterate over all the elements
   in an array or other kinds of collections.

   for (String name: nameArray){}
   
   What it means in plain English: For each element in nameArray, assign the element to the 'name' variable, and run the body of the loop.

   Note: the colon(:) means "IN"

Chapter 6 Using the Java Library

-  "ArrayList" is a class in the core Java library (the API).

   add
   remove
   contains
   isEmpty
   indexOf
   size
   get
   ...

-  Although an ArrayList holds objects and not primitives, the compiler will automatically "wrap" (and "unwrap" when you take it out) a primitive into an Object, and place that
   object in the ArrayList instead of primitive.

-  You declare the type of the array using a type parameter, which is a type name in angle brackets. E.g.

   ArrayList<Button> means ArrayList will be able to hold only objects of type Button (or subclass of Button as you will learn in the next couple of chapters)

-  In the java API, classes are grouped into packages. to use a class in the API, you have to know which package the class is in. Using a class from the API is simple, somewhere
   in your code, you have to indicate the full name of the library class you want to use, and that means package name + class name
   
   E.g.

   java.util.ArrayList;
   
   where

   "java.util" is the package name and "ArrayList" is the class name.

-  You have to tell Java which ArrayList you want to use. You have two options:

   Put an import statement at the top of your source code file:

   java.util.ArrayList;
   public class MuClass {...}

   or

   Type the full name everywhere in your code each time you use it.

   1) When you declare and/or instantiate it:
   
      java.util.ArrayList<Dog> list = new java.util.ArrayList<Dog>();

   2) When you use it as an argument type:
   
      public void go(java.util.ArrayList<Dog> list) { }

   3) When you use it as a return type:
   
      public java.util.ArrayList<Dog> foo() {...}

-  "import" is different from "include" in C. An import is simply the way you give Java the full name of a class.

-  Remember, you have to tell Java the full name of every class you use, unless the class is in the java.lang.
   
Chapter 7 inheritance and polymorphism

-  When you call a method on an object reference, you're calling the most specific version of the method for that object type. In other words, the lowest one wins. Here "Lowest"
   means lowest on the inheritance tree.

-  Remember that when one class inherits from another, we say that the subclass extends the supercla. We use "IS-A" test to test if the inheritance makes sense. To know if you've
   designed your types correctly, ask, "Does it make sense to say type X IS-A type of Y?"
   
-  In a subclass, how to use both the superclass version and my overriding subclass version of a method?

   public void roam() {
   super.roam(); //this calls the inherited version of roam()
   // my own roam stuff
   }

-  A subclass inherits members(instance variables and methods) of the superclass. A superclass can choose whether or not it wants a subclass to inherit a particular member by the
   level of access the particular member is given.

   There are 4 access levels covered in this book:

   private: public members are inherited.
   default: private members are not inherited.
   protected:
   public:

-  Inherited methods can be overridden; instance variables cannot be overriden (although they can be redefined in the subclass, but that's not the same thing, and there's almost never
   a need to it.)

-  Inheritance lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a common protocol for
   a set of classes related though inheritance.

-  With polymorphism, the reference type can be a superclass of the actual object type.

   Animal myDog = new Dog();

   Also, you can have polymorphic arguments and return types. E.g.

   class Vet {
      public void giveShot (Animal a) {
      // do horrible things to the Animal at
      // the other end of the 'a' parameter
      a.makeNoise();
   }

   class PetOwner {
      public void Start() {
         Vet v = new Vet();
         Dog d = new Dog();
         Hippo h = new Hippo();
         v.giveShot(d); //dog's makeNoise runs
         v.giveShot(d); //Hippo's makeNoise() runs

   With polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program. Let's say if others want to take advantage of your
   your Vet class, all they have to do is make sure their new Animal types extend class Animal. The Vet methods will still work, even though the Vet class was written without
   any knowledge of the new Animal subtypes the Vet will be working on.

-  If you want to protect a specific method from being overriden, mark the method with the "final" modifier. Mark the whole class as final if you want to guarantee that none
   of the methods in that class will ever be overriden.

-  Overriding: The arguments and return types of your overriding method must look to the outside world exactly like the overriden method in the superclass. E.g.

   Appliance:

      boolean turnOn()

      boolean turnOff()

   Toaster:

      boolean turnOn(int level) <--This is actually overload but not override as the arguments have been changed!

   Also, the access level must be the same or friendlier. That means you cannot for example override a public method and make it private.

-  Overloading: It means two methods with the same name but different argument lists. remember, there is no polymorphism involved with overloaded methods.

   Overloading lets you make multiple versions of a method. Something to remember about overload:

   1) The return types can be different;
   2) You cannot change only the return type;
   3) You can vary the access levels in any direction.

Chapter 8 Serious Polymorphism

-  Abstract classes

   Some classes just should not be instantiated. E.g. Animals. By marking the class as abstact, the compiler will stop any code, anywhere, from ever creating an instance
   of that type. to mark a class as abstract, put the keyword "abstract" before the class declaration:

   abstract class Canine extends Animal {
      public void roam {}
   }

   By doing this, the compiler won't let you instantiate an abstract class

   abstract class Canine extends Animal {
      public void roam {}
   }

   public class MakeSense {
      public void go() {
         Canine c;
         c = new Dog(); // <--- This is OK
         c = new Canine(); <---class Canine is marked abstract so the compiler will Not let you do this.

-  Abstract methods

   You can mark methods abstract too. An abstract class means the class must be extended; an abstract method means the method must be overriden.

   An abstract method has no body:

   public abstract void eat(); 

   Also, if you declare an abstract method, you MUST mark the class abstract as well. You can’t have an abstract method in a non-abstract class. In other words, if a class has
   even one abstract method, the class must be marked abstract.

   The point of using abstract methods is...Polymorphism! Image how you'd have to change the Vet class, if it didn't use Animal as its argument type of methods. You'd have to
   have a seperate method for every single Animal subclass!

   Abstract methods don't have a body; that means the first concrete class in the inheritance tree must implement all abstract methods.

-  Every class in Java extends class "Object". That means "Object" is the superclass of everything. It also means that every class you write extends "Object".

   public class Dog extends Objext{}

   But wait a minute, Dog already extends Canine. It is OK becasue the compiler will make Canine extend Object instead. Except Canine extends Animal. No problem, then the compiler
   will just make Animal extend Object.

-  So what's in this ultra-super-megaclass Object?

   1) equals(object o) ->> tells you if two objects are equal.

   e.g. a.equals(c) <--a, c are objects
   
   2) getClass --> Gives you back the class that object was instantiated from

   3) hashCode --> Prints out a hashcode for the object

   4) toString --> Prints out a String message with the name of the class and some other number we rarely care about.

-  The compiler decides whether you can call a method based on the reference type, not the actual object type. E.g.

   Object o = al.get(index);
   int i = o.hashCode(); <-- this is fine as every object in Java can call hashCode().
   o.bark(); <-- Can't do this. The Object class has not idea what it means to bark(), Even though you know it's really a Dog at that index, the compiler doesn't.

   The compiler checks the class of the reference type, not the object type - to see if you can call a method using that reference.

-  Casting an object reference back to its real type

   You must ensure that the object is really dog, e.g.,    

   Object o = al.get(index);
   Dog d = (Dog) o;
   d.roam();

   If you not sure it's a Dog, you can use instanceof operator to check:

   if (o instanceof Dog) {
      Dog d = (Dog) o;
   }

-  A Java interface solves your multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the
   Deadly Diamond of Death (DDD).

   Note: What is Deadly diamond of Death?

   The way to handle that is very simple: make all the methods abstract.

   Pet:

   abstract void beFriendly();
   abstract void play();

   1) To DEFINE an interface:

   public interface Pet {...}
               ^
               |-----------------> Use the keyword "interface" instead of "class"

   2) To IMPLEMENT an interface:
   
   public class Dog extends Canine implements Pet {...}
                                       ^
                                       |
                                       |-----------------Use the keyword "implements" followed by the inferface name. Note that when you implement an interface you still get
                                                         to extend a class.

   3) Making and Implementing the Pet interface:

   public interface Pet {

      public abstract void beFriendly();  <--no body as it is an abstract method.
      public abstract void play(); <--no body as it is an abstract method.

   public class Dog extends Canine implements Pet {
   
      public abstract void beFriendly() {...} <---Implement the pet method
      public abstract void play() {...} <--Implement the pet method

      public void roam() {...} <-- This is just normal overriding method.
      public void eat() {...} <-- This is just normal overriding method.

-  In summary, how do you know whether to make a class, a subclass, an abstract class, or an inferface:

   1) Make a class that doesn’t extend anything (other than Object) when your new class doesn’t pass the IS-A test for any other type.

   2) Make a subclass (in other words, extend a class) only when you need to make a more specific version of a class and need to override or add new behaviors.

   3) Use an abstract class when you want to define a template for a group of subclasses, and you have at least some implementation code that all subclasses 
      could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.

   4) Use an interface when you want to define a role that other classes can play, regardless of where those classes are in the inheritance tree.

-  Invoking the superclass version of a method

   If you want to invoke the superclass version of a method instead of the overriden one, use the keyword "super" lets you invoke a superclass version of an overridden method, 
   from within the subclass. E.g.

   abstract class Report {
      void runReport() {
         //setup a report
      }
      void printReport() {
         //generic printing
      }
   }

   class BuzzwordsReport extends Report {
      
      void runreport () {
         super.runReport(); //call superclass version then come back and do some subclass-specific stuff.
         buzzwordCompliance();
         printReport();
      }
      
      void buzzwordCompilance() {...}

  The "super" keyword is really a reference to the superclass portion of an object. 

Chapter 9 Life and Death of an Object


