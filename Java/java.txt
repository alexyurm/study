Chapter 1 

-  In Java, everything goes in class. You'll type your source code file (with java extension), then compile it into a new class file (with a .class extension). When you run your program, you're really running a class.

-  Running a program means telling the Java Virtual Machine to "Load the Hello class then start executing its main()".

Chapter 2 Objects and Classes

-  A class is a blueprint for an object(or instance).

-  Things that an object can do are called methods.

-  As long you're in main(), you are not really in Objectville. It's fine for a test program to run within the main method. But in true OO application, you need objects talling
   to other objects, as opposed to a static main() method creating and testing objects.

-  A real Java application is nothing but objects talking to other objects. In this case, talking means objects calling methods of on one another.

-  Java takes out the garbage:

   Each time an object is created in Java, it goes into an area of memory known the Heap. The Java Heap, which is not like the heap memory in C/C++, is actually a Garbage-Collection
   Heap. When JVM can 'see' that an object can never be used again, that object becomes eligible collection.

-  It would be a big pain to deliver a huge bunch of individual files to your end-users but you won't have to. You can put all of your application files into Java Archive - a .jar file
   that is based on the pkzip format. In the jar file, you can include a simple text file formatted as something called a manifest, that defines which class in that jar holds the main()
   method that should run.

-  A class can inherit instance variables and methods from a more abstract superclass.

Chapter 3  Primitives and References.

-  A primitive variable (int, float...) is full of bits representing the actual value of the variable, an object reference variable is full of bits representing a way to get to 
   the object. Remember again, objects live in one place and one place only - the garbage collectible heap.

-  Dog myDog = new Dog();

   Step1: Dog myDog: Tells the JVM to allocate space for a reference variable and names that variable myDog.

   Question: Where is the space allocated from?

   Step2: new Dog();: Tells the JVM to allocate space for a new Dog object on the heap.

   Step3: Dog myDog = new Dog();: Assigns the new Dog to the reference variable myDog.

-  We cannot do arithmetic on a reference variable, e.g. increment it.

-  An array itself (e.g. int[] and dog[]) is an object.

-  A reference variable has value of null when it is not referencing any object.

-  An array is alwasy an object, even if the array is declared to hold primitives. There is no such thing as a primitive array, only an array that holds primitives. E.g.

   Dog[] myDogs = new Dog[3];
   myDogs[0] = new Dog();
   myDogs[0].name = "Fido";

Chapter 4 How objects behave

-  A class describes what an object knows and what an object does.

-  Java is pass-by-value. That means pass by copy.

-  As the encapsulation starter rule of thumb: mark your instance variables private and provide public getters and setters for access control.

-  You don't have to initialize instance variables, because they always have a default value. Number primitives (including char) get 0, booleans get false, 
   and objects reference variables get null. Remember null just means a remote control that isn't controlling/programmed to anything. A reference, but no actual object.

-  The difference between instance and local variables:

   Instance variables are declared inside a class but not within a method.

   class Horse
   {
      private double height = 15.2;
      private String breed;

      //more code...
   }

   Local variables are declared within a method. Local variables must be initilized before use!

   class Foo
   {
      public void go()
      {
         int x;
         int z = x + 3;  <--- It won't compile!! You declare x without a value, but as soon as you try to use it, the compiler freaks out.
      }
   }

-  Comparing variables.

   == : to know if two primitives are the same.

-  Developing a Class:

   prep code:  A form of pseudocode to help you focus on the logic without stressing about syntax;

   test code: A class or methods that will test the real code and validate that it's doing the right thing;

   real code: The actual implementation of the class.

Chapter 5 Extra-Strength Methods

-  The enhanced for loop

   Beginning with java 5.0(Tiger), the Java language has a second kind of for loop called the "enhanced for", that makes it easier to iterate over all the elements
   in an array or other kinds of collections.

   for (String name: nameArray){}
   
   What it means in plain English: For each element in nameArray, assign the element to the 'name' variable, and run the body of the loop.

   Note: the colon(:) means "IN"

Chapter 6 Using the Java Library

-  "ArrayList" is a class in the core Java library (the API).

   add
   remove
   contains
   isEmpty
   indexOf
   size
   get
   ...

-  Although an ArrayList holds objects and not primitives, the compiler will automatically "wrap" (and "unwrap" when you take it out) a primitive into an Object, and place that
   object in the ArrayList instead of primitive.

-  You declare the type of the array using a type parameter, which is a type name in angle brackets. E.g.

   ArrayList<Button> means ArrayList will be able to hold only objects of type Button (or subclass of Button as you will learn in the next couple of chapters)

-  In the java API, classes are grouped into packages. to use a class in the API, you have to know which package the class is in. Using a class from the API is simple, somewhere
   in your code, you have to indicate the full name of the library class you want to use, and that means "package name + class name"
   
   E.g.

   java.util.ArrayList;
   
   where

   "java.util" is the package name and "ArrayList" is the class name.

-  You have to tell Java which ArrayList you want to use. You have two options:

   Put an import statement at the top of your source code file:

   java.util.ArrayList;
   public class MuClass {...}

   or

   Type the full name everywhere in your code each time you use it.

   1) When you declare and/or instantiate it:
   
      java.util.ArrayList<Dog> list = new java.util.ArrayList<Dog>();

   2) When you use it as an argument type:
   
      public void go(java.util.ArrayList<Dog> list) { }

   3) When you use it as a return type:
   
      public java.util.ArrayList<Dog> foo() {...}

-  "import" is different from "include" in C. An import is simply the way you give Java the full name of a class.

-  Remember, you have to tell Java the full name of every class you use, unless the class is in the java.lang.
   
Chapter 7 inheritance and polymorphism

-  When you call a method on an object reference, you're calling the most specific version of the method for that object type. In other words, the lowest one wins. Here "Lowest"
   means lowest on the inheritance tree.

-  Remember that when one class inherits from another, we say that the subclass extends the superclass. We use "IS-A" test to test if the inheritance makes sense. To know if you've
   designed your types correctly, ask, "Does it make sense to say type X IS-A type of Y?"
   
-  In a subclass, how to use both the superclass version and my overriding subclass version of a method?

   public void roam() {
   super.roam(); //this calls the inherited version of roam()
   // my own roam stuff
   }

-  A subclass inherits members(instance variables and methods) of the superclass. A superclass can choose whether or not it wants a subclass to inherit a particular member by the
   level of access the particular member is given.

   The following table shows the access to members permitted by each modifier:

   | Modifier | Class    | Package |  Subclass | World |
      public     Y            Y          Y         Y
     protected   Y            Y          Y         N
     default     Y            Y          N         N
     private     Y            N          N         N

-  Inherited methods can be overridden; instance variables cannot be overriden (although they can be redefined in the subclass, but that's not the same thing, and there's almost never
   a need to it.)

-  Inheritance lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a common protocol for
   a set of classes related though inheritance.

-  With polymorphism, the reference type can be a superclass of the actual object type.

   Animal myDog = new Dog();

   Also, you can have polymorphic arguments and return types. E.g.

   class Vet {
      public void giveShot (Animal a) {
      // do horrible things to the Animal at
      // the other end of the 'a' parameter
      a.makeNoise();
   }

   class PetOwner {
      public void Start() {
         Vet v = new Vet();
         Dog d = new Dog();
         Hippo h = new Hippo();
         v.giveShot(d); //dog's makeNoise runs
         v.giveShot(h); //Hippo's makeNoise() runs

   With polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program. Let's say if others want to take advantage of your
   your Vet class, all they have to do is make sure their new Animal types extend class Animal. The Vet methods will still work, even though the Vet class was written without
   any knowledge of the new Animal subtypes the Vet will be working on.

-  If you want to protect a specific method from being overriden, mark the method with the "final" modifier. Mark the whole class as final if you want to guarantee that none
   of the methods in that class will ever be overriden.

-  Overriding: The arguments and return types of your overriding method must look to the outside world exactly like the overriden method in the superclass. E.g.

   Appliance:

      boolean turnOn()

      boolean turnOff()

   Toaster:

      boolean turnOn(int level) <--This is actually overload but not override as the arguments have been changed!

   Also, the access level must be the same or friendlier. That means you cannot for example override a public method and make it private.

-  Overloading: It means two methods with the same name but different argument lists. remember, there is no polymorphism involved with overloaded methods.

   Overloading lets you make multiple versions of a method. Something to remember about overload:

   1) The return types can be different;
   2) You cannot change only the return type;
   3) You can vary the access levels in any direction.

Chapter 8 Serious Polymorphism

-  Abstract classes

   Some classes just should not be instantiated. E.g. Animals. By marking the class as abstact, the compiler will stop any code, anywhere, from ever creating an instance
   of that type. to mark a class as abstract, put the keyword "abstract" before the class declaration:

   abstract class Canine extends Animal {
      public void roam {}
   }

   By doing this, the compiler won't let you instantiate an abstract class

   abstract class Canine extends Animal {
      public void roam {}
   }

   public class MakeSense {
      public void go() {
         Canine c;
         c = new Dog(); // <--- This is OK
         c = new Canine(); <---class Canine is marked abstract so the compiler will Not let you do this.

-  Abstract methods

   You can mark methods abstract too. An abstract class means the class must be extended; an abstract method means the method must be overriden.

   An abstract method has no body:

   public abstract void eat(); 

   Also, if you declare an abstract method, you MUST mark the class abstract as well. You can’t have an abstract method in a non-abstract class. In other words, if a class has
   even one abstract method, the class must be marked abstract.

   The point of using abstract methods is...Polymorphism! Image how you'd have to change the Vet class, if it didn't use Animal as its argument type of methods. You'd have to
   have a seperate method for every single Animal subclass!

   Abstract methods don't have a body; that means the first concrete class in the inheritance tree must implement all abstract methods.

-  Every class in Java extends class "Object". That means "Object" is the superclass of everything. It also means that every class you write extends "Object".

   public class Dog extends Objext{}

   But wait a minute, Dog already extends Canine. It is OK becasue the compiler will make Canine extend Object instead. Except Canine extends Animal. No problem, then the compiler
   will just make Animal extend Object.

-  So what's in this ultra-super-megaclass Object?

   1) equals(object o) ->> tells you if two objects are equal.

   e.g. a.equals(c) <--a, c are objects
   
   2) getClass --> Gives you back the class that object was instantiated from

   3) hashCode --> Prints out a hashcode for the object

   4) toString --> Prints out a String message with the name of the class and some other number we rarely care about.

-  The compiler decides whether you can call a method based on the reference type, not the actual object type. E.g.

   Object o = al.get(index);
   int i = o.hashCode(); <-- this is fine as every object in Java can call hashCode().
   o.bark(); <-- Can't do this. The Object class has not idea what it means to bark(), Even though you know it's really a Dog at that index, the compiler doesn't.

   The compiler checks the class of the reference type, not the object type - to see if you can call a method using that reference.

-  Casting an object reference back to its real type

   You must ensure that the object is really dog, e.g.,    

   Object o = al.get(index);
   Dog d = (Dog) o;
   d.roam();

   If you not sure it's a Dog, you can use instanceof operator to check:

   if (o instanceof Dog) {
      Dog d = (Dog) o;
   }

-  A Java interface solves your multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the
   Deadly Diamond of Death (DDD).

   Note: What is Deadly diamond of Death??

   The "diamond problem" (sometimes refereed to as the "deadly diamond of death") is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from
   B and C.

         A
       /   \
      /     \
      B     C           (the shape looks like a diamond)
      ^     ^
      \     /
       \   /
         D

   If D calls a method defined in A (and does not override the method), and B and C override that method differently, this from which class does it inherit: B or C? It's 
   called the "diamond problem" because of the shape of the class inheritance diagram in this situation.

   The way to handle that is very simple: make all the methods abstract(How to solve the DDD using abstract methods?).

   Pet:

   abstract void beFriendly();
   abstract void play();

   1) To DEFINE an interface:

   public interface Pet {...}
               ^
               |-----------------> Use the keyword "interface" instead of "class"

   2) To IMPLEMENT an interface:
   
   public class Dog extends Canine implements Pet {...}
                                       ^
                                       |
                                       |-----------------Use the keyword "implements" followed by the inferface name. Note that when you implement an interface you still get
                                                         to extend a class.

   3) Making and Implementing the Pet interface:

   public interface Pet {

      public abstract void beFriendly();  <--no body as it is an abstract method.
      public abstract void play(); <--no body as it is an abstract method.

   public class Dog extends Canine implements Pet {
   
      public abstract void beFriendly() {...} <---Implement the pet method
      public abstract void play() {...} <--Implement the pet method

      public void roam() {...} <-- This is just normal overriding method.
      public void eat() {...} <-- This is just normal overriding method.

-  In summary, how do you know whether to make a class, a subclass, an abstract class, or an inferface:

   1) Make a class that doesn’t extend anything (other than Object) when your new class doesn’t pass the IS-A test for any other type.

   2) Make a subclass (in other words, extend a class) only when you need to make a more specific version of a class and need to override or add new behaviors.

   3) Use an abstract class when you want to define a template for a group of subclasses, and you have at least some implementation code that all subclasses 
      could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.

   4) Use an interface when you want to define a role that other classes can play, regardless of where those classes are in the inheritance tree.

-  Invoking the superclass version of a method

   If you want to invoke the superclass version of a method instead of the overriden one, use the keyword "super" lets you invoke a superclass version of an overridden method, 
   from within the subclass. E.g.

   abstract class Report {
      void runReport() {
         //setup a report
      }
      void printReport() {
         //generic printing
      }
   }

   class BuzzwordsReport extends Report {
      
      void runreport () {
         super.runReport(); //call superclass version then come back and do some subclass-specific stuff.
         buzzwordCompliance();
         printReport();
      }
      
      void buzzwordCompilance() {...}

  The "super" keyword is really a reference to the superclass portion of an object. 

Chapter 9 Life and Death of an Object

-  The STACK and the HEAP: where things live

   Stack: method invocations and local variables live
   Heap:  objects live

   Instance variables: they are declared inside a class but not inside a method.
   Local variables: they are declared inside a method, including method parameters.
   The method on the top of the stack is always the currently-executing method.

   Note: No matter where the object reference variable is declared (inside a method vs an instance variable of a class)the object always always always goes on the heap.
   
-  Instance variables live on the heap, inside the object they belong to.

   1) If the instance variables are all primitives, Java makes space for the instance variables based on the primitive type. E.g. an int needs 32 bits.
   2) How about the instance variables are objects? 

      If the instance variable is declared but no object is assigned to it, then only the space for the reference variable (the remote control) is created.
      
      private Antenna ant;

      No actual Antenna object is made on the heap unless or until the reference variable is assigned a new Antenna object:

      private Antenna ant = new Antenna();

   Instance variables are assigned a default value. even when you don't explicitly assign one. The default values are 0/0.0/false for primitives, and null for references.

-  Constructor

   A constructor is the code that runs when you say "new" on a class type. A constructor must have the same name as the class, and must not have a return type.
   By default, there is nothing inside the constructor of a class:

   public class Duck {
      public Duck { 
      
      //empty here. Remember there is no code here. Also there is no return type.
      }
   }

   You can do more with constructor. E.g.

   public Duck(int duckSize) {
      size = duckSize; //size is the instance variable.
   }

   Remember, the compiler gets involved with constructor making only if you don't say anything at all about constructors. That means no to the question: Doesn't the compiler
   always make no-arg constructor for you?

   If you write a constructor that takes arguments, and you still want a no-arg constructor, you'll have to build the no-arg constructor yourself! That means if you touch the
   constructor, you need to write two versions of it. Overloaded constructors means you have more than one constructor in your class. To copmpile, each constructor must have
   diffeent argument list!

-  The big point there was that every object holds not just its own declared instance variables, but also everything from its superclasses(which, at minimum, means class Object
   , since every class extends Object). But how does a superclass constructor gets involked?

   call super(). E.g.

   public class Duck extends Animal {
      int size;

      public Duck(int newSize) {
         super();
         size = newSize;
      }
   }

   The compiler gets involved in constructor-making in two ways:

   1) If you don't provide a constructor, the compiler puts one in that looks like:

      public ClassName() {
         super();
      }

   2) If you do provide a constructor but you do not put in the call to super():

      The compiler will put a call to super() in each of your overloaded constructors(unless the constructor calls another overloaded constructor). The compiler-supplied 
      call looks like:
      
      super();

      It always looks like that. The compiler-inserted call to super() is always no-arg call. If the superclass has overloaded constructors, only the no-arg
      one is called.

   Can you pass something in to the super() call? Yes!

   E.g.

   public abstract class Animal {
      private String name;

      public String getName() {
         return name;
      }

      public Animal(String theName) {
         name = theName;
      }
   }

   public class Hippo extends Animal {
      public Hippo(String name ){
         super(name);//it sends the name up the stack to the Animal constructor
      }
   {

   public class MakeHippo {
      public static void main (String[] args) {
         Hippo h = new Hippo("Buffy");
         System.out.println(h.getName());
      }
   }

-  What if you have overloaded constructors that, with the exception of handling different argument types, and do all the same thing? You know that you don't want to
   duplicate code sitting in each of the constructors (pain to maintain, etc.). You can use this() to call a constructor from another overloaded constructor in the same
   class. The call to this() can be used only in a constructor, and must be the first statement in a constructor. Remember, Every constructor can have a call to super()
   or this(), but never both!

   class Mini extends Car {
      Color color;
      
      public Mini() {
         this(Color.Red); //The no-arg constructor supplies a default Color and calls to the overloaded Real Constructor (the one that calls super()).
      }

      public Mini(color c) {
         super("Mini"); //This is the Real Constructor that does the real work of initializing the object (including the call to super()).
         color = c;
         //more initialization
      }

      public Mini(int size) {
         this(Color.Red);
         super(size); //<<- won't work! Can't have super() and this() in the same constructor, because they each must be the first statement!
      }

-  How long does an object live?

   An object's life depends entirely on the life of references referring to it. So how long does a variable live?

   That depends on whether the variable is a local variable or an instance variable. A local variable lives only within the method that declared the variable. An instance
   variable lives as long as the object does. If the object is still alive, so are its instance variables.

   An object becomes eligible for GC(garbage collectable) when its last live reference disappears. Three ways to get rid of an object's reference:

   1) The reference goes out of scope, permanently

      void go() {
         Life z = new Life(); //reference 'z' dies at end of method.
      }

   2) The reference is assigned another object

   Life z = new Life(); //the first object is abandoned when z is 'reprogrammed' to a new object.
   z = new Life(); 

   3) The reference is explicitly set to null

   Life z = new Life(); //the first object is abandoned when z is deprogrammed.
   z = null;

Chapter 10 numbers and statics

-  The difference between regular (non-static) and static methods methods.

   Java is object-oriented, but once in a while you have a special case, typically a utility method (like the Math methods), where there is no need to have an instance of the class.
   
   The keyword "static" lets a method run without any instance of the class. A static method means "behavior not dependent on an instance variable, so no instance/object is required. 
   Just the class."

-  Static methods cannot use non-static (instance) variables.

   public class Duck {
      private int size;
   
      public static void main(String [] args) {
         System.out.println("Size of duck is " + size); //<<---which duck? whose size? if there is Duck on the heap somewhere, we don't know about it.
      }

      public setSize (int s) {
         size = s;
      }

      public int getSize() {
         return size;
      }
   }
   
-  Static methods can't use non-static methods either. E.g.

   public static void main(String [] args) {
      System.out.println("Size of duck is " + getSize()); //whose size?
   }

   Also, if you have a class with only static methods, and you do not want the class to be instanciated, you can mark the constructor private.

-  Static variable: value is the same for all instances of the class

   A value shared by all instances of a class. In other words, one value per class, instead of one value per instance.

   public class Duck {
      private int size;
      private static int duckCount = 0; // The static duckCount variable is initialized ONLY when the class is first loaded, Not each time a new instance is made.
   
   public Duck() {
      duckCount++; //Now it will keep incrementing each time the Duck constructor runs, because duckCount is static and won't be reset to 0. With this static variable, you can
                   //count how many duck instances are being created while your program is running.
   }

   All static variables in a class are initialized before any object of that class can be created. Default values for declared but uninitialized static and instance variables
   are the same:

   primitive integers (long, short, etc...): 0
   primitive floating points (float, double): 0.0
   boolean: false
   object reference: null

   Note: A static method can access a static variable.

-  static final variables are constants

   A variable marked "final" means that - once initialized - it can never change. E.g.

   public static final double PI = 3.141592653589793;

   note: Constants variable names should be in all caps.

   Assigning a value to a final instance variable must be either at the time it is declared, or in the constructor.

   1) At the time you declare it:

   public class Foo {
      public static final int FOO_X = 25;
   }

   or

   2) In a static initializer in the constructor

   public class Bar {
      public static final double BAR_SIGN;
   
      static {

         BAR_SIGN = (double) Math.random();
      }

   }

-  "final" isn't just for static variables...
   
   You can use "final" to modify non-static variables too, including instance variables, local variables and even method parameter.

   A final variable means you can't change its value.

   A final method means you can't override the method.

   A final class means you can't extend the class (i.e. you can't make a subclass).

-  Using "final" immutable, final object with proper equals() and hashcode() implementation would act as perfect Java HashMap keys and
   improve performance of Java HashMap by reducing collision(??). Immutability also allows catching there hashcode of different keys which
   makes overall retrival process very fast.

-  In summary, we should follow the following order of defining a variable:

   [access type][static or not][final or not]type variableName;

   access type could be: private, (default), "public" and "protected".

-  Wrapping a primitive

   In all version of Java prior to 5.0, you cannot put a primitive directly into a collection like AllayList and HashMap:

   To treat a primitive like an object, there is a wrapper class for every primitive type(you don't need to import them as the wrapper classes are in the java.lang package).
   Each wrapper class is named after the primitive type it wraps, but with the first letter capitalized to follow the class naming convention:

   Boolean
   Character
   Byte
   Short
   Integer
   Long
   Float
   Double

   Wrapping a value:

   int i = 288;
   Integer iWrap = new Integer(i);

   Unwrapping a value:

   int unWrapped = iWrap.intValue.

-  Autoboxing: blurring the line between primitive and object.

   The autoboxing feature added to Java 5.0 does the conversion from primitive to wrapper object automatically!

   public void doNumNewWay () {
      ArrayList<Integer> listOfNumbers = new ArrayList<Integer>(); //<---Make an ArrayList of type Integer
      listOfNumbers.add(3); //<---Although there is not a method in ArrayList, for add(int), the compiler does all the wrapping (boxing) for you. In other words, there is an Integer
                            //object stored in the ArrayList, but you get to "pretend" that the ArrayList takes ints.(You can add both ints and Integers to an ArrayList<Integer>).
      int num = listOfNumbers.get(0);//<---the compiler automatically unwraps(unboxes) the Integer object to you can assign the int value directly to 
                                     //a primitive without having to call intValue() method on the Integer object.
   }

   Beside doing wrapping and unwrapping, autobox also lets you use either a primitive or its wrapper type virtually anywhere one or the other is expected.

   1) Method arguments

   void takeNumber(Integer i) {}

   2) Return values

   int giveNumber() {
      return x;
   }

   3) Boolean expressions

   if (bool) {
      System.out.println("true");
   }

   4) Operations on numbers

   Integer i = new Integer(42);
   i++;

   or

   Integer j = new Integer(5);
   Integer k = j + 3;

   5) Assignments

   Double d = x;

   But wait! There's more! Wrappers have static utility methods too!

   6) converting a String to a primitive value is easy:

   String s = "2";
   int x = Integer.parseInt(s); //<---No problem to parse "2" into 2.
   double d = Double.parseDouble("420.24");
   boolean b = new Boolean("true").booleanValue();//<--There is no method called "Boolean.parseBoolean()". Fortunatelly, there is a Boolean constructor that takes (and parses) a String
                                                  //, and then you just get the primitive value by unwrapping it.

   But if you try this:

   String t = "two";
   int y = Integer.parseInt(t); //<---You get runtime error as Anything that can't be parse as a number will cause a Number FormatException.

-  Turning a primitive number into a String.

   There are a couple ways to turn a number into a String.

   1) concatenate the number to an existing String.

   double d = 42.5;
   String doubleString "" + d; //<---The "+" operator is overloaded in Java (the only overloaded operator) as a String concatenator. Anything added to a String becomes Stringified.

   2) Using a static method in class Double.

   double d = 42.5;
   String doubleString = Double.toString(d);

-  Number formatting

   1) Formatting a number to use commas;

   public class TestFormats {
      public static void main (String[] args) {
         String s = String.format("%, d", 1000000000); //<---The formatting instructions for how to format the second argument. Remember, there are only two arguments to this method
                                                       //here - the first comma is inside the string literal, so it isn't seperating arguments to the format method.
      }
   }

   Output:
   
   1,000,000,000

-  Formatting deconstructor...

   format("%, d", 1000000000);

   1) "%, d" ---> Use these instructions;
   2) 1000000000 ---> on this argument(s).

   The percent (%) says, "Insert argument here" (and format it using these instructions).

   When you see the % sign, think of the percent sign as a variable that represents the other argument to the method.

   format("I have %.2f bugs to fix.", 476578.09876);

   %.2f --> The "%" sign tells the formatter to insert the other method argument (the second argument to format(), the number) here, AND format it using the ".2f" character
            after the percent sign. Then the rest of the format String, "bugs to fix", is added to the final output.

   Output:

   I have 476578.10 bugs to fix.

   Adding a comma:

   format(“I have %,.2f bugs to fix.”, 476578.09876);

   Output:

   I have 476,578.10 bugs to fix.

   In summary:

   %,d means "insert commas and format the number as a decimal integer"

   %.2f means "format the number as a floating point with a precision of two decimal places."

   %,.2f means "insert commas and format the number as a floating point with a precision of two decimal places."

-  The format specifier

   A format specifier can have up to five different parts (not including the "%"). Everything in brackets [] below is optional, so only the percent(%) and the type are required.
   But the order is also mandatory, so any parts you Do use must go in this order.

   %[argument number][flags][width][.precision]type

   E.g.

   format(“%,6.1f”, 42.000);
   
   Note; We will talk about [argument number] later.

   1) type

   %d decimal
   %f float
   %x hex
   $c character

   What happens if you have more than one argument:

   int one = 20456654;
   double two = 100567890.248907;
   String s = String.format(“The rank is %,d out of %,.2f”, one, two);

   output:

   The rank is 20,456,654 out of 100,567,890.25.

-  How about dates?

   1) The complete date and type: %tc

   String.format(“%tc”, new Date());

   output:

   Sun Nov 28 14:52:41 MST 2004

   2) Just the time: %tr

   String.format(“%tr”, new Date());

   03:01:47 PM

   3) Day of the week, month and day: %tA %tB %td

   There isn't single format specifier that will do exactly what we want, so we have to combine three of them for day of the week (%tA), month(%tB), and day of the month(%td).

   Same as above, but without duplicating the arguments

   Date today = new Date();
   String.format(“%tA, %<tB %<td”,today); //<---The angle-bracket "<" is just another flag in the specifier that tells the formatter to "Use the previous argument again.", instead
                                          //you format the same argument three different ways.

-  Getting an object that extends Calendar

   How do you get an "instance" of an abstract class?

   This won't work:

   Calendar cal = new Calendar(); //<---it won't work because the constructor Calendar() is a protected method.

   Instead, use the static "getInstance()" method.

   Calendar cal = Calendar.getInstance(); //<---This is not an instance of Calendar as Calendar is an abstract class. This static method returns an instance of a concrete subclass
                                          //. Something that extends Calendar. In most of the world, and by default for most versions of Java, you will be getting back a
                                          //java.util.GregorianCalendar instance.

-  Even more Statics!...static imports.

   New to Java 5.0...The basic idea is that whenever you're using a static class, a static variable, or an enum(more on those later), you can import them, and save yourself some 
   typing. The downside to static imports is that if you are not careful - using them can make your code a lot harder to read.

   Some old-fashioned code:

   import java.lang.Math;
   class NoStatic {
      public static void main(String[] args) {
         System.out.println("sqrt " + Math.sqrt(2.0));
         System.out.println("tan " + Math.tan(2.0));
      }
   }

   Same code with static imports:

   import static java.lang.System.out; //The syntax to use when declaring static imports.
   import static java.lang.Math.*; 

   class WithStatic {
      public static void main(String[] args) {
         out.println("sqrt " + Math.sqrt(2.0));
         out.println("tan " + Math.tan(2.0));
      }
   }

Chapter 11 Risky Behavior

-  Tha JavaSound API

   JavaSound is a collection of classes and interfaces added to Java starting with version 1.3. They are not add-ons but part of the standard J2SE class library.

   1) First, we need a Sequencer

   The sequencer is the object that takes all the MIDI data and sends it to the right instruments. A sequencer can do a lot of different things, but in this book, we
   are using it strictly as a playback device. Like a CD-player on your stereo but with added features.

   import javax.sound.midi.*

   public class MusicTest1 {
      
      public void play() {
         Sequencer sequencer = MidiSystem.getSequencer();

         System.out.println("We got a sequencer");
      } //close play

      public static void main(String[] args) {
         MusicTest mt = new MusicTest1();
         mt.play();
      }
   }

   The code won't compile! The compiler says there's an "unreported exception" that must be caught or declared

   alexyu@alexyu:~/Desktop/study/Java/beatBox$ javac MusicTest1.java 
   MusicTest1.java:6: unreported exception javax.sound.midi.MidiUnavailableException；must be caught or declared to be thrown
            Sequencer sequencer = MidiSystem.getSequencer();

   
   1 errors
   
-  What happens when a method you want to call(probably in a class you didn't write) is risky?

   Methods in Java use exception to tell the calling code, "Something Bad Happened. I failed". This approach is based on you knowing that the method you're calling is risky.
   (e.g. that the method might generate an exception), so that you can write code to deal with that possibility.

   How do you know if a method throws an exception? You find a throws clauses in the risky method's declaration. You can read the Java API to understand under what circumstances, 
   Exceptions can happen.

   If you wrap the risky code in something called a "try/catch", the compiler will relax. A "try/catch" block tells the compiler that you know an exceptional thing could happen
   in the method you're calling, and that you're prepared to handle it. The compiler doesn't care how you handle it; it cares only that you say you're taking care of it.

   import javax.sound.midi.*

      public class MusicTest1 {
         
         public void play() {
         
            try {
            Sequencer sequencer = MidiSystem.getSequencer();
            System.out.println("We got a sequencer");
            
         } catch (MidiUnavailableException ex) {

            System.out.println("Bummer");
            
         }

         public static void main(String[] args) {
            MusicTest mt = new MusicTest1();
            mt.play();
         }
      }

-  An exception is an object...of type Exception.

   Remember from your polymorphism chapters that an object of type Exception can be an instance of any subclass of Exception. Because an Exception is an object, what you catch
   is an object. If the following code, the catch arguments is declared as type Exception, and the parameter reference variable is ex

   try {
      // do risky thing
   } catch (Exception ex) {  //<---This is just like declaring a method argument
      //try to recover   //<---The code only runs if an Exception is thrown.
   }

-  If it is your code that catches the exception, then whose code throw it?

          
            ---------(2)--------
            |                  |
            v                  |
   Your code ---(1)----> class with a risky method 

   1) Call risky method

   When somebody write code that could throw an exception, they must declare the exception.

                              |--------This method MUST tell the world (by declaring) that it throws a BadException
                              v      
   public void takeRisk() throws BadException { 
      if (abadonAllHope) {
         throw new BadException(); //<---Create a new Exception and throw it
      }
      
   }   

   2) throws an exception back

   public void crossFingers() {
      try {
         anObject.takeRisk();
      } catch (BadException ex) {
         System.out.println("Aaargh!");
         ex.printStackTrace(); //<---If you can't recover from the exception, at LEAST get a stack trace using the printStackTrack() method that all exceptions inherit.
      }
   }

-  The compiler checks for everything except RunTimeExceptions.

   Exceptions that are not subclass of RuntimeException are checked for by the compiler. They're called "checked exceptions".

                     Exception
                           |
                           ^
         ----------------------------------------
         |                 |                    |
      IOEXception    InterruptException   RuntimeException (RuntimeExceptions are NOT checked by the compiler. They've known as (big surprise here) "unchecked exceptions")
                                                      |--------------|
                                                      ^              ^
                                           ClassCastException NullPointerException    

   But why RuntimeExceptions the compiler doesn't care about those runtime exceptions? Becasue most RuntimeExceptions come from a problem in your code logic，rather than a
   condition that fails at runtime in ways that you cannot predict or prevent. You cannot guarantee the server is up. You cannot guarantee the server is up. But you can make
   sure you code doesn't index off the end of the array.
   
-  Flow control in try/catch blocks

   try {
      Foo f = x.doRiskyThing();
      int b = f.getNum(); //<---------------------It doRishkyThing() failed, the rest of the try block never runs, which is a good thing as the rest depends on the success of 
                          //the call to doRiskyThing().
   } catch (Exception ex) {
      System.out.println("failed");
   }
   System.out.println("We made it!");

-  Finally: for the things you want to do no matter what.

   A finally block is where you put code that must run regardless of an exception.

   try {
      turnOvenOn();
   } catch (BakingException ex) {
      ex.printStackTrace();
   } finally {
      turnOvenOff();
   }

   Without finally, you have to put the turnOverOff() in both the try and the catch becasue you have to turn off the oven no matter what. A finally block lets you put all
   your important cleanup code in one place instead of duplicating the code.

   Note: 

   If the try block fails (an exception) --> catch block runs ---> finally block runs

   If the try block succeeds -> skip catch block ---> finally block runs

   If the try or catch block has a return statement, finally will still run!

-  A method can throw multiple exceptions

   public class Laundry {
      public void doLaundry() throws PantsException, LingerieException {
      // code that could throw either exception.
      }
   }

   public class Foo {
      public void go() {
         Laundry laundry = new Laundry();
         
         try {
            laundry.doLaundry();
         } catch (PantsException) {
            //recovery code
         } catch (LingerieException) {
            //recovery code
         }
      }
   }

-  Exceptions are polymorphic

   Exceptions are objects that can be thrown. All exceptions have "Exception" as a superclass. Becasue you CAN catch everything with one big super polymorphic catch, doesn't alwasy
   mean you SHOULD.

   try {
      laundry.doLaundry();
   } catch (Exception ex) {
      //recovery code...   //<---Recovery from what? This catch block will catch ANY and all exceptions, so you won't automatically know what went wrong.
   }

   Instead, write a different catch block for each exception that you need to handle uniquely. Multiple catch blocks must be ordered from smallest to biggest
   
                     ClothingException

   PantsException    LingerieException    ShirtException    UniformException
        
                                  TeeShirtException DressShirtException

   try {
      laundry.doLaundry ();
   
   } catch (TeeShirtException tex) {
      //recovery from TeeShirtException
   } catch (LingerieException tex) {
      //recovery from LingerieException
   } catch (ClothingException tex) {
      //recovery from all others
   }

-  When you don't want to handle an exception...Just duck it by clearing it.

-  Exception Rules

   1) You cannot have a catch or finally without a try.
   2) You cannot put code between the try and the catch.
   3) A try MUST be followed by either a catch or a finally.
   4) A try with only a finally (no catch) must still declare the exception.

-  Making actual sound

   1) The thing that plays the music;
   2) The music to be played...a song;
   3) The part of the Sequence that holds the actual information;
   4) The actual music information; note to play, how long, etc...

   
                  plays                         has                  holds
   Sequencer   ----------->   Sequence    -------------> Track    -------------->   MidiEvents...

   Note: A MIDI event is a message that the Sequencer can understand such as play Middle C, play this fast and play this hard...

-  Making a MidiEvent (song data)

   Skip it for now.

Chapter 12 A very Graphic story

-  Skip it for now

Chapter 13 Work on your Swing

-  Skip it for now

Chapter 14 Saving Objects

-  Skip it for now

Chapter 15 Making a connection

-  Skip it for now

Chapter 16 Data Structure

-  ArrayList has a lot of methods, but there is nothing can do sorting. ArrayList is not the only collection. Some of the key collection classes are:

   -  TreeSet

      Keeps the elements sorted and prevents duplicates.

   -  HashMap

      Let's you store and access elements as name/value pairs.

   -  LinkedList

      Designed to give better performance when you insert or delete elements from the middle of the collection.

   -  HashSet

      Prevents duplicates in the collection, and given an element, can find that element in the collection quickly.

   -  LinkedHashMap

      Like a regular HashMap except it can remember then order in which elements (name/value pairs) were inserted, or it can be configured to remember the order in which elements
      were last accessed.
      
-  You could use a TreeSet...or you could use the Collections.sort() method.

   TreeSet: If you put all the strings into a TreeSet instead of an ArrayList, the Strings would automatically land in the right place, alphbetically sorted. There is a trade-off:
   every time you insert into a TreeSet, the TreeSet has to take time to figure out where in the tree the new element must go.

   Collection.sort(): The Collection.sort() method sorts a list of Strings alphabetically. E.g.

   import java.util.*;
   import java.io.*;

   public class Jukebox1 {

      ArrayList <String> songList = new ArrayList<String>();

      public static void main(String[] args) {
         new Jukebox1().go();
      }
   
      public void go() {
         getSongs();
         System.out.println(songList);
         Collection.sort(songList); //<---Call the static Collections sort() method.
         System.out.println(songList);
      }

   ...
   }

-  But if you need Song objects not just simple Strings to store in the list?

   class Song {
      String title;
      String artist;
      String rating;
      String bpm;
   }

   Thus we need to change thd code a littie bit:

   ...
   public class Jukebox3 {
      ArrayList<Song> songList = new ArrayList<Song>();
   }

   Unfortunatelly, it won't compile

   symbol : method sort(java.util.ArrayList<Song>)
   location: class java.util.Collections
                     Collections.sort(songList);
                                ^

   1 error

-  Generic

   From the Java API docs:

   public static <T extends Comparable<? super T>> void sort(List<T> list)

   Why the definition of sort is so strange...this is because the sort() method (along with other things in the whole collection framework in Java) makes heavy use of generics.
   Anytime you see something with angle brackets in Java source code or documentations, it means generics - a feature added to Java 5.0.

   Generics means more type-safety. The main point of generics is to let you write type-safe collections. In other words, code that makes the compiler stop you from putting a Dog
   into a list of Ducks.

   Without generics:

   Objects go IN as a reference of type of Object and OUT as a reference to type of Object.

   With generics:

   Objects go IN as a reference to only Fish (for example) objects

   ArrayList<Fish>
   
   and come OUT as a reference of type Fish. With Generics now, you can put only Fish Objects in the ArrayList<FISH>, so the objects come out as  Fish references.

   Of the dozens of things you could learn about generics, there are really three things that matter to most programmers:

   1) Creating instances of generified classes (like ArrayList)

   You have to tell the type of objects you'll allow in the list, just as you do with plain old arrays. 

   new ArrayList<Song>();

   2) Declaring and assigning variables of generic types

   List<Song> songList = new ArrayList<Song>();

   3) Declaring (and involking) methods that take generic types

   void foo(List<Song> list) 
      
   x.foo(songList)

   void foo(List<Song> list)
   
   x.foo(songList)

-  Using generic CLASSES

   A generic class: it means that the class declaration includes a type parameter.

   A generic method: it means that the method declaration uses a type parameter in its signature.

   You can use type parameters in a method in several different ways:

   1) Using a type parameter defined in the class declaration

   public class ArrayList<E> extends AbstractList<E> ... {
      public boolean add (E o) //<-- You can use the "E" here ONLY because it's already been defined as part of the class.
   }

   The type declared in the method argument is essentially replaced with the type you use when you instantiate the class.

   2) Using a type parameter that was NOT defined in the class declaration

   public <T extends Animal> void takeThing(ArrayList<T> list)

   If the class itself doesn't use a type parameter, you can still specify one for a method, by declaring it in a really unusual (but available) space - before the return type.
   This method says that T can be "any type of Animal".

-  Revisiting the sort() method

   The sort() method can take only lists of Comparable objects.

   Song is not a subtype Comparable, so you cannot use sort() the list of Songs.

   public static <T extends Comparable<? super T>> void sort(List<T> list)   
                           |                |                     |
                           |                |                     |---------> You can only pass in only a List(or subtype of List, like ArrayList that uses parameterized type that
                           |                |                                 ("extends Comparable" )
                           |                |
                           |                |-----> it means the type parameter for Comparable must be of type T or one of T's supertypes(??).
                           |
                           |
                           -----> This says "Whatever" 'T' is must be of type Comparable

   Note: "super" in Generics is the opposite of "extends". Instead of saying the comparable's generic type has to be a subclass of T, it is saying it has to be a superclass
   of T. This is important because extends tells you what you can get out of a class(you get at least this, perhaps a subclass). super tells you what you can put into 
   the class(at most this, perhaps a superclass).

   But the docs for String say String doesn't EXTEND Comparable -- it IMPLEMENTS it. Comparable is an interface. So it's nonsense to say <T extends Comparable>:

   public final class String extends Object implements Serializable, Comparable<String>, CharSequence

   In generics, "extends" means "extends or implements".

-  Here is the detail of the Comparable interface

   java.lang.Comparable

   public interface Comparable<T> {
      int compareTo(T o);
   }

   There is only one method to implement and it is called compareTo:

   Returns:

   Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than 
   the specified object.

   Your job now is to implement compareTo for the class Song to decide what mekes one song greater than another.

   Thus we have the new, comparable Song class:

   class Song implements Comparable<Song> {
      String title;
      String artist;
      String rating;
      String bpm;
   
      public int compareTo(Song s) {
         return title.compareTo(s.getTitle()); //<---Very simple!
      }

-  There's new problem - if you want two different views of the song list, one by song title and one by artist.

   There is another sort() method in the Class Collections.

   public static <T> void sort(List<T> list, Comparator<? super T> c)

-  using a custom Comparator

   An element in a list can compare itself to another of its own type in only one way, using its compareTo() method. But a Comparator is external to the element type you're comparing
   - it's a seperate class. You can make as many of these as you like! E.g. ArtistComparator, BPMComparator...

   The sort() method that takes a Comparator will use the Comparator instead of the element's own compareTo()method, when it puts the elements in order. In other words, if your sort()
   method gets a Comparator, it won't even call the compareTo method of the elements in the list. The sort() method will instead invoke the compare() method on the Comparator.

-  Updating the Jukebox to use a Comparator

   ...
   public class JukeBox5 {
      ArrayList<Song> songList = new ArrayList<Song>();
      public static void main(String[] args) {
         new Jukebox5.go();
      }

      class ArtistCompare implements Comparator<Song> {
         public int compare(Song one, Song two) {
            return one.getArtist().compareTo(two.getArtist());//<--We're letting the String variable (for artist do the actual comparision, since Strings already know how to 
                                                              //alphbetize themselves)
         }

      public void go() {
         getSongs();
         System.out.println(songList);
         Collections.sort(songList);
         System.out.println(songList);

         ArtistCompare artistCompare = new ArtistCompare(); //<---Make an instance of the Comparator inner class
         Collections.sort(songList, artistCompare); //<---Invoke sort(), passing it the list and a reference to the new custom Comparator object.
         ...
      }
   }

-  We can use "Set" instead of "List" to resolve the dublicate elements stored in a list.

   1) LIST

   Collections that know about index position. Lists know where something is in the list. You can have more than one element referencing the same object.

   2) SET

   collections that do not allow duplicates. Sets know whether something is already in the collection. You can never have more than one element referencing
   the same object (or more than one element referencing two objects that are considered equal—we’ll look at what object equality means in a moment).

   3）MAP

   When finding something by key matters

   Collections that use key-value pairs. Maps know the value associated with a given key. You can have two keys that reference the same value, but you cannot have
   dublicate keys. Although keys are typically String names (so that you can make name/value property lists, for example), a key can be any object.

-  Using a HashSet instead of ArrayList.

   ...public void go() {
      getSongs();
      System.out.println(songList);
      Collections.sort(songList);
      System.out.println(songList);

      HashSet<Song> songSet = new HashSet<Song>();
      songSet.addAll(songList);//<---HashSet has a simple addAll() method that can take another collection and use it to populate the HashSet. It is the same as if we
                               //added each some one at a time(except much simpler).
      System.out.println(songList);
   }  

   But there are still duplicate elements in above method using HashSet. Why?

-  What makes two objects equal?

   This brings up a key issue: reference equality vs. object equality.

   1) Reference equality

   Two references, one object on the heap

   Two references that refer to the same object on the heap are equal. If you call hashCode() method on both references you will get the same result.

   2) Object equality

   Two references, two objects on the heap, but the objects are considered meaningfully equilvalent.

   If you want to treat two different Song objects as equal (for example if you needed that two songs are the same if you they have matching title variables), you must
   override both the hashCode() and equals() methods inherited from class Object.

   If you don't override hashCode(), the default behavior (from Object ) is to give each object a unique hashcode value. Also, you must override equals() so that if you call
   it on either object, passing in the other object, always return true. 

   if (foo.equals(bar) && foo.hashCode() == bar.hashCode()) {
      //both references are referring to either a single object, or to two objects that are equal.
   }

-  The Song class with overridden

   class Song implements Comparable<Song>{
      String title;
      String artist;
      String rating;
      String bpm;

      public boolean equals(Object aSong) { 
         Song s = (Song) aSong;
         return getTitle().equals(s.getTitle()); //<---The great news is that title is a String, and Strings have an overriden equals() method. So all we have to do is to ask
                                                 // one title if it's equal to the other song's title.
      }

      public int hashCode() {
         return title.hashCode(); //<---Same deal here...the String class has an overriden hashCode method, so you can just return the result of calling hashCode() on the title.
                                  //Notice how hashCode() and equals() are using the SAME instance variable.
      }

      Java Object Law For HashCode() and equals()

      The API docs for class Object state the rules you MUST follow:

      1) If two objects are equal, they MUST have matching hashcodes.

      2) If two objects are equal, calling equals on either object MUST return true. In other words, if (a.equals(b)) then (b.equals(a)).

      3) If two objects have the same hashcode value, they are NOT required to be equal. But if they're equal, they MUST have the same hashcode value.

      4) So, if you override equals(), you MUST override hashCode().

      5) The default behavior of hashCode() is to generate a unique integer for each object on the heap. So if you don't override hashCode() in a class, no two objects of that type
         can EVER be considered equal.

      6) The default behavior of equals() is do do an == comparision. In other words, to test whether the two references refer to a single object on the heap. So if you don't override
         equals() in a class, no two objects can EVER be considered equal since references to two different objects will always contain a different bit pattern.

      7) a.equals(b) must also mean that a.hashCode() == b.hashCode().
      
      8) But a.hashCode() == b.hashCode() does NOT have to mean a.equals(b). (??)

-  And if we want the set to stay sorted, we've got TreeSet.

   TreeSet is similar to Hashset but it also keeps the list sorted.

   public void go() {
      getSong();
      System.out.println(songList);
      Collections.sort(songList);
      System.out.println(songList);

      TreeSet<Song> songSet = new TreeSet<Song>();
      songSet.addAll(songList);//<---Calling the addAll method.
      System.out.println(songList);
   }

   import java.util.*;

   public class TestTree {
      public static void main(String[] args) {
         new TestTree().go();
      }

      public void go() {
         Book b1 = new Book("How Cats Work");
         Book b2 = new Book("Remix your Body");
         Book b3 = new Book("Finding Emo");

         TreeSet<Book> tree = new TreeSet<Book>();
         tree.add(b1);
         tree.add(b2);
         tree.add(b3);
         System.out.println(tree);
      }
   }

   class Book implements Comparable<Book>{
      String title;
      public Book(String t) {
         title = t;
      }

      public int compareTo(Book b) {
         return title.compareTo(b.title);
      }
   }

   The above program won't compile! It is simply becasue the elements in the list must be of a type that implements Comparable. 

   class Book implements Comparable {
      String title;
      public Book(String t) {
         title = t;
      }
      
      public int compareTo(Object b) {
         Book book = (Book) b;
         return (title.compareTo(book.title));
      }
   }
   
   Or you use the TreeSet's overloaded constructor that takes a Comparator:

   public class BookCompare implements Comparetor<Book> {
      public int compare(Book one, Book two) {
         return (one.title.compareTo(two.title));
      }
   }

   class Test {
      public void go() {
         Book b1 = new Book("How Cats Work");
         Book b2 = new Book("Remix your Body");
         Book b3 = new Book("Finding Emo");
         BookCompare bCompare = new BookCompare();//Create a new BookCompare instance
         TreeSet<Book> tree = new TreeSet<Book>(bCompare);
         tree.add(new Book("How Cats Work"));
         tree.add(new Book("Remix your Body"));
         tree.add(new Book("Finding Emo"));
         System.out.println(tree);
      }  
   }

-  We've seen Lists and Sets, now we'll use a Map.

   Sometimes a Map is the best. Each element in a Map is actually TWO objects - a key and a value. You can have dulpicate values, but NOT duplicate keys.

-  Finally, back to generics.

   If you declare a method to take ArrayList<Animal> it can take ONLY an ArrayList<Animal>, not ArrayList<Dog> or ArrayList<Cat>.

   But why that doesn't happen in Array?

   Because Array types are checked again at runtime, but collection type checks happen only wheny when you compile. You will get store exception when you add a new dog object 
   into a Animal array.

-  Widecards to the rescue

   It looks unusual, but there is a way to create a method argument that can accept an ArrayList of any Animal subtype. The simplest way is to use a widecard - The
   simplest way is to use a widecard. 

   public void takeAnimals(ArrayList<? extends Animal> animals) { //<---the keyword "extends" here means either extends OR implements depending on the type. So if you want to tak
      for (Animal a : animals) {                                  //an ArrayList of types that implement the Pet interface, you'd declare it as ArrayList<? extends Pet>
         a.eat();
      }
   }

   When you use a widecard in your method argument, the compiler will STOP you from doing anything that could hurt the list referenced by the method parameter.

   You still can invoke methods on the elements in the list, but you cannot add elements to the list. In other words, you can do things with the list elements, but you can't 
   put new things in the list. So you're safe at runtime, because the compiler won't let you do anything that might be horrible at runtime.

   So this is OK inside takeAnimals();

   for (Animal a: animals) {
      a.eat();
   }

   But This would not compile:

   animals.add(new Cat());

-  Alternative syntax for doing the same thing:

   The type parameter can also be declared before the return type. The results are the same.

   This:

   public <T extends Animal> void takeThing(ArrayList <T> list)

   Does the same thing as this:

   public void takeThing(ArrayList<? extends Animal> list)

   If they both do the same thing, why would you use one over the other?

   It is all depends on whether you want to use "T" some-where else. For example, what if you want the method to have two arguments - both of which are lists of a type
   that extend Animal? In this case, it's more efficient to just declare the type parameter once:

   public <T extends Animal> void takeThing(ArrayList<T> one, ArrayList<T> two)

   instead of typing:

   public void takeThing(ArrayList<? extends Animal> one, ArrayList<? extends Animal> two)

Chapter 17 Release Code

-  Skip it for now

Chapter 18 Distriburted Computing

-  Methods are always between two objects on the same heap. What if you want to invoke a method on an object running on another machine?

-  You want to cause a method invocation on a remote object (i.e. an object in a heap somewhere else.) but with code that lets
   you pretend that you are invoking a method on a local object. That's what RMI (Remote Method Invocation) gives you!

-  A design for remote methdo calls:

   Create four things: server, client, server helper, client helper

   1) The server app is the remote service that has an object with the method that the client wants to invoke.

   2) The client/server 'helpers'. They will handle all the low-level networking and I/O details so your client and service
      can pretend like they're in the same heap.

-  The role of the 'helpers'

   The client calls a method on the client helper, as if the client helper were the actual service. The client helper is a proxy
   for the Real Thing.

Chapter 19 Concurrency

-  Each thread is associated with an instance of the class Thread. There are two basic strategies for using Thread objects to create a concurrent application.

   -  To directly control thread creation and management, simply instantiate Thread each time the application needs to initiate an asynchronous task.
   -  To abstract thread management from the rest of your application, pass the application's tasks to an executor.

-  An application that creates an instance of Thread must provide the code that will run in that thread. Two ways to do this:

   1) Provide a Runnable object. The Runnable interface defines a single method, run, meant to contain the code executed in the thread. The Runnable object is passed to
      the Thread constructor. (A more general method because the Runnable object can subclass a class other than Thread)

      E.g. 

      class HelloRunnable implements Runnable {
         public void run() {
            System.out.println("Hello from a thread!");
         }

         public static void main(String[] args) {
            (new Thread(new HelloRunnable())).start();//start a new thread using a Runnable Object by calling start();
         }
      }


   2) The subclass thread itself implements Runnable, though its run method does nothing. An application can subclass Thread, providing its own implementation of run, as in
      the HelloThread example: (easier to use but your class is limited by the fact that your task must be a descendant of Thread).

      E.g.
   
      class HelloThread extends Thread {
         public void run() {
            System.out.println("Hello from a thread!");
         }

         public static void main(String[] args) {
            (new HelloThread()).start();//start a new thread on a Thread subclass object
         }
      }

-  The Interrupted Status Flag


   The interrupt mechanism is implemented using an internal flag known as the interrupt status. Involking Thread.interrupt sets this flag. E.g.

      if (Thread.interrupted()) {
         throw new InterruptedException();
      }

   When a thread checks for an interrupt by involking the static method Thread.interrupted, interrupt status is cleared. The non-static isInterrupted method, which is used
   by one thread to query the interrupt status of another, does not change the interrupt status flag.

   By convention, any method that exists by throwing an InterruptedException clears interrupt status when it does so. However, it is always possible that interrupt status will
   immediatedly be set again, by another thread invoking interrupt.

-  Joins

   The Join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing,

   t.join();

   causes the current thread to pause execution until t's thread terminates. Like sleep, join responds to an interrupt by exiting with an InterruptedException.

-  Some other thread methods:

   t.isAlive() ---> check if t is still alive
   t.interrupt() ---> send an InterruptedException to thread t
   t.start() ---> start the thread
   t.interrupted() ----> Check if thread t has been interrupted
   t.join() ----> cause the current thread to pause execution until t's thread terminates.

-  Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient,  but makes 
   two kinds of errors possible: thread interface and memory consistency errors. The tool needed to prevent these errors is synchronization.

   1) Thread Interference: It happens when two operations, running in different threads, but acting on the same data, interleave. This means that two operations consist of multiple
                           steps, and the sequences of steps overlap. E.g.

   Thread A: Retrieve c.
   Thread B: Retrieve c.
   Thread A: Increment retrieved value; result is 1.
   Thread B: Decrement retrieved value; result is -1.
   Thread A: Store result in c; c is now 1.
   Thread B: Store result in c; c is now -1.    

   2) Memory Consistency Errors: It occurs when different threads have inconsistent views of what should be the same data. 

   int counter = 0;

   Thread A: counter++;
   Thread B: System.out.println(counter);

   the output might be 0 or 1, depending on A finishes first or B finishes first.

-  Two Synchronized methods:

   1) Synchronized methods;

   To make a method synchronized, simply add the synchronized keyword to its declaration:

   -  First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method 
   for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object. 

   -  Second, when a synchronized method exits, it automatically establishes a happen-before relationship with any subsequent invocation of a synchronized method
      exits, it automatically establishes a happen-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees
      that changes to the state of the object are visialbe to all threads.

      instance.add(this);

      Warning: When constructing an object that will be shared between threads, be very careful that a reference to that object does not "leak" prematurely. For example,
      suppose you want to maintain a List called instances containing every instance of class. You might be tempted to add the following line to your constructor:

      Note: final fields, which cannot be modified after the object is constructed, can be safely read through non-synchronized methods, once the object is constructed.

      Synchronization is built around an internal entity known as the intrisic lock or monitor lock. As long as a thread owns an intrinsic lock, no other thread can acquire 
      the same lock. The other thread will block when it attempts to acquire the lock until it is released by that thread.

      What happens when a static synchronized method is invoked? Since a static method is associated with a class, not an object. In this case, the thread acquires the 
      intrinsic lock for the Class object associated with the class. Thus access to class's static fields is controlled by a lock that's distinct from the lock for any 
      instance of the class.


   2) Synchronized statements

   -  Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:

      public void addName(String name) {
         synchronized(this) {
            lastName = name;
            nameCount++;
         }
         nameList.add(name);
      }

      The above example needs to synchronize changes to lastName and nameCount, but also needs to avoid synchronizing invocations of other object's methods(the Liveness problem).
      Without synchronized statements, there would have to be a seperate, unsynchronized method for the sole purpose of involking nameList.add(??).

      Synchronized statements are also useful for improving concurrency with fine-grained synchronization. E,g,

      public class MsLunch {
         private long c1 = 0;
         private long c2 = 0;
         private Object lock1 = new Object();
         private Object lock2 = new Object();

         public void inc1() {
            synchronized(lock1);
            c1++;
         }

         public void inc2() {
            synchronized(lock2);
            c2++;
         }
      }

      Since c1 and c2 will never be used together, there is no reason to prevent an update of c1 from being interleaved with an update of c2 - and doing so reduces concurrency
      by creating unnecessary blocking. Instead of using synchronized methods or otherwise using the lock associated with this, we create two objects solely to provide locks.

-  Reentrant Synchronization

   Allowing a thread to acquire the same lock more than once enables reentrant synchronization.

-  Atomic Access

   In programming, an atomic access is one that effectively happens all at once. An atomic action cannot stop in the middle; it either happens completely, or it doesn't 
   happen at all. No side effects of an atomic action are visible until the action is complete.

   - Reads and writes are atomic for reference variables and for most primitive variables (all types except long and double).
   - Reads and writes are atomic for all variables declared volatile (including long and double variables).

   Atomic actions cannot be interleaved, so they can be used without fear of thread interference. However, this does not eliminate all need to synchronize atomic actions, 
   because memory consistency errors are still possible. Using volatile variables reduces the risk of memory consistency errors, because any write to a volatile variable 
   establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a volatile variable are always visible to other threads. 
   What's more, it also means that when a thread reads a volatile variable, it sees not just the latest change to the volatile, but also the side effects of the code that 
   led up the change.

   Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory 
   consistency errors. Whether the extra effort is worthwhile depends on the size and complexity of the application.

-  Liveness

   A concurrent application's ability to execute in a timely manner is known as its liveness. 

   -  Deadlock: a situation where two or more threads are blocked forever, waiting for each other.

   -  Starvation: a situation where a thread is unable to gain regular access to shared resources and is unable to make progress.

   -  Livelock:   A thread often acts in response to the action of another thread. If the other thread action is also response to the action of another thread, 
                  then livelock may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked — 
                  they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: 
                  Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, 
                  Alphone moves to his right, while Gaston moves to his left. They're still blocking each other, so...

-  Guarded Blocks

   public void guardedJoy() {
      //Simple loop guard. Wastes
      //processor time. don't do this!
      while(!joy) {}
      System.out.println("Joy has been achieved!");
   }

   A more efficient way is to invoke Object.wait to suspend the current thread. The invocation of wait does not return until another thread has issued a notification
   that some special event may have occured ----though not necessarily the event this thread is waiting for:

   public synchronized guardedJoy() {
       // This guard only loops once for each special event, which may not
       // be the event we're waiting for.
       while(!joy) {
           try {
               wait();
           } catch (InterruptedException e) {}
       }
       System.out.println("Joy and efficiency have been achieved!");
   }

   Note: Don't assume that the interrupt was for the particular care about the value of joy.

   How that works? When wait is invoked, the thread releases the lock and suspends execution. At some future time, another thread will acquire the same lock and invoke
   Object.notifyAll(??), informing all threads waiting on that lock that something important has happened.

   public synchronized notifyJoy() {
      joy = true;
      notifyAll();
   }

   Some time after the second thread has released the lock, the first thread reacquires the lock and resumes by returning from the invocation of wait.

-  Immutable Objects

   An object is considered immutable if its state cannot change after it is constructed. Maximum reliance on immutable objects is widely accpted as a sound strategy for creating
   simple, reliable code. 

   Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in 
   an inconsistent state.

   Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place. The 
   impact of object creation is often overestimated, and can be offset by some of the efficiencies associated with immutable objects. These include decreased overhead due 
   to garbage collection, and the elimination of code needed to protect mutable objects from corruption.

   The following rules define a simple strategy for creating immutable objects. Not all classes documented as "immutable" follow these rules. This does not necessarily mean
   the creators of these classes are sloppy(??) - they may have good reason for believing that instances of their classes never change after construction. However, such
   strategies require sophisticated analysis are not for beginners.

   1. Don't provide "setter" methods — methods that modify fields or objects referred to by fields.
   2. Make all fields final and private.
   3. Don't allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor 
      private and construct instances in factory methods.
   4. If the instance fields include references to mutable objects, don't allow those objects to be changed: Don't provide methods that modify the mutable objects.
      Don't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and 
      store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.

   Applying this strategy to SynchronizedRGB results in the following steps:

   1. There are two setter methods in this class. The first one, set, arbitrarily transforms the object, and has no place in an immutable version of the class. 
      The second one, invert, can be adapted by having it create a new object instead of modifying the existing one.
   2. All fields are already private; they are further qualified as final.
   3. The class itself is declared final.
   4. Only one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of "contained" mutable objects
      are necessary.
         

   

   


Questions

1) Is it ture that the name of a public class must be the same as the file name?

2) What is an iterator/

   An iterator enables you cycle through a collection, obtaining or removing elements. Listiterator extends iterator to allow bidirectional traversal of a list, and the modification
   of elements. In general, to use an iterator to cycle through the contents of a collection, follow these steps:

   -  Obtain an iterator to the start of the collection by calling the collections's iterator() method. 

   -  Set up a loop that makes a call to hasNext(). Have the loop iterate as long as hashNext() returns true.

   -  Within the loop, obtain each element by calling next().

3) What is "<? super T>" mean?

   public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        int srcSize = src.size();
        if (srcSize > dest.size())
            throw new IndexOutOfBoundsException("Source does not fit in dest");

        if (srcSize < COPY_THRESHOLD ||
            (src instanceof RandomAccess && dest instanceof RandomAccess)) {
            for (int i=0; i<srcSize; i++)
                dest.set(i, src.get(i));
        } else {
            ListIterator<? super T> di=dest.listIterator();
            ListIterator<? extends T> si=src.listIterator();
            for (int i=0; i<srcSize; i++) {
                di.next();
                di.set(si.next());
            }
        }
    }

Answer: It is "generics". <? super T> dest must be the type of class T or the super class of T. <? extends T> means src must be the type of class T or T's sub-class.

4) We can create a container class for a pair of value. E.g.

   /** Container class for a key-value pair */

   class KVpair<Key, E> {
     private Key k;
     private E e;

     /** Constructors */
     KVpair()
       { k = null; e = null; }
     KVpair(Key kval, E eval)
       { k = kval; e = eval; }

     /** Data member access functions */
     public Key key() { return k; }
     public E value() { return e; }
   }

   Note: <Key, E> is the key-value pair value that implementing the "generics" feature.

5) What is that comment used for in Java?

   /**  */

6) Why I cannot create generics arrays. E.g.

   BSTNode<Integer>[] nodes = new BSTNode<Integer>[11];

   Answer: Generics and arrays don't mix. Basically, the short answer is that you can work around this problem. The longer answer is that you probably shouldn't. Here is the explanation
   of why?

   Arrays are covariant. That means they retain the type of their elements at runtime. Java's generics are not. They use type erasure to basically mask the implicit casting that 
   is going
   on. It's important to understand that.

   The following example is perfectly legal:

   List<String> list = new ArrayList<String>();
   List<Integer> list2 = new (List<Integer>)list;
   list.add(3);

   It is also why you can't do this:

   public <T> T newInstance(T t) {
      return new T();
   }

   ie at runtime, there is no knowledge of T's class. This is why the above code is more often written as:\

   public <T> T newInstance(T t, Class<T> clazz) {
      return clazz.newInstance();
   }

   because there is no runtime type for the generics argument. But with arrays:

   String arr[] = new String[10];
   Integer arr2[] = (Integer[])arr; //error

   What you should be doing in this case (imho) is not using arrays but using an ArrayList. In all honesty, there is very little reason to use arrays over an ArrayList and generics
   is just one example of that.

7) If you see the following error while running a java compiled program: (resolved)

   Exception in thread "main" java.lang.UnsupportedClassVersionError: BinTree : Unsupported major.minor version 51.0
      at java.lang.ClassLoader.defineClass1(Native Method)
      at java.lang.ClassLoader.defineClass(ClassLoader.java:634)
      at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
      at java.net.URLClassLoader.defineClass(URLClassLoader.java:277)
      at java.net.URLClassLoader.access$000(URLClassLoader.java:73)
      at java.net.URLClassLoader$1.run(URLClassLoader.java:212)
      at java.security.AccessController.doPrivileged(Native Method)
      at java.net.URLClassLoader.findClass(URLClassLoader.java:205)
      at java.lang.ClassLoader.loadClass(ClassLoader.java:321)
      at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:294)
      at java.lang.ClassLoader.loadClass(ClassLoader.java:266)
   Could not find the main class: BinTree. Program will exit.

   That means you have are using classes compiled with different versions of java.
   
8) How can I resolve this issue?

   BinTree.java:285: warning: [unchecked] unchecked call to setRight(BinNode<E>) as a member of the raw type BinNode
         u.parent().setRight(v); 

9) The assertion in Java (resolved)

   Two forms of assertions in Java:

   1) assert Expression1;

   E.g.  assert a>0;

   2) assert Expression1 : Expression2 where Expression1 is a boolean expression; Expression2 is an expression that has a value. Use this version of the assert statement
   to provide a detail message for AssertionError. The system passes the value of Expression2 to the appropriate AssertionError constructor, which uses the string representation
   of the value as the error's detail message.

10) How can I create generics array in Java:

   No, you can't! It is because Java's arrays (unlike generics) contain, at runtime, information about its component type. So you must know the component type when you create
   the array. Since you don't know what T is at runtime, you cannot create the array. 

11) One can use enum in Java. E.g.

   public enum Color {
      WHITE, GRAY, BLACK;
   }

12) Why we can assign a LinkedList Object to a Queue reference?

   Queue<String> q = new LinkedList<String>();

   The class "LinkedList" implements the interface "Queue". Is it the same as polymorphism between a class and its subclasses?

13) How can I resolve this issue?

   warning: [unchecked] unchecked conversion 

14) Assuming there is a private memeber, which is a linkedlist in a class

      class A {
         private LinkedList llist;
      }

      If in main, we define a variable to store the llist

      LinkedList l = a.getList;
      l.removeLast();

      I can use l to remove element in a.llist?? by isn't llist a private variable?

15) Hash Map

   The Map interface that maps unique keys to value means it associate value to unique keys which you use to retrieve value at a later date. Some of they key points are:

   -  Using a key and a value, you can store the value in Map object. You can retrieve it later by using it's key.
   -  When no element exists in the involking Map, many methods throw a 'NoSuchElementException'
   -  A ClassCastException is thrown when an object is incompatible with the elements in a map.
   -  An UnsupportedOperation is thrown when an attempt is made to change an unmodified map.

16) Why always override hashcode() method if overriding equals().

   The default implementation of the equals() just simply compares the memory addresses of the objects. If you override the
   equals(), you MUST also override hashCode(). Otherwise, a violation of the general contract for Object.hashCode will occur.
   which can have unexpected repercussions when your class is in conjunction with all hash-based collections.

   public int hashCode():

   Return a hash code value for the object. This method is supported for the benefit of hashtables such as those provided by
   java.util.Hashtable. The general contract oif hashCode is:

   -  Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method
      must consistently return the same integer, provide no info in equals comparision on the object is modified. The interger
      need not remain consistent from one application to another execution of the same application.

   -  If two objects are equal according to the equals(Objct) method, then calling the hashCode method on each of the two 
      objects must produce the same integer result.

   -  It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the 
      hashCode method on each of the two objects must produce distinct integer results. However, the progrmmer should be
      aware that producing distinct integer results for unequal objects may improve the performance of hashtables.
   
      The hashCode method defined by Object does not return distinct integers for distinct objects(This is typically implemented
      by converting the internal address of the object into an integer, but this implementation technique is not required by
      Java programming language). 

      The default implementation of equals() method checks to see if the two objects have the same identity. Similarly, 
      the default implementation of the hashCode() method returns an integer based on the object's identity and is not 
      based on the values of instance (and class) variables of the object. No matter how many times the values of its 
      instance variables (data fields) change, the hash code calculated by the default hashCode implementation does not 
      change during the life of the object.

17) What are immutable objects(!!):

   Immutable objects are simply objects whose state (the object's data) cannot change after construction. Examples of immutable objects from the JDK
   include String and Integer. Immutable objects greatly simpilify your program. Since they are:

   -  are simple to construct, test, and use.
   -  are automatically thread-safe and have no synchronization issues
   -  do not need a copy constructor(??)
   -  do not need an implementation of clone
   -  allow hashCode to use lazy initialization, and to catch its return value(??)
   -  do not need to be copied defensively when used as a field(??)
   -  make good map keys and Set elements (these objects must not change state while in the collection)
   -  have their class invariant established once upon construction, and it never needs to be checked again.

   Immutable objects have a very compelling list of positive qualities. Without question, they are among the simplest and most robust kinds of classes you 
   can possibly build. When you create immutable classes, entire categories of problems simply disappear.

   Make a class immutable by following these guidelines:

   -  Ensure the class cannot be overriden - make the class final, or use static factories and keep constructors private
   -  make fields private and final
   -  force callers to construct an object completely in a single step, instead of using a no-argument constructor combined with subsequent calls to
      setXXX methods (that is, avoid the Java Beans convention)   
   -  do not provide any methods which can change the state of the object in any way - not just setXXX methods, but any method which can change state.
   -  If the class has any mutable object fields, then they must be defensively copied when passed between the class and its caller.

   In Effective Java, Joshua Bloch makes this compelling recommendation:

   "Classes should be immutable unless there is a very good reason to make them mutable...If a class cannot be made immutable, limit its mutability as much as 
   possible." 

18)  An Interesting way of thread creation.

      new Thread(new Runnable() {
         public void run() {alphonse,bow(gaston); }
      }).start();

19) How to read number from System input stream:

   import java.util.Scanner;

   //...

   Scanner in = new Scanner(System.in);
   int num = in.nextInt();
