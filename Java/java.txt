Chapter 1 

-  In Java, everything goes in class. You'll type your source code file (with java extension), then compile it into a new class file (with a .class extension). When you run your program, you're really running a class.

-  Running a program means telling the Java Virtual Machine to "Load the Hello class then start executing its main()".

Chapter 2 Objects and Classes

-  A class is a blueprint for an object(or instance).

-  Things that an object can do are called methods.

-  As long you're in main(), you are not really in Objectville. It's fine for a test program to run within the main method. But in true OO application, you need objects talling
   to other objects, as opposed to a static main() method creating and testing objects.

-  A real Java application is nothing but objects talking to other objects. In this case, talking means objects calling methods of on one another.

-  Java takes out the garbage:

   Each time an object is created in Java, it goes into an area of memory known The Heap. The Java Heap, which is not like the heap memory in C/C++, is actually a Garbage-Collection
   Heap. When JVM can 'see' that an object can never be used again, that object becomes eligible collection.

-  It would be a big pain to deliver a huge bunch of individual files to your end-users but you won't have to. You can put all of your application files into Java Archive - a .jar file
   that is based on the pkzip format. In the jar file, you can include a simple text file formatted as something called a manifest, that defines which class in that jar holds the main()
   method that should run.

-  A class can inherit instance variables and methods from a more abstract superclass.

Chapter 3  Primitives and References.

-  A primitive variable (int, float...) is full of bits representing the actual value of the variable, an object reference variable is full of bits representing a way to get to 
   the object. Remember again, objects live in one place and one place only - the garbage collectible heap.

-  Dog myDog = new Dog();

   Step1: Dog myDog: Tells the JVM to allocate space for a reference variable and names that variable myDog.

   Question: Where is the space allocated from?

   Step2: new Dog();: Tells the JVM to allocate space for a new Dog object on the heap.

   Step3: Dog myDog = new Dog();: Assigns the new Dog to the reference variable myDog.

-  We cannot do arithmetic on a reference variable, e.g. increment it.

-  An array itself (e.g. int[] and dog[]) is an object.

-  A reference variable has value of null when it is not referencing any object.

-  An array is alwasy an object, even if the array is declared to hold primitives. There is no such thing as a primitive array, only an array that holds primitives. E.g.

   Dog[] myDogs = new Dog[3];
   myDogs[0] = new Dog();
   myDogs[0].name = "Fido";

Chapter 4 How objects behave

-  A class describes what an object knows and what an object does.

-  Java is pass-by-value. That means pass by copy.

-  As the encapsulation starter rule of thumb: mark your instance variables private and provide public getters and setters for access control.

-  You don't have to initialize instance variables, because they always have a default value. Number primitives (including char) get 0, booleans get false, 
   and objects reference variables get null. Remember null just means a remote control that isn't controlling/programmed to anything. A reference, but no actual object.

-  The difference between instance and local variables:

   Instance variables are declared inside a class but not within a method.

   class Horse
   {
      private double height = 15.2;
      private String breed;

      //more code...
   }

   Local variables are declared within a method. Local variables must be initilized before use!

   class Foo
   {
      public void go()
      {
         int x;
         int z = x + 3;  <--- It won't compile!! You declare x without a value, but as soon as you try to use it, the compiler freaks out.
      }
   }

-  Comparing variables.

   == : to know if two primitives are the same.

-  Developing a Class:

   prep code:  A form of pseudocode to help you focus on the logic without stressing about syntax;

   test code: A class or methods that will test the real code and validate that it's doing the right thing;

   real code: The actual implementation of the class.

Chapter 5 Extra-Strength Methods

-  The enhanced for loop

   Beginning with java 5.0(Tiger), the Java language has a second kind of for loop called the "enhanced for", that makes it easier to iterate over all the elements
   in an array or other kinds of collections.

   for (String name: nameArray){}
   
   What it means in plain English: For each element in nameArray, assign the element to the 'name' variable, and run the body of the loop.

   Note: the colon(:) means "IN"

Chapter 6 Using the Java Library

-  "ArrayList" is a class in the core Java library (the API).

   add
   remove
   contains
   isEmpty
   indexOf
   size
   get
   ...

-  Although an ArrayList holds objects and not primitives, the compiler will automatically "wrap" (and "unwrap" when you take it out) a primitive into an Object, and place that
   object in the ArrayList instead of primitive.

-  You declare the type of the array using a type parameter, which is a type name in angle brackets. E.g.

   ArrayList<Button> means ArrayList will be able to hold only objects of type Button (or subclass of Button as you will learn in the next couple of chapters)

-  In the java API, classes are grouped into packages. to use a class in the API, you have to know which package the class is in. Using a class from the API is simple, somewhere
   in your code, you have to indicate the full name of the library class you want to use, and that means package name + class name
   
   E.g.

   java.util.ArrayList;
   
   where

   "java.util" is the package name and "ArrayList" is the class name.

-  You have to tell Java which ArrayList you want to use. You have two options:

   Put an import statement at the top of your source code file:

   java.util.ArrayList;
   public class MuClass {...}

   or

   Type the full name everywhere in your code each time you use it.

   1) When you declare and/or instantiate it:
   
      java.util.ArrayList<Dog> list = new java.util.ArrayList<Dog>();

   2) When you use it as an argument type:
   
      public void go(java.util.ArrayList<Dog> list) { }

   3) When you use it as a return type:
   
      public java.util.ArrayList<Dog> foo() {...}

-  "import" is different from "include" in C. An import is simply the way you give Java the full name of a class.

-  Remember, you have to tell Java the full name of every class you use, unless the class is in the java.lang.
   
Chapter 7 inheritance and polymorphism

-  When you call a method on an object reference, you're calling the most specific version of the method for that object type. In other words, the lowest one wins. Here "Lowest"
   means lowest on the inheritance tree.

-  Remember that when one class inherits from another, we say that the subclass extends the superclass. We use "IS-A" test to test if the inheritance makes sense. To know if you've
   designed your types correctly, ask, "Does it make sense to say type X IS-A type of Y?"
   
-  In a subclass, how to use both the superclass version and my overriding subclass version of a method?

   public void roam() {
   super.roam(); //this calls the inherited version of roam()
   // my own roam stuff
   }

-  A subclass inherits members(instance variables and methods) of the superclass. A superclass can choose whether or not it wants a subclass to inherit a particular member by the
   level of access the particular member is given.

   There are 4 access levels covered in this book:

   private: public members are inherited.
   default: private members are not inherited.
   protected:
   public:

   The following table shows the access to members permitted by each modifier:

   | Modifier | Class    | Package |  Subclass | World |
      public     Y            Y          Y         Y
     protected   Y            Y          Y         N
     default     Y            Y          N         N
     private     Y            N          N         N

-  Inherited methods can be overridden; instance variables cannot be overriden (although they can be redefined in the subclass, but that's not the same thing, and there's almost never
   a need to it.)

-  Inheritance lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a common protocol for
   a set of classes related though inheritance.

-  With polymorphism, the reference type can be a superclass of the actual object type.

   Animal myDog = new Dog();

   Also, you can have polymorphic arguments and return types. E.g.

   class Vet {
      public void giveShot (Animal a) {
      // do horrible things to the Animal at
      // the other end of the 'a' parameter
      a.makeNoise();
   }

   class PetOwner {
      public void Start() {
         Vet v = new Vet();
         Dog d = new Dog();
         Hippo h = new Hippo();
         v.giveShot(d); //dog's makeNoise runs
         v.giveShot(h); //Hippo's makeNoise() runs

   With polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program. Let's say if others want to take advantage of your
   your Vet class, all they have to do is make sure their new Animal types extend class Animal. The Vet methods will still work, even though the Vet class was written without
   any knowledge of the new Animal subtypes the Vet will be working on.

-  If you want to protect a specific method from being overriden, mark the method with the "final" modifier. Mark the whole class as final if you want to guarantee that none
   of the methods in that class will ever be overriden.

-  Overriding: The arguments and return types of your overriding method must look to the outside world exactly like the overriden method in the superclass. E.g.

   Appliance:

      boolean turnOn()

      boolean turnOff()

   Toaster:

      boolean turnOn(int level) <--This is actually overload but not override as the arguments have been changed!

   Also, the access level must be the same or friendlier. That means you cannot for example override a public method and make it private.

-  Overloading: It means two methods with the same name but different argument lists. remember, there is no polymorphism involved with overloaded methods.

   Overloading lets you make multiple versions of a method. Something to remember about overload:

   1) The return types can be different;
   2) You cannot change only the return type;
   3) You can vary the access levels in any direction.

Chapter 8 Serious Polymorphism

-  Abstract classes

   Some classes just should not be instantiated. E.g. Animals. By marking the class as abstact, the compiler will stop any code, anywhere, from ever creating an instance
   of that type. to mark a class as abstract, put the keyword "abstract" before the class declaration:

   abstract class Canine extends Animal {
      public void roam {}
   }

   By doing this, the compiler won't let you instantiate an abstract class

   abstract class Canine extends Animal {
      public void roam {}
   }

   public class MakeSense {
      public void go() {
         Canine c;
         c = new Dog(); // <--- This is OK
         c = new Canine(); <---class Canine is marked abstract so the compiler will Not let you do this.

-  Abstract methods

   You can mark methods abstract too. An abstract class means the class must be extended; an abstract method means the method must be overriden.

   An abstract method has no body:

   public abstract void eat(); 

   Also, if you declare an abstract method, you MUST mark the class abstract as well. You can’t have an abstract method in a non-abstract class. In other words, if a class has
   even one abstract method, the class must be marked abstract.

   The point of using abstract methods is...Polymorphism! Image how you'd have to change the Vet class, if it didn't use Animal as its argument type of methods. You'd have to
   have a seperate method for every single Animal subclass!

   Abstract methods don't have a body; that means the first concrete class in the inheritance tree must implement all abstract methods.

-  Every class in Java extends class "Object". That means "Object" is the superclass of everything. It also means that every class you write extends "Object".

   public class Dog extends Objext{}

   But wait a minute, Dog already extends Canine. It is OK becasue the compiler will make Canine extend Object instead. Except Canine extends Animal. No problem, then the compiler
   will just make Animal extend Object.

-  So what's in this ultra-super-megaclass Object?

   1) equals(object o) ->> tells you if two objects are equal.

   e.g. a.equals(c) <--a, c are objects
   
   2) getClass --> Gives you back the class that object was instantiated from

   3) hashCode --> Prints out a hashcode for the object

   4) toString --> Prints out a String message with the name of the class and some other number we rarely care about.

-  The compiler decides whether you can call a method based on the reference type, not the actual object type. E.g.

   Object o = al.get(index);
   int i = o.hashCode(); <-- this is fine as every object in Java can call hashCode().
   o.bark(); <-- Can't do this. The Object class has not idea what it means to bark(), Even though you know it's really a Dog at that index, the compiler doesn't.

   The compiler checks the class of the reference type, not the object type - to see if you can call a method using that reference.

-  Casting an object reference back to its real type

   You must ensure that the object is really dog, e.g.,    

   Object o = al.get(index);
   Dog d = (Dog) o;
   d.roam();

   If you not sure it's a Dog, you can use instanceof operator to check:

   if (o instanceof Dog) {
      Dog d = (Dog) o;
   }

-  A Java interface solves your multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the
   Deadly Diamond of Death (DDD).

   Note: What is Deadly diamond of Death?

   The way to handle that is very simple: make all the methods abstract.

   Pet:

   abstract void beFriendly();
   abstract void play();

   1) To DEFINE an interface:

   public interface Pet {...}
               ^
               |-----------------> Use the keyword "interface" instead of "class"

   2) To IMPLEMENT an interface:
   
   public class Dog extends Canine implements Pet {...}
                                       ^
                                       |
                                       |-----------------Use the keyword "implements" followed by the inferface name. Note that when you implement an interface you still get
                                                         to extend a class.

   3) Making and Implementing the Pet interface:

   public interface Pet {

      public abstract void beFriendly();  <--no body as it is an abstract method.
      public abstract void play(); <--no body as it is an abstract method.

   public class Dog extends Canine implements Pet {
   
      public abstract void beFriendly() {...} <---Implement the pet method
      public abstract void play() {...} <--Implement the pet method

      public void roam() {...} <-- This is just normal overriding method.
      public void eat() {...} <-- This is just normal overriding method.

-  In summary, how do you know whether to make a class, a subclass, an abstract class, or an inferface:

   1) Make a class that doesn’t extend anything (other than Object) when your new class doesn’t pass the IS-A test for any other type.

   2) Make a subclass (in other words, extend a class) only when you need to make a more specific version of a class and need to override or add new behaviors.

   3) Use an abstract class when you want to define a template for a group of subclasses, and you have at least some implementation code that all subclasses 
      could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.

   4) Use an interface when you want to define a role that other classes can play, regardless of where those classes are in the inheritance tree.

-  Invoking the superclass version of a method

   If you want to invoke the superclass version of a method instead of the overriden one, use the keyword "super" lets you invoke a superclass version of an overridden method, 
   from within the subclass. E.g.

   abstract class Report {
      void runReport() {
         //setup a report
      }
      void printReport() {
         //generic printing
      }
   }

   class BuzzwordsReport extends Report {
      
      void runreport () {
         super.runReport(); //call superclass version then come back and do some subclass-specific stuff.
         buzzwordCompliance();
         printReport();
      }
      
      void buzzwordCompilance() {...}

  The "super" keyword is really a reference to the superclass portion of an object. 

Chapter 9 Life and Death of an Object

-  The STACK and the HEAP: where things live

   Stack: method invocations and local variables live
   Heap:  objects live

   Instance variables: they are declared inside a class but not inside a method.
   Local variables: they are declared inside a method, including method parameters.
   The method on the top of the stack is always the currently-executing method.

   Note: No matter where the object reference variable is declared (inside a method vs an instance variable of a class)the object always always always goes on the heap.
   
-  Instance variables live on the heap, inside the object they belong to.

   1) If the instance variables are all primitives, Java makes space for the instance variables based on the primitive type. E.g. an int needs 32 bits.
   2) How about the instance variables are objects? 

      If the instance variable is declared but no object is assigned to it, then only the space for the reference variable (the remote control) is created.
      
      private Antenna ant;

      No actual Antenna object is made on the heap unless or until the reference variable is assigned a new Antenna object:

      private Antenna ant = new Antenna();

   Instance variables are assigned a default value. even when you don't explicitly assign one. The default values are 0/0.0/false for primitives, and null for references.

-  Constructor

   A constructor is the code that runs when you say "new" on a class type. A constructor must have the same name as the class, and must not have a return type.
   By default, there is nothing inside the constructor of a class:

   public class Duck {
      public Duck { 
      
      //empty here. Remember there is no code here. Also there is no return type.
      }
   }

   You can do more with constructor. E.g.

   public Duck(int duckSize) {
      size = duckSize; //size is the instance variable.
   }

   Remember, the compiler gets involved with constructor making only if you don't say anything at all about constructors. That means no to the question: Doesn't the compiler
   always make no-arg constructor for you?

   If you write a constructor that takes arguments, and you still want a no-arg constructor, you'll have to build the no-arg constructor yourself! That means if you touch the
   constructor, you need to write two versions of it. Overloaded constructors means you have more than one constructor in your class. To copmpile, each constructor must have
   diffeent argument list!

-  The big point there was that every object holds not just its own declared instance variables, but also everything from its superclasses(which, at minimum, means class Object
   , since every class extends Object). But how does a superclass constructor gets involked?

   call super(). E.g.

   public class Duck extends Animal {
      int size;

      public Duck(int newSize) {
         super();
         size = newSize;
      }
   }

   The compiler gets involved in constructor-making in two ways:

   1) If you don't provide a constructor, the compiler puts one in that looks like:

      public ClassName() {
         super();
      }

   2) If you do provide a constructor but you do not put in the call to super():

      The compiler will put a call to super() in each of your overloaded constructors(unless the constructor calls another overloaded constructor). The compiler-supplied 
      call looks like:
      
      super();

      It always looks like that. The compiler-inserted call to super() is always no-arg call. If the superclass has overloaded constructors, only the no-arg
      one is called.

   Can you pass something in to the super() call? Yes!

   E.g.

   public abstract class Animal {
      private String name;

      public String getName() {
         return name;
      }

      public Animal(String theName) {
         name = theName;
      }
   }

   public class Hippo extends Animal {
      public Hippo(String name ){
         super(name);//it sends the name up the stack to the Animal constructor
      }
   {

   public class MakeHippo {
      public static void main (String[] args) {
         Hippo h = new Hippo("Buffy");
         System.out.println(h.getName());
      }
   }

-  What if you have overloaded constructors that, with the exception of handling different argument types, and do all the same thing? You know that you don't want to
   duplicate code sitting in each of the constructors (pain to maintain, etc.). You can use this() to call a constructor from another overloaded constructor in the same
   class. The call to this() can be used only in a constructor, and must be the first statement in a constructor. Remember, Every constructor can have a call to super()
   or this(), but never both!

   class Mini extends Car {
      Color color;
      
      public Mini() {
         this(Color.Red); //The no-arg constructor supplies a default Color and calls to the overloaded Real Constructor (the one that calls super()).
      }

      public Mini(color c) {
         super("Mini"); //This is the Real Constructor that does the real work of initializing the object (including the call to super()).
         color = c;
         //more initialization
      }

      public Mini(int size) {
         this(Color.Red);
         super(size); //<<- won't work! Can't have super() and this() in the same constructor, because they each must be the first statement!
      }

-  How long does an object live?

   An object's life depends entirely on the life of references referring to it. So how long does a variable live?

   That depends on whether the variable is a local variable or an instance variable. A local variable lives only within the method that declared the variable. An instance
   variable lives as long as the object does. If the object is still alive, so are its instance variables.

   An object becomes eligible for GC(garbage collectable) when its last live reference disappears. Three ways to get rid of an object's reference:

   1) The reference goes out of scope, permanently

      void go() {
         Life z = new Life(); //reference 'z' dies at end of method.
      }

   2) The reference is assigned another object

   Life z = new Life(); //the first object is abandoned when z is 'reprogrammed' to a new object.
   z = new Life(); 

   3) The reference is explicitly set to null

   Life z = new Life(); //the first object is abandoned when z is deprogrammed.
   z = null;

Chapter 10 numbers and statics

-  The difference between regular (non-static) and static methods methods.

   Java is object-oriented, but once in a while you have a special case, typically a utility method (like the Math methods), where there is no need to have an instance of the class.
   
   The keyword "static" lets a method run without any instance of the class. A static method means "behavior not dependent on an instance variable, so no instance/object is required. 
   Just the class."

-  Static methods cannot use non-static (instance) variables.

   public class Duck {
      private int size;
   
      public static void main(String [] args) {
         System.out.println("Size of duck is " + size); //<<---which duck? whose size? if there is Duck on the heap somewhere, we don't know about it.
      }

      public setSize (int s) {
         size = s;
      }

      public int getSize() {
         return size;
      }
   }
   
-  Static methods can't use non-static methods either. E.g.

   public static void main(String [] args) {
      System.out.println("Size of duck is " + getSize()); //whose size?
   }

   Also, if you have a class with only static methods, and you do not want the class to be instanciated, you can mark the constructor private.

-  Static variable: value is the same for all instances of the class

   A value shared by all instances of a class. In other words, one value per class, instead of one value per instance.

   public class Duck {
      private int size;
      private static int duckCount = 0; // The static duckCount variable is initialized ONLY when the class is first loaded, Not each time a new instance is made.
   
   public Duck() {
      duckCount++; //Now it will keep incrementing each time the Duck constructor runs, because duckCount is static and won't be reset to 0. With this static variable, you can
                   //count how many duck instances are being created while your program is running.
   }

   All static variables in a class are initialized before any object of that class can be created. Default values for declared but uninitialized static and instance variables
   are the same:

   primitive integers (long, short, etc...): 0
   primitive floating points (float, double): 0.0
   boolean: false
   object reference: null

   Note: A static method can access a static variable.

-  static final variables are constants

   A variable marked "final" means that - once initialized - it can never change. E.g.

   public static final double PI = 3.141592653589793;

   note: Constants variable names should be in all caps.

   Assigning a value to a final instance variable must be either at the time it is declared, or in the constructor.

   1) At the time you declare it:

   public class Foo {
      public static final int FOO_X = 25;
   }

   or

   2) In a static initializer in the constructor

   public class Bar {
      public static final double BAR_SIGN;
   
      static {

         BAR_SIGN = (double) Math.random();
      }

   }

-  "final" isn't just for static variables...
   
   You can use "final" to modify non-static variables too, including instance variables, local variables and even method parameter.

   A final variable means you can't change its value.

   A final method means you can't override the method.

   A final class means you can't extend the class (i.e. you can't make a subclass).

-  In summary, we should follow the following order of defining a variable:

   [access type][static or not][final or not]type variableName;

   access type could be: private, (default), "public" and "protected".

-  Wrapping a primitive

   In all version of Java prior to 5.0, you cannot put a primitive directly into a collection like AllayList and HashMap:

   To treat a primitive like an object, there is a wrapper class for every primitive type(you don't need to import them as the wrapper classes are in the java.lang package).
   Each wrapper class is named after the primitive type it wraps, but with the first letter capitalized to follow the class naming convention:

   Boolean
   Character
   Byte
   Short
   Integer
   Long
   Float
   Double

   Wrapping a value:

   int i = 288;
   Integer iWrap = new Integer(i);

   Unwrapping a value:

   int unWrapped = iWrap.intValue.

-  Autoboxing: blurring the line between primitive and object.

   The autoboxing feature added to Java 5.0 does the conversion from primitive to wrapper object automatically!

   public void doNumNewWay () {
      ArrayList<Integer> listOfNumbers = new ArrayList<Integer>(); //<---Make an ArrayList of type Integer
      listOfNumbers.add(3); //<---Although there is not a method in ArrayList, for add(int), the compiler does all the wrapping (boxing) for you. In other words, there is an Integer
                            //object stored in the ArrayList, but you get to "pretend" that the ArrayList takes ints.(You can add both ints and Integers to an ArrayList<Integer>).
      int num = listOfNumbers.get(0);//<---the compiler automatically unwraps(unboxes) the Integer object to you can assign the int value directly to 
                                     //a primitive without having to call intValue() method on the Integer object.
   }

   Beside doing wrapping and unwrapping, autobox also lets you use either a primitive or its wrapper type virtually anywhere one or the other is expected.

   1) Method arguments

   void takeNumber(Integer i) {}

   2) Return values

   int giveNumber() {
      return x;
   }

   3) Boolean expressions

   if (bool) {
      System.out.println("true");
   }

   4) Operations on numbers

   Integer i = new Integer(42);
   i++;

   or

   Integer j = new Integer(5);
   Integer k = j + 3;

   5) Assignments

   Double d = x;

   But wait! There's more! Wrappers have static utility methods too!

   6) converting a String to a primitive value is easy:

   String s = "2";
   int x = Integer.parseInt(s); //<---No problem to parse "2" into 2.
   double d = Double.parseDouble("420.24");
   boolean b = new Boolean("true").booleanValue();//<--There is no method called "Boolean.parseBoolean()". Fortunatelly, there is a Boolean constructor that takes (and parses) a String
                                                  //, and then you just get the primitive value by unwrapping it.

   But if you try this:

   String t = "two";
   int y = Integer.parseInt(t); //<---You get runtime error as Anything that can't be parse as a number will cause a Number FormatException.

-  Turning a primitive number into a String.

   There are a couple ways to turn a number into a String.

   1) concatenate the number to an existing String.

   double d = 42.5;
   String doubleString "" + d; //<---The "+" operator is overloaded in Java (the only overloaded operator) as a String concatenator. Anything added to a String becomes Stringified.

   2) Using a static method in class Double.

   double d = 42.5;
   String doubleString = Double.toString(d);

-  Number formatting

   1) Formatting a number to use commas;

   public class TestFormats {
      public static void main (String[] args) {
         String s = String.format("%, d", 1000000000); //<---The formatting instructions for how to format the second argument. Remember, there are only two arguments to this method
                                                       //here - the first comma is inside the string literal, so it isn't seperating arguments to the format method.
      }
   }

   Output:
   
   1,000,000,000

-  Formatting deconstructor...

   format("%, d", 1000000000);

   1) "%, d" ---> Use these instructions;
   2) 1000000000 ---> on this argument(s).

   The percent (%) says, "Insert argument here" (and format it using these instructions).

   When you see the % sign, think of the percent sign as a variable that represents the other argument to the method.

   format("I have %.2f bugs to fix.", 476578.09876);

   %.2f --> The "%" sign tells the formatter to insert the other method argument (the second argument to format(), the number) here, AND format it using the ".2f" character
            after the percent sign. Then the rest of the format String, "bugs to fix", is added to the final output.

   Output:

   I have 476578.10 bugs to fix.

   Adding a comma:

   format(“I have %,.2f bugs to fix.”, 476578.09876);

   Output:

   I have 476,578.10 bugs to fix.

   In summary:

   %,d means "insert commas and format the number as a decimal integer"

   %.2f means "format the number as a floating point with a precision of two decimal places."

   %,.2f means "insert commas and format the number as a floating point with a precision of two decimal places."

-  The format specifier

   A format specifier can have up to five different parts (not including the "%"). Everything in brackets [] below is optional, so only the percent(%) and the type are required.
   But the order is also mandatory, so any parts you Do use must go in this order.

   %[argument number][flags][width][.precision]type

   E.g.

   format(“%,6.1f”, 42.000);
   
   Note; We will talk about [argument number] later.

   1) type

   %d decimal
   %f float
   %x hex
   $c character

   What happens if you have more than one argument:

   int one = 20456654;
   double two = 100567890.248907;
   String s = String.format(“The rank is %,d out of %,.2f”, one, two);

   output:

   The rank is 20,456,654 out of 100,567,890.25.

-  How about dates?

   1) The complete date and type: %tc

   String.format(“%tc”, new Date());

   output:

   Sun Nov 28 14:52:41 MST 2004

   2) Just the time: %tr

   String.format(“%tr”, new Date());

   03:01:47 PM

   3) Day of the week, month and day: %tA %tB %td

   There isn't single format specifier that will do exactly what we want, so we have to combine three of them for day of the week (%tA), month(%tB), and day of the month(%td).

   Same as above, but without duplicating the arguments

   Date today = new Date();
   String.format(“%tA, %<tB %<td”,today); //<---The angle-bracket "<" is just another flag in the specifier that tells the formatter to "Use the previous argument again.", instead
                                          //you format the same argument three different ways.

   

   

   

   
   
Questions

1) Is it ture that the name of a public class must be the same as the file name?

2) What is an iterator/

   An iterator enables you cycle through a collection, obtaining or removing elements. Listiterator extends iterator to allow bidirectional traversal of a list, and the modification
   of elements. In general, to use an iterator to cycle through the contents of a collection, follow these steps:

   -  Obtain an iterator to the start of the collection by calling the collections's iterator() method. 

   -  Set up a loop that makes a call to hashNext(). Have the loop iterate as long as hashNext() returns true.

   -  Within the loop, obtain each element by calling next().

3) What is "<? super T>" mean?

   public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        int srcSize = src.size();
        if (srcSize > dest.size())
            throw new IndexOutOfBoundsException("Source does not fit in dest");

        if (srcSize < COPY_THRESHOLD ||
            (src instanceof RandomAccess && dest instanceof RandomAccess)) {
            for (int i=0; i<srcSize; i++)
                dest.set(i, src.get(i));
        } else {
            ListIterator<? super T> di=dest.listIterator();
            ListIterator<? extends T> si=src.listIterator();
            for (int i=0; i<srcSize; i++) {
                di.next();
                di.set(si.next());
            }
        }
    }

4) 
