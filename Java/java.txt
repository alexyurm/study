Chapter 1 

-  In Java, everything goes in class. You'll type your source code file (with java extension), then compile it into a new class file (with a .class extension). When you run your program, you're really running a class.

-  Running a program means telling the Java Virtual Machine to "Load the Hello class then start executing its main()".

Chapter 2 Objects and Classes

-  A class is a blueprint for an object(or instance).

-  Things that an object can do are called methods.

-  As long you're in main(), you are not really in Objectville. It's fine for a test program to run within the main method. But in true OO application, you need objects talling
   to other objects, as opposed to a static main() method creating and testing objects.

-  A real Java application is nothing but objects talking to other objects. In this case, talking means objects calling methods of on one another.

-  Java takes out the garbage:

   Each time an object is created in Java, it goes into an area of memory known The Heap. The Java Heap, which is not like the heap memory in C/C++, is actually a Garbage-Collection
   Heap. When JVM can 'see' that an object can never be used again, that object becomes eligible collection.

-  It would be a big pain to deliver a huge bunch of individual files to your end-users but you won't have to. You can put all of your application files into Java Archive - a .jar file
   that is based on the pkzip format. In the jar file, you can include a simple text file formatted as something called a manifest, that defines which class in that jar holds the main()
   method that should run.

-  A class can inherit instance variables and methods from a more abstract superclass.

Chapter 3  Primitives and References.

-  A primitive variable (int, float...) is full of bits representing the actual value of the variable, an object reference variable is full of bits representing a way to get to 
   the object. Remember again, objects live in one place and one place only - the garbage collectible heap.

-  Dog myDog = new Dog();

   Step1: Dog myDog: Tells the JVM to allocate space for a reference variable and names that variable myDog.

   Question: Where is the space allocated from?

   Step2: new Dog();: Tells the JVM to allocate space for a new Dog object on the heap.

   Step3: Dog myDog = new Dog();: Assigns the new Dog to the reference variable myDog.

-  We cannot do arithmetic on a reference variable, e.g. increment it.

-  An array itself (e.g. int[] and dog[]) is an object.

-  A reference variable has value of null when it is not referencing any object.

-  An array is alwasy an object, even if the array is declared to hold primitives. There is no such thing as a primitive array, only an array that holds primitives. E.g.

   Dog[] myDogs = new Dog[3];
   myDogs[0] = new Dog();
   myDogs[0].name = "Fido";

Chapter 4 How objects behave

-  A class describes what an object knows and what an object does.

-  Java is pass-by-value. That means pass by copy.

-  As the encapsulation starter rule of thumb: mark your instance variables private and provide public getters and setters for access control.

-  You don't have to initialize instance variables, because they always have a default value. Number primitives (including char) get 0, booleans get false, 
   and objects reference variables get null. Remember null just means a remote control that isn't controlling/programmed to anything. A reference, but no actual object.

-  The difference between instance and local variables:

   Instance variables are declared inside a class but not within a method.

   class Horse
   {
      private double height = 15.2;
      private String breed;

      //more code...
   }

   Local variables are declared within a method. Local variables must be initilized before use!

   class Foo
   {
      public void go()
      {
         int x;
         int z = x + 3;  <--- It won't compile!! You declare x without a value, but as soon as you try to use it, the compiler freaks out.
      }
   }

-  Comparing variables.

   == : to know if two primitives are the same.

-  Developing a Class:

   prep code:  A form of pseudocode to help you focus on the logic without stressing about syntax;

   test code: A class or methods that will test the real code and validate that it's doing the right thing;

   real code: The actual implementation of the class.

Chapter 5 Extra-Strength Methods

-  The enhanced for loop

   Beginning with java 5.0(Tiger), the Java language has a second kind of for loop called the "enhanced for", that makes it easier to iterate over all the elements
   in an array or other kinds of collections.

   for (String name: nameArray){}
   
   What it means in plain English: For each element in nameArray, assign the element to the 'name' variable, and run the body of the loop.

   Note: the colon(:) means "IN"

Chapter 6 Using the Java Library

-  "ArrayList" is a class in the core Java library (the API).

   add
   remove
   contains
   isEmpty
   indexOf
   size
   get
   ...

-  Although an ArrayList holds objects and not primitives, the compiler will automatically "wrap" (and "unwrap" when you take it out) a primitive into an Object, and place that
   object in the ArrayList instead of primitive.

-  You declare the type of the array using a type parameter, which is a type name in angle brackets. E.g.

   ArrayList<Button> means ArrayList will be able to hold only objects of type Button (or subclass of Button as you will learn in the next couple of chapters)

-  In the java API, classes are grouped into packages. to use a class in the API, you have to know which package the class is in. Using a class from the API is simple, somewhere
   in your code, you have to indicate the full name of the library class you want to use, and that means package name + class name
   
   E.g.

   java.util.ArrayList;
   
   where

   "java.util" is the package name and "ArrayList" is the class name.

-  You have to tell Java which ArrayList you want to use. You have two options:

   Put an import statement at the top of your source code file:

   java.util.ArrayList;
   public class MuClass {...}

   or

   Type the full name everywhere in your code each time you use it.

   1) When you declare and/or instantiate it:
   
      java.util.ArrayList<Dog> list = new java.util.ArrayList<Dog>();

   2) When you use it as an argument type:
   
      public void go(java.util.ArrayList<Dog> list) { }

   3) When you use it as a return type:
   
      public java.util.ArrayList<Dog> foo() {...}

-  "import" is different from "include" in C. An import is simply the way you give Java the full name of a class.

-  Remember, you have to tell Java the full name of every class you use, unless the class is in the java.lang.
   
Chapter 7 inheritance and polymorphism

-  When you call a method on an object reference, you're calling the most specific version of the method for that object type. In other words, the lowest one wins. Here "Lowest"
   means lowest on the inheritance tree.

-  Remember that when one class inherits from another, we say that the subclass extends the superclass. We use "IS-A" test to test if the inheritance makes sense. To know if you've
   designed your types correctly, ask, "Does it make sense to say type X IS-A type of Y?"
   
-  In a subclass, how to use both the superclass version and my overriding subclass version of a method?

   public void roam() {
   super.roam(); //this calls the inherited version of roam()
   // my own roam stuff
   }

-  A subclass inherits members(instance variables and methods) of the superclass. A superclass can choose whether or not it wants a subclass to inherit a particular member by the
   level of access the particular member is given.

   The following table shows the access to members permitted by each modifier:

   | Modifier | Class    | Package |  Subclass | World |
      public     Y            Y          Y         Y
     protected   Y            Y          Y         N
     default     Y            Y          N         N
     private     Y            N          N         N

-  Inherited methods can be overridden; instance variables cannot be overriden (although they can be redefined in the subclass, but that's not the same thing, and there's almost never
   a need to it.)

-  Inheritance lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a common protocol for
   a set of classes related though inheritance.

-  With polymorphism, the reference type can be a superclass of the actual object type.

   Animal myDog = new Dog();

   Also, you can have polymorphic arguments and return types. E.g.

   class Vet {
      public void giveShot (Animal a) {
      // do horrible things to the Animal at
      // the other end of the 'a' parameter
      a.makeNoise();
   }

   class PetOwner {
      public void Start() {
         Vet v = new Vet();
         Dog d = new Dog();
         Hippo h = new Hippo();
         v.giveShot(d); //dog's makeNoise runs
         v.giveShot(h); //Hippo's makeNoise() runs

   With polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program. Let's say if others want to take advantage of your
   your Vet class, all they have to do is make sure their new Animal types extend class Animal. The Vet methods will still work, even though the Vet class was written without
   any knowledge of the new Animal subtypes the Vet will be working on.

-  If you want to protect a specific method from being overriden, mark the method with the "final" modifier. Mark the whole class as final if you want to guarantee that none
   of the methods in that class will ever be overriden.

-  Overriding: The arguments and return types of your overriding method must look to the outside world exactly like the overriden method in the superclass. E.g.

   Appliance:

      boolean turnOn()

      boolean turnOff()

   Toaster:

      boolean turnOn(int level) <--This is actually overload but not override as the arguments have been changed!

   Also, the access level must be the same or friendlier. That means you cannot for example override a public method and make it private.

-  Overloading: It means two methods with the same name but different argument lists. remember, there is no polymorphism involved with overloaded methods.

   Overloading lets you make multiple versions of a method. Something to remember about overload:

   1) The return types can be different;
   2) You cannot change only the return type;
   3) You can vary the access levels in any direction.

Chapter 8 Serious Polymorphism

-  Abstract classes

   Some classes just should not be instantiated. E.g. Animals. By marking the class as abstact, the compiler will stop any code, anywhere, from ever creating an instance
   of that type. to mark a class as abstract, put the keyword "abstract" before the class declaration:

   abstract class Canine extends Animal {
      public void roam {}
   }

   By doing this, the compiler won't let you instantiate an abstract class

   abstract class Canine extends Animal {
      public void roam {}
   }

   public class MakeSense {
      public void go() {
         Canine c;
         c = new Dog(); // <--- This is OK
         c = new Canine(); <---class Canine is marked abstract so the compiler will Not let you do this.

-  Abstract methods

   You can mark methods abstract too. An abstract class means the class must be extended; an abstract method means the method must be overriden.

   An abstract method has no body:

   public abstract void eat(); 

   Also, if you declare an abstract method, you MUST mark the class abstract as well. You can’t have an abstract method in a non-abstract class. In other words, if a class has
   even one abstract method, the class must be marked abstract.

   The point of using abstract methods is...Polymorphism! Image how you'd have to change the Vet class, if it didn't use Animal as its argument type of methods. You'd have to
   have a seperate method for every single Animal subclass!

   Abstract methods don't have a body; that means the first concrete class in the inheritance tree must implement all abstract methods.

-  Every class in Java extends class "Object". That means "Object" is the superclass of everything. It also means that every class you write extends "Object".

   public class Dog extends Objext{}

   But wait a minute, Dog already extends Canine. It is OK becasue the compiler will make Canine extend Object instead. Except Canine extends Animal. No problem, then the compiler
   will just make Animal extend Object.

-  So what's in this ultra-super-megaclass Object?

   1) equals(object o) ->> tells you if two objects are equal.

   e.g. a.equals(c) <--a, c are objects
   
   2) getClass --> Gives you back the class that object was instantiated from

   3) hashCode --> Prints out a hashcode for the object

   4) toString --> Prints out a String message with the name of the class and some other number we rarely care about.

-  The compiler decides whether you can call a method based on the reference type, not the actual object type. E.g.

   Object o = al.get(index);
   int i = o.hashCode(); <-- this is fine as every object in Java can call hashCode().
   o.bark(); <-- Can't do this. The Object class has not idea what it means to bark(), Even though you know it's really a Dog at that index, the compiler doesn't.

   The compiler checks the class of the reference type, not the object type - to see if you can call a method using that reference.

-  Casting an object reference back to its real type

   You must ensure that the object is really dog, e.g.,    

   Object o = al.get(index);
   Dog d = (Dog) o;
   d.roam();

   If you not sure it's a Dog, you can use instanceof operator to check:

   if (o instanceof Dog) {
      Dog d = (Dog) o;
   }

-  A Java interface solves your multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the
   Deadly Diamond of Death (DDD).

   Note: What is Deadly diamond of Death?

   The way to handle that is very simple: make all the methods abstract.

   Pet:

   abstract void beFriendly();
   abstract void play();

   1) To DEFINE an interface:

   public interface Pet {...}
               ^
               |-----------------> Use the keyword "interface" instead of "class"

   2) To IMPLEMENT an interface:
   
   public class Dog extends Canine implements Pet {...}
                                       ^
                                       |
                                       |-----------------Use the keyword "implements" followed by the inferface name. Note that when you implement an interface you still get
                                                         to extend a class.

   3) Making and Implementing the Pet interface:

   public interface Pet {

      public abstract void beFriendly();  <--no body as it is an abstract method.
      public abstract void play(); <--no body as it is an abstract method.

   public class Dog extends Canine implements Pet {
   
      public abstract void beFriendly() {...} <---Implement the pet method
      public abstract void play() {...} <--Implement the pet method

      public void roam() {...} <-- This is just normal overriding method.
      public void eat() {...} <-- This is just normal overriding method.

-  In summary, how do you know whether to make a class, a subclass, an abstract class, or an inferface:

   1) Make a class that doesn’t extend anything (other than Object) when your new class doesn’t pass the IS-A test for any other type.

   2) Make a subclass (in other words, extend a class) only when you need to make a more specific version of a class and need to override or add new behaviors.

   3) Use an abstract class when you want to define a template for a group of subclasses, and you have at least some implementation code that all subclasses 
      could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.

   4) Use an interface when you want to define a role that other classes can play, regardless of where those classes are in the inheritance tree.

-  Invoking the superclass version of a method

   If you want to invoke the superclass version of a method instead of the overriden one, use the keyword "super" lets you invoke a superclass version of an overridden method, 
   from within the subclass. E.g.

   abstract class Report {
      void runReport() {
         //setup a report
      }
      void printReport() {
         //generic printing
      }
   }

   class BuzzwordsReport extends Report {
      
      void runreport () {
         super.runReport(); //call superclass version then come back and do some subclass-specific stuff.
         buzzwordCompliance();
         printReport();
      }
      
      void buzzwordCompilance() {...}

  The "super" keyword is really a reference to the superclass portion of an object. 

Chapter 9 Life and Death of an Object

-  The STACK and the HEAP: where things live

   Stack: method invocations and local variables live
   Heap:  objects live

   Instance variables: they are declared inside a class but not inside a method.
   Local variables: they are declared inside a method, including method parameters.
   The method on the top of the stack is always the currently-executing method.

   Note: No matter where the object reference variable is declared (inside a method vs an instance variable of a class)the object always always always goes on the heap.
   
-  Instance variables live on the heap, inside the object they belong to.

   1) If the instance variables are all primitives, Java makes space for the instance variables based on the primitive type. E.g. an int needs 32 bits.
   2) How about the instance variables are objects? 

      If the instance variable is declared but no object is assigned to it, then only the space for the reference variable (the remote control) is created.
      
      private Antenna ant;

      No actual Antenna object is made on the heap unless or until the reference variable is assigned a new Antenna object:

      private Antenna ant = new Antenna();

   Instance variables are assigned a default value. even when you don't explicitly assign one. The default values are 0/0.0/false for primitives, and null for references.

-  Constructor

   A constructor is the code that runs when you say "new" on a class type. A constructor must have the same name as the class, and must not have a return type.
   By default, there is nothing inside the constructor of a class:

   public class Duck {
      public Duck { 
      
      //empty here. Remember there is no code here. Also there is no return type.
      }
   }

   You can do more with constructor. E.g.

   public Duck(int duckSize) {
      size = duckSize; //size is the instance variable.
   }

   Remember, the compiler gets involved with constructor making only if you don't say anything at all about constructors. That means no to the question: Doesn't the compiler
   always make no-arg constructor for you?

   If you write a constructor that takes arguments, and you still want a no-arg constructor, you'll have to build the no-arg constructor yourself! That means if you touch the
   constructor, you need to write two versions of it. Overloaded constructors means you have more than one constructor in your class. To copmpile, each constructor must have
   diffeent argument list!

-  The big point there was that every object holds not just its own declared instance variables, but also everything from its superclasses(which, at minimum, means class Object
   , since every class extends Object). But how does a superclass constructor gets involked?

   call super(). E.g.

   public class Duck extends Animal {
      int size;

      public Duck(int newSize) {
         super();
         size = newSize;
      }
   }

   The compiler gets involved in constructor-making in two ways:

   1) If you don't provide a constructor, the compiler puts one in that looks like:

      public ClassName() {
         super();
      }

   2) If you do provide a constructor but you do not put in the call to super():

      The compiler will put a call to super() in each of your overloaded constructors(unless the constructor calls another overloaded constructor). The compiler-supplied 
      call looks like:
      
      super();

      It always looks like that. The compiler-inserted call to super() is always no-arg call. If the superclass has overloaded constructors, only the no-arg
      one is called.

   Can you pass something in to the super() call? Yes!

   E.g.

   public abstract class Animal {
      private String name;

      public String getName() {
         return name;
      }

      public Animal(String theName) {
         name = theName;
      }
   }

   public class Hippo extends Animal {
      public Hippo(String name ){
         super(name);//it sends the name up the stack to the Animal constructor
      }
   {

   public class MakeHippo {
      public static void main (String[] args) {
         Hippo h = new Hippo("Buffy");
         System.out.println(h.getName());
      }
   }

-  What if you have overloaded constructors that, with the exception of handling different argument types, and do all the same thing? You know that you don't want to
   duplicate code sitting in each of the constructors (pain to maintain, etc.). You can use this() to call a constructor from another overloaded constructor in the same
   class. The call to this() can be used only in a constructor, and must be the first statement in a constructor. Remember, Every constructor can have a call to super()
   or this(), but never both!

   class Mini extends Car {
      Color color;
      
      public Mini() {
         this(Color.Red); //The no-arg constructor supplies a default Color and calls to the overloaded Real Constructor (the one that calls super()).
      }

      public Mini(color c) {
         super("Mini"); //This is the Real Constructor that does the real work of initializing the object (including the call to super()).
         color = c;
         //more initialization
      }

      public Mini(int size) {
         this(Color.Red);
         super(size); //<<- won't work! Can't have super() and this() in the same constructor, because they each must be the first statement!
      }

-  How long does an object live?

   An object's life depends entirely on the life of references referring to it. So how long does a variable live?

   That depends on whether the variable is a local variable or an instance variable. A local variable lives only within the method that declared the variable. An instance
   variable lives as long as the object does. If the object is still alive, so are its instance variables.

   An object becomes eligible for GC(garbage collectable) when its last live reference disappears. Three ways to get rid of an object's reference:

   1) The reference goes out of scope, permanently

      void go() {
         Life z = new Life(); //reference 'z' dies at end of method.
      }

   2) The reference is assigned another object

   Life z = new Life(); //the first object is abandoned when z is 'reprogrammed' to a new object.
   z = new Life(); 

   3) The reference is explicitly set to null

   Life z = new Life(); //the first object is abandoned when z is deprogrammed.
   z = null;

Chapter 10 numbers and statics

-  The difference between regular (non-static) and static methods methods.

   Java is object-oriented, but once in a while you have a special case, typically a utility method (like the Math methods), where there is no need to have an instance of the class.
   
   The keyword "static" lets a method run without any instance of the class. A static method means "behavior not dependent on an instance variable, so no instance/object is required. 
   Just the class."

-  Static methods cannot use non-static (instance) variables.

   public class Duck {
      private int size;
   
      public static void main(String [] args) {
         System.out.println("Size of duck is " + size); //<<---which duck? whose size? if there is Duck on the heap somewhere, we don't know about it.
      }

      public setSize (int s) {
         size = s;
      }

      public int getSize() {
         return size;
      }
   }
   
-  Static methods can't use non-static methods either. E.g.

   public static void main(String [] args) {
      System.out.println("Size of duck is " + getSize()); //whose size?
   }

   Also, if you have a class with only static methods, and you do not want the class to be instanciated, you can mark the constructor private.

-  Static variable: value is the same for all instances of the class

   A value shared by all instances of a class. In other words, one value per class, instead of one value per instance.

   public class Duck {
      private int size;
      private static int duckCount = 0; // The static duckCount variable is initialized ONLY when the class is first loaded, Not each time a new instance is made.
   
   public Duck() {
      duckCount++; //Now it will keep incrementing each time the Duck constructor runs, because duckCount is static and won't be reset to 0. With this static variable, you can
                   //count how many duck instances are being created while your program is running.
   }

   All static variables in a class are initialized before any object of that class can be created. Default values for declared but uninitialized static and instance variables
   are the same:

   primitive integers (long, short, etc...): 0
   primitive floating points (float, double): 0.0
   boolean: false
   object reference: null

   Note: A static method can access a static variable.

-  static final variables are constants

   A variable marked "final" means that - once initialized - it can never change. E.g.

   public static final double PI = 3.141592653589793;

   note: Constants variable names should be in all caps.

   Assigning a value to a final instance variable must be either at the time it is declared, or in the constructor.

   1) At the time you declare it:

   public class Foo {
      public static final int FOO_X = 25;
   }

   or

   2) In a static initializer in the constructor

   public class Bar {
      public static final double BAR_SIGN;
   
      static {

         BAR_SIGN = (double) Math.random();
      }

   }

-  "final" isn't just for static variables...
   
   You can use "final" to modify non-static variables too, including instance variables, local variables and even method parameter.

   A final variable means you can't change its value.

   A final method means you can't override the method.

   A final class means you can't extend the class (i.e. you can't make a subclass).

-  In summary, we should follow the following order of defining a variable:

   [access type][static or not][final or not]type variableName;

   access type could be: private, (default), "public" and "protected".

-  Wrapping a primitive

   In all version of Java prior to 5.0, you cannot put a primitive directly into a collection like AllayList and HashMap:

   To treat a primitive like an object, there is a wrapper class for every primitive type(you don't need to import them as the wrapper classes are in the java.lang package).
   Each wrapper class is named after the primitive type it wraps, but with the first letter capitalized to follow the class naming convention:

   Boolean
   Character
   Byte
   Short
   Integer
   Long
   Float
   Double

   Wrapping a value:

   int i = 288;
   Integer iWrap = new Integer(i);

   Unwrapping a value:

   int unWrapped = iWrap.intValue.

-  Autoboxing: blurring the line between primitive and object.

   The autoboxing feature added to Java 5.0 does the conversion from primitive to wrapper object automatically!

   public void doNumNewWay () {
      ArrayList<Integer> listOfNumbers = new ArrayList<Integer>(); //<---Make an ArrayList of type Integer
      listOfNumbers.add(3); //<---Although there is not a method in ArrayList, for add(int), the compiler does all the wrapping (boxing) for you. In other words, there is an Integer
                            //object stored in the ArrayList, but you get to "pretend" that the ArrayList takes ints.(You can add both ints and Integers to an ArrayList<Integer>).
      int num = listOfNumbers.get(0);//<---the compiler automatically unwraps(unboxes) the Integer object to you can assign the int value directly to 
                                     //a primitive without having to call intValue() method on the Integer object.
   }

   Beside doing wrapping and unwrapping, autobox also lets you use either a primitive or its wrapper type virtually anywhere one or the other is expected.

   1) Method arguments

   void takeNumber(Integer i) {}

   2) Return values

   int giveNumber() {
      return x;
   }

   3) Boolean expressions

   if (bool) {
      System.out.println("true");
   }

   4) Operations on numbers

   Integer i = new Integer(42);
   i++;

   or

   Integer j = new Integer(5);
   Integer k = j + 3;

   5) Assignments

   Double d = x;

   But wait! There's more! Wrappers have static utility methods too!

   6) converting a String to a primitive value is easy:

   String s = "2";
   int x = Integer.parseInt(s); //<---No problem to parse "2" into 2.
   double d = Double.parseDouble("420.24");
   boolean b = new Boolean("true").booleanValue();//<--There is no method called "Boolean.parseBoolean()". Fortunatelly, there is a Boolean constructor that takes (and parses) a String
                                                  //, and then you just get the primitive value by unwrapping it.

   But if you try this:

   String t = "two";
   int y = Integer.parseInt(t); //<---You get runtime error as Anything that can't be parse as a number will cause a Number FormatException.

-  Turning a primitive number into a String.

   There are a couple ways to turn a number into a String.

   1) concatenate the number to an existing String.

   double d = 42.5;
   String doubleString "" + d; //<---The "+" operator is overloaded in Java (the only overloaded operator) as a String concatenator. Anything added to a String becomes Stringified.

   2) Using a static method in class Double.

   double d = 42.5;
   String doubleString = Double.toString(d);

-  Number formatting

   1) Formatting a number to use commas;

   public class TestFormats {
      public static void main (String[] args) {
         String s = String.format("%, d", 1000000000); //<---The formatting instructions for how to format the second argument. Remember, there are only two arguments to this method
                                                       //here - the first comma is inside the string literal, so it isn't seperating arguments to the format method.
      }
   }

   Output:
   
   1,000,000,000

-  Formatting deconstructor...

   format("%, d", 1000000000);

   1) "%, d" ---> Use these instructions;
   2) 1000000000 ---> on this argument(s).

   The percent (%) says, "Insert argument here" (and format it using these instructions).

   When you see the % sign, think of the percent sign as a variable that represents the other argument to the method.

   format("I have %.2f bugs to fix.", 476578.09876);

   %.2f --> The "%" sign tells the formatter to insert the other method argument (the second argument to format(), the number) here, AND format it using the ".2f" character
            after the percent sign. Then the rest of the format String, "bugs to fix", is added to the final output.

   Output:

   I have 476578.10 bugs to fix.

   Adding a comma:

   format(“I have %,.2f bugs to fix.”, 476578.09876);

   Output:

   I have 476,578.10 bugs to fix.

   In summary:

   %,d means "insert commas and format the number as a decimal integer"

   %.2f means "format the number as a floating point with a precision of two decimal places."

   %,.2f means "insert commas and format the number as a floating point with a precision of two decimal places."

-  The format specifier

   A format specifier can have up to five different parts (not including the "%"). Everything in brackets [] below is optional, so only the percent(%) and the type are required.
   But the order is also mandatory, so any parts you Do use must go in this order.

   %[argument number][flags][width][.precision]type

   E.g.

   format(“%,6.1f”, 42.000);
   
   Note; We will talk about [argument number] later.

   1) type

   %d decimal
   %f float
   %x hex
   $c character

   What happens if you have more than one argument:

   int one = 20456654;
   double two = 100567890.248907;
   String s = String.format(“The rank is %,d out of %,.2f”, one, two);

   output:

   The rank is 20,456,654 out of 100,567,890.25.

-  How about dates?

   1) The complete date and type: %tc

   String.format(“%tc”, new Date());

   output:

   Sun Nov 28 14:52:41 MST 2004

   2) Just the time: %tr

   String.format(“%tr”, new Date());

   03:01:47 PM

   3) Day of the week, month and day: %tA %tB %td

   There isn't single format specifier that will do exactly what we want, so we have to combine three of them for day of the week (%tA), month(%tB), and day of the month(%td).

   Same as above, but without duplicating the arguments

   Date today = new Date();
   String.format(“%tA, %<tB %<td”,today); //<---The angle-bracket "<" is just another flag in the specifier that tells the formatter to "Use the previous argument again.", instead
                                          //you format the same argument three different ways.

-  Getting an object that extends Calendar

   How do you get an "instance" of an abstract class?

   This won't work:

   Calendar cal = new Calendar(); //<---it won't work because the constructor Calendar() is a protected method.

   Instead, use the static "getInstance()" method.

   Calendar cal = Calendar.getInstance(); //<---This is not an instance of Calendar as Calendar is an abstract class. This static method returns an instance of a concrete subclass
                                          //. Something that extends Calendar. In most of the world, and by default for most versions of Java, you will be getting back a
                                          //java.util.GregorianCalendar instance.

-  Even more Statics!...static imports.

   New to Java 5.0...The basic idea is that whenever you're using a static class, a static variable, or an enum(more on those later), you can import them, and save yourself some 
   typing. The downside to static imports is that if you are not careful - using them can make your code a lot harder to read.

   Some old-fashioned code:

   import java.lang.Math;
   class NoStatic {
      public static void main(String[] args) {
         System.out.println("sqrt " + Math.sqrt(2.0));
         System.out.println("tan " + Math.tan(2.0));
      }
   }

   Same code with static imports:

   import static java.lang.System.out; //The syntax to use when declaring static imports.
   import static java.lang.Math.*; 

   class WithStatic {
      public static void main(String[] args) {
         out.println("sqrt " + Math.sqrt(2.0));
         out.println("tan " + Math.tan(2.0));
      }
   }

Chapter 11 Risky Behavior

-  Tha JavaSound API

   JavaSound is a collection of classes and interfaces added to Java starting with version 1.3. They are not add-ons but part of the standard J2SE class library.

   1) First, we need a Sequencer

   The sequencer is the object that takes all the MIDI data and sends it to the right instruments. A sequencer can do a lot of different things, but in this book, we
   are using it strictly as a playback device. Like a CD-player on your stereo but with added features.

   import javax.sound.midi.*

   public class MusicTest1 {
      
      public void play() {
         Sequencer sequencer = MidiSystem.getSequencer();

         System.out.println("We got a sequencer");
      } //close play

      public static void main(String[] args) {
         MusicTest mt = new MusicTest1();
         mt.play();
      }
   }

   The code won't compile! The compiler says there's an "unreported exception" that must be caught or declared

   alexyu@alexyu:~/Desktop/study/Java/beatBox$ javac MusicTest1.java 
   MusicTest1.java:6: unreported exception javax.sound.midi.MidiUnavailableException；must be caught or declared to be thrown
            Sequencer sequencer = MidiSystem.getSequencer();

   
   1 errors
   
-  What happens when a method you want to call(probably in a class you didn't write) is risky?

   Methods in Java use exception to tell the calling code, "Something Bad Happened. I failed". This approach is based on you knowing that the method you're calling is risky.
   (e.g. that the method might generate an exception), so that you can write code to deal with that possibility.

   How do you know if a method throws an exception? You find a throws clauses in the risky method's declaration. You can read the Java API to understand under what circumstances, 
   Exceptions can happen.

   If you wrap the risky code in something called a "try/catch", the compiler will relax. A "try/catch" block tells the compiler that you know an exceptional thing could happen
   in the method you're calling, and that you're prepared to handle it. The compiler doesn't care how you handle it; it cares only that you say you're taking care of it.

   import javax.sound.midi.*

      public class MusicTest1 {
         
         public void play() {
         
            try {
            Sequencer sequencer = MidiSystem.getSequencer();
            System.out.println("We got a sequencer");
            
         } catch (MidiUnavailableException ex) {

            System.out.println("Bummer");
            
         }

         public static void main(String[] args) {
            MusicTest mt = new MusicTest1();
            mt.play();
         }
      }

-  An exception is an object...of type Exception.

   Remember from your polymorphism chapters that an object of type Exception can be an instance of any subclass of Exception. Because an Exception is an object, what you catch
   is an object. If the following code, the catch arguments is declared as type Exception, and the parameter reference variable is ex

   try {
      // do risky thing
   } catch (Exception ex) {  //<---This is just like declaring a method argument
      //try to recover   //<---The code only runs if an Exception is thrown.
   }

-  If it is your code that catches the exception, then whose code throw it?

          
            ---------(2)--------
            |                  |
            v                  |
   Your code ---(1)----> class with a risky method 

   1) Call risky method

   When somebody write code that could throw an exception, they must declare the exception.

                              |--------This method MUST tell the world (by declaring) that it throws a BadException
                              v      
   public void takeRisk() throws BadException { 
      if (abadonAllHope) {
         throw new BadException(); //<---Create a new Exception and throw it
      }
      
   }   

   2) throws an exception back

   public void crossFingers() {
      try {
         anObject.takeRisk();
      } catch (BadException ex) {
         System.out.println("Aaargh!");
         ex.printStackTrace(); //<---If you can't recover from the exception, at LEAST get a stack trace using the printStackTrack() method that all exceptions inherit.
      }
   }

-  The compiler checks for everything except RunTimeExceptions.

   Exceptions that are not subclass of RuntimeException are checked for by the compiler. They're called "checked exceptions".

                     Exception
                           |
                           ^
         ----------------------------------------
         |                 |                    |
      IOEXception    InterruptException   RuntimeException (RuntimeExceptions are NOT checked by the compiler. They've known as (big surprise here) "unchecked exceptions")
                                                      |--------------|
                                                      ^              ^
                                           ClassCastException NullPointerException    

   But why RuntimeExceptions the compiler doesn't care about those runtime exceptions? Becasue most RuntimeExceptions come from a problem in your code logic，rather than a
   condition that fails at runtime in ways that you cannot predict or prevent. You cannot guarantee the server is up. You cannot guarantee the server is up. But you can make
   sure you code doesn't index off the end of the array.
   
-  Flow control in try/catch blocks

   try {
      Foo f = x.doRiskyThing();
      int b = f.getNum(); //<---------------------It doRishkyThing() failed, the rest of the try block never runs, which is a good thing as the rest depends on the success of 
                          //the call to doRiskyThing().
   } catch (Exception ex) {
      System.out.println("failed");
   }
   System.out.println("We made it!");

-  Finally: for the things you want to do no matter what.

   A finally block is where you put code that must run regardless of an exception.

   try {
      turnOvenOn();
   } catch (BakingException ex) {
      ex.printStackTrace();
   } finally {
      turnOvenOff();
   }

   Without finally, you have to put the turnOverOff() in both the try and the catch becasue you have to turn off the oven no matter what. A finally block lets you put all
   your important cleanup code in one place instead of duplicating the code.

   Note: 

   If the try block fails (an exception) --> catch block runs ---> finally block runs

   If the try block succeeds -> skip catch block ---> finally block runs

   If the try or catch block has a return statement, finally will still run!

-  A method can throw multiple exceptions

   public class Laundry {
      public void doLaundry() throws PantsException, LingerieException {
      // code that could throw either exception.
      }
   }

   public class Foo {
      public void go() {
         Laundry laundry = new Laundry();
         
         try {
            laundry.doLaundry();
         } catch (PantsException) {
            //recovery code
         } catch (LingerieException) {
            //recovery code
         }
      }
   }

-  Exceptions are polymorphic

   Exceptions are objects that can be thrown. All exceptions have "Exception" as a superclass. Becasue you CAN catch everything with one big super polymorphic catch, doesn't alwasy
   mean you SHOULD.

   try {
      laundry.doLaundry();
   } catch (Exception ex) {
      //recovery code...   //<---Recovery from what? This catch block will catch ANY and all exceptions, so you won't automatically know what went wrong.
   }

   Instead, write a different catch block for each exception that you need to handle uniquely. Multiple catch blocks must be ordered from smallest to biggest
   
                     ClothingException

   PantsException    LingerieException    ShirtException    UniformException
        
                                  TeeShirtException DressShirtException

   try {
      laundry.doLaundry ();
   
   } catch (TeeShirtException tex) {
      //recovery from TeeShirtException
   } catch (LingerieException tex) {
      //recovery from LingerieException
   } catch (ClothingException tex) {
      //recovery from all others
   }

-  When you don't want to handle an exception...Just duck it by clearing it.

-  Exception Rules

   1) You cannot have a catch or finally without a try.
   2) You cannot put code between the try and the catch.
   3) A try MUST be followed by either a catch or a finally.
   4) A try with only a finally (no catch) must still declare the exception.

-  Making actual sound

   1) The thing that plays the music;
   2) The music to be played...a song;
   3) The part of the Sequence that holds the actual information;
   4) The actual music information; note to play, how long, etc...

   
                  plays                         has                  holds
   Sequencer   ----------->   Sequence    -------------> Track    -------------->   MidiEvents...

   Note: A MIDI event is a message that the Sequencer can understand such as play Middle C, play this fast and play this hard...

-  Making a MidiEvent (song data)

   Skip it for now.

Chapter 12 A very Graphic story

-  Skip it for now

Chapter 13 Work on your Swing

-  Skip it for now

Chapter 14 Saving Objects

-  Skip it for now

Chapter 15 Making a connection

-  Skip it for now

Chapter 16 Data Structure

-  ArrayList has a lot of methods, but there is nothing can do sorting. ArrayList is not the only collection. Some of the key collection classes are:

   -  TreeSet

      Keeps the elements sorted and prevents duplicates.

   -  HashMap

      Let's you store and access elements as name/value pairs.

   -  LinkedList

      Designed to give better performance when you insert or delete elements from the middle of the collection.

   -  HashSet

      Prevents duplicates in the collection, and given an element, can find that element in the collection quickly.

   -  LinkedHashMap

      Like a regular HashMap except it can remember then order in which elements (name/value pairs) were inserted, or it can be configured to remember the order in which elements
      were last accessed.
      
-  You could use a TreeSet...or you could use the Collections.sort() method.

   TreeSet: If you put all the strings into a TreeSet instead of an ArrayList, the Strings would automatically land in the right place, alphbetically sorted. There is a trade-off:
   every time you insert into a TreeSet, the TreeSet has to take time to figure out where in the tree the new element must go.

   Collection.sort(): The Collection.sort() method sorts a list of Strings alphabetically. E.g.

   import java.util.*;
   import java.io.*;

   public class Jukebox1 {

      ArrayList <String> songList = new ArrayList<String>();

      public static void main(String[] args) {
         new Jukebox1().go();
      }
   
      public void go() {
         getSongs();
         System.out.println(songList);
         Collection.sort(songList); //<---Call the static Collections sort() method.
         System.out.println(songList);
      }

   ...
   }

-  But if you need Song objects not just simple Strings to store in the list?

   class Song {
      String title;
      String artist;
      String rating;
      String bpm;
   }

   Thus we need to change thd code a littie bit:

   ...
   public class Jukebox3 {
      ArrayList<Song> songList = new ArrayList<Song>();
   }

   Unfortunatelly, it won't compile

   symbol : method sort(java.util.ArrayList<Song>)
   location: class java.util.Collections
                     Collections.sort(songList);
                                ^

   1 error

-  Generic

   From the Java API docs:

   public static <T extends Comparable<? super T>> void sort(List<T> list)

   Why the definition of sort is so strange...this is because the sort() method (along with other things in the whole collection framework in Java) makes heavy use of generics.
   Anytime you see something with angle brackets in Java source code or documentations, it means generics - a feature added to Java 5.0.

   Generics means more type-safety. The main point of generics is to let you write type-safe collections. In other words, code that makes the compiler stop you from putting a Dog
   into a list of Ducks.

   Without generics:

   Objects go IN as a reference of type of Object and OUT as a reference to type of Object.

   With generics:

   Objects go IN as a reference to only Fish (for example) objects

   ArrayList<Fish>
   
   and come OUT as a reference of type Fish. With Generics now, you can put only Fish Objects in the ArrayList<FISH>, so the objects come out as  Fish references.

   Of the dozens of things you could learn about generics, there are really three things that matter to most programmers:

   1) Creating instances of generified classes (like ArrayList)

   You have to tell the type of objects you'll allow in the list, just as you do with plain old arrays. 

   new ArrayList<Song>();

   2) Declaring and assigning variables of generic types

   List<Song> songList = new ArrayList<Song>();

   3) Declaring (and involking) methods that take generic types

   void foo(List<Song> list) 
      
   x.foo(songList)

   void foo(List<Song> list)
   
   x.foo(songList)

-  Using generic CLASSES

   A generic class: it means that the class declaration includes a type parameter.

   A generic method: it means that the method declaration uses a type parameter in its signature.

   You can use type parameters in a method in several different ways:

   1) Using a type parameter defined in the class declaration

   public class ArrayList<E> extends AbstractList<E> ... {
      public boolean add (E o) //<-- You can use the "E" here ONLY because it's already been defined as part of the class.
   }

   The type declared in the method argument is essentially replaced with the type you use when you instantiate the class.

   2) Using a type parameter that was NOT defined in the class declaration

   public <T extends Animal> void takeThing(ArrayList<T> list)

   If the class itself doesn't use a type parameter, you can still specify one for a method, by declaring it in a really unusual (but available) space - before the return type.
   This method says that T can be "any type of Animal".

-  Revisiting the sort() method

   The sort() method can take only lists of Comparable objects.

   Song is not a subtype Comparable, so you cannot use sort() the list of Songs.

   public static <T extends Comparable<? super T>> void sort(List<T> list)   
                           |                |                     |
                           |                |                     |---------> You can only pass in only a List(or subtype of List, like ArrayList that uses parameterized type that
                           |                |                                 ("extends Comparable" )
                           |                |
                           |                |-----> it means the type parameter for Comparable must be of type T or one of T's supertypes(??).
                           |
                           |
                           -----> This says "Whatever" 'T' is must be of type Comparable

   But the docs for String say String doesn't EXTEND Comparable -- it IMPLEMENTS it. Comparable is an interface. So it's nonsense to say <T extends Comparable>:

   public final class String extends Object implements Serializable, Comparable<String>, CharSequence

   In generics, "extends" means "extends or implements".

-  Here is the detail of the Comparable interface

   java.lang.Comparable

   public interface Comparable<T> {
      int compareTo(T o);
   }

   There is only one method to implement and it is called compareTo:

   Returns:

   Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than 
   the specified object.

   Your job now is to implement compareTo for the class Song to decide what mekes one song greater than another.

   Thus we have the new, comparable Song class:

   class Song implements Comparable<Song> {
      String title;
      String artist;
      String rating;
      String bpm;
   
      public int compareTo(Song s) {
         return title.compareTo(s.getTitle()); //<---Very simple!
      }

-  There's new problem - if you want two different views of the song list, one by song title and one by artist.

   There is another sort() method in the Class Collections.

   public static <T> void sort(List<T> list, Comparator<? super T> c)

-  using a custom Comparator

   An element in a list can compare itself to another of its own type in only one way, using its compareTo() method. But a Comparator is external to the element type you're comparing
   - it's a seperate class. You can make as many of these as you like! E.g. ArtistComparator, BPMComparator...

   The sort() method that takes a Comparator will use the Comparator instead of the element's own compareTo()method, when it puts the elements in order. In other words, if your sort()
   method gets a Comparator, it won't even call the compareTo method of the elements in the list. The sort() method will instead invoke the compare() method on the Comparator.

-  Updating the Jukebox to use a Comparator

   ...
   public class JukeBox5 {
      ArrayList<Song> songList = new ArrayList<Song>();
      public static void main(String[] args) {
         new Jukebox5.go();
      }

      class ArtistCompare implements Comparator<Song> {
         public int compare(Song one, Song two) {
            return one.getArtist().compareTo(two.getArtist());//<--We're letting the String variable (for artist do the actual comparision, since Strings already know how to 
                                                              //alphbetize themselves)
         }

      public void go() {
         getSongs();
         System.out.println(songList);
         Collections.sort(songList);
         System.out.println(songList);

         ArtistCompare artistCompare = new ArtistCompare(); //<---Make an instance of the Comparator inner class
         Collections.sort(songList, artistCompare); //<---Invoke sort(), passing it the list and a reference to the new custom Comparator object.
         ...
      }
   }

-  We can use "Set" instead of "List" to resolve the dublicate elements stored in a list.

   1) LIST

   Collections that know about index position. Lists know where something is in the list. You can have more than one element referencing the same object.

   2) SET

   collections that do not allow duplicates. Sets know whether something is already in the collection. You can never have more than one element referencing
   the same object (or more than one element referencing two objects that are considered equal—we’ll look at what object equality means in a moment).

   3）MAP

   When finding something by key matters

   Collections that use key-value pairs. Maps know the value associated with a given key. You can have two keys that reference the same value, but you cannot have
   dublicate keys. Although keys are typically String names (so that you can make name/value property lists, for example), a key can be any object.

-  Using a HashSet instead of ArrayList.

   ...public void go() {
      getSongs();
      System.out.println(songList);
      Collections.sort(songList);
      System.out.println(songList);

      HashSet<Song> songSet = new HashSet<Song>();
      songSet.addAll(songList);//<---HashSet has a simple addAll() method that can take another collection and use it to populate the HashSet. It is the same as if we
                               //added each some one at a time(except much simpler).
      System.out.println(songList);
   }  

   But there are still duplicate elements in above method using HashSet. Why?

-  What makes two objects equal?

   This brings up a key issue: reference equality vs. object equality.

   1) Reference equality

   Two references, one object on the heap

   Two references that refer to the same object on the heap are equal. If you call hashCode() method on both references you will get the same result.

   2) Object equality

   Two references, two objects on the heap, but the objects are considered meaningfully equilvalent.

   If you want to treat two different Song objects as equal (for example if you needed that two songs are the same if you they have matching title variables), you must
   override both the hashCode() and equals() methods inherited from class Object.

   If you don't override hashCode(), the default behavior (from Object ) is to give each object a unique hashcode value. Also, you must override equals() so that if you call
   it on either object, passing in the other object, always return true. 

   if (foo.equals(bar) && foo.hashCode() == bar.hashCode()) {
      //both references are referring to either a single object, or to two objects that are equal.
   }

-  The Song class with overridden

   class Song implements Comparable<Song>{
      String title;
      String artist;
      String rating;
      String bpm;

      public boolean equals(Object aSong) { 
         Song s = (Song) aSong;
         return getTitle().equals(s.getTitle()); //<---The great news is that title is a String, and Strings have an overriden equals() method. So all we have to do is to ask
                                                 // one title if it's equal to the other song's title.
      }

      public int hashCode() {
         return title.hashCode(); //<---Same deal here...the String class has an overriden hashCode method, so you can just return the result of calling hashCode() on the title.
                                  //Notice how hashCode() and equals() are using the SAME instance variable.
      }

      Java Object Law For HashCode() and equals()

      The API docs for class Object state the rules you MUST follow:

      1) If two objects are equal, they MUST have matching hashcodes.

      2) If two objects are equal, calling equals on either object MUST return true. In other words, if (a.equals(b)) then (b.equals(a)).

      3) If two objects have the same hashcode value, they are NOT required to be equal. But if they're equal, they MUST have the same hashcode value.

      4) So, if you override equals(), you MUST override hashCode().

      5) The default behavior of hashCode() is to generate a unique integer for each object on the heap. So if you don't override hashCode() in a class, no two objects of that type
         can EVER be considered equal.

      6) The default behavior of equals() is do do an == comparision. In other words, to test whether the two references refer to a single object on the heap. So if you don't override
         equals() in a class, no two objects can EVER be considered equal since references to two different objects will always contain a different bit pattern.

      7) a.equals(b) must also mean that a.hashCode() == b.hashCode().
      
      8) But a.hashCode() == b.hashCode() does NOT have to mean a.equals(b). (??)

-  And if we want the set to stay sorted, we've got TreeSet.

   TreeSet is similar to Hashset but it also keeps the list sorted.

   public void go() {
      getSong();
      System.out.println(songList);
      Collections.sort(songList);
      System.out.println(songList);

      TreeSet<Song> songSet = new TreeSet<Song>();
      songSet.addAll(songList);//<---Calling the addAll method.
      System.out.println(songList);
   }

   import java.util.*;

   public class TestTree {
      public static void main(String[] args) {
         new TestTree().go();
      }

      public void go() {
         Book b1 = new Book("How Cats Work");
         Book b2 = new Book("Remix your Body");
         Book b3 = new Book("Finding Emo");

         TreeSet<Book> tree = new TreeSet<Book>();
         tree.add(b1);
         tree.add(b2);
         tree.add(b3);
         System.out.println(tree);
      }
   }

   class Book implements Comparable<Book>{
      String title;
      public Book(String t) {
         title = t;
      }

      public int compareTo(Book b) {
         return title.compareTo(b.title);
      }
   }

   The above program won't compile! It is simply becasue the elements in the list must be of a type that implements Comparable. 

   class Book implements Comparable {
      String title;
      public Book(String t) {
         title = t;
      }
      
      public int compareTo(Object b) {
         Book book = (Book) b;
         return (title.compareTo(book.title));
      }
   }
   
   Or you use the TreeSet's overloaded constructor that takes a Comparator:

   public class BookCompare implements Comparetor<Book> {
      public int compare(Book one, Book two) {
         return (one.title.compareTo(two.title));
      }
   }

   class Test {
      public void go() {
         Book b1 = new Book("How Cats Work");
         Book b2 = new Book("Remix your Body");
         Book b3 = new Book("Finding Emo");
         BookCompare bCompare = new BookCompare();//Create a new BookCompare instance
         TreeSet<Book> tree = new TreeSet<Book>(bCompare);
         tree.add(new Book("How Cats Work"));
         tree.add(new Book("Remix your Body"));
         tree.add(new Book("Finding Emo"));
         System.out.println(tree);
      }  
   }

-  We've seen Lists and Sets, now we'll use a Map.

   Sometimes a Map is the best. Each element in a Map is actually TWO objects - a key and a value. You can have dulpicate values, but NOT duplicate keys.

-  Finally, back to generics.

   If you declare a method to take ArrayList<Animal> it can take ONLY an ArrayList<Animal>, not ArrayList<Dog> or ArrayList<Cat>.

   But why that doesn't happen in Array?

   Because Array types are checked again at runtime, but collection type checks happen only wheny when you compile. You will get store exception when you add a new dog object 
   into a Animal array.

-  Widecards to the rescue

   It looks unusual, but there is a way to create a method argument that can accept an ArrayList of any Animal subtype. The simplest way is to use a widecard - The
   simplest way is to use a widecard. 

   public void takeAnimals(ArrayList<? extends Animal> animals) { //<---the keyword "extends" here means either extends OR implements depending on the type. So if you want to tak
      for (Animal a : animals) {                                  //an ArrayList of types that implement the Pet interface, you'd declare it as ArrayList<? extends Pet>
         a.eat();
      }
   }

   When you use a widecard in your method argument, the compiler will STOP you from doing anything that could hurt the list referenced by the method parameter.

   You still can invoke methods on the elements in the list, but you cannot add elements to the list. In other words, you can do things with the list elements, but you can't 
   put new things in the list. So you're safe at runtime, because the compiler won't let you do anything that might be horrible at runtime.

   So this is OK inside takeAnimals();

   for (Animal a: animals) {
      a.eat();
   }

   But This would not compile:

   animals.add(new Cat());

-  Alternative syntax for doing the same thing:

   The type parameter can also be declared before the return type. The results are the same.

   This:

   public <T extends Animal> void takeThing(ArrayList <T> list)

   Does the same thing as this:

   public void takeThing(ArrayList<? extends Animal> list)

   If they both do the same thing, why would you use one over the other?

   It is all depends on whether you want to use "T" some-where else. For example, what if you want the method to have two arguments - both of which are lists of a type
   that extend Animal? In this case, it's more efficient to just declare the type parameter once:

   public <T extends Animal> void takeThing(ArrayList<T> one, ArrayList<T> two)

   instead of typing:

   public void takeThing(ArrayList<? extends Animal> one, ArrayList<? extends Animal> two)

Chapter 17 Release Code

-  Skip it for now

Chapter 18 Distriburted Computing

-  Methods are always between two objects on the same heap. What if you want to invoke a method on an object running on another machine?

-  You want to cause a method invocation on a remote object (i.e. an object in a heap somewhere else.) but with code that lets
   you pretend that you are invoking a method on a local object. That's what RMI (Remote Method Invocation) gives you!

-  A design for remote methdo calls:

   Create four things: server, client, server helper, client helper

   1) The server app is the remote service that has an object with the method that the client wants to invoke.

   2) The client/server 'helpers'. They will handle all the low-level networking and I/O details so your client and service
      can pretend like they're in the same heap.

-  The role of the 'helpers'

   The client calls a method on the client helper, as if the client helper were the actual service. The client helper is a proxy
   for the Real Thing.



   

   
   

   

   

   
   
   

   



Questions

1) Is it ture that the name of a public class must be the same as the file name?

2) What is an iterator/

   An iterator enables you cycle through a collection, obtaining or removing elements. Listiterator extends iterator to allow bidirectional traversal of a list, and the modification
   of elements. In general, to use an iterator to cycle through the contents of a collection, follow these steps:

   -  Obtain an iterator to the start of the collection by calling the collections's iterator() method. 

   -  Set up a loop that makes a call to hashNext(). Have the loop iterate as long as hashNext() returns true.

   -  Within the loop, obtain each element by calling next().

3) What is "<? super T>" mean?

   public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        int srcSize = src.size();
        if (srcSize > dest.size())
            throw new IndexOutOfBoundsException("Source does not fit in dest");

        if (srcSize < COPY_THRESHOLD ||
            (src instanceof RandomAccess && dest instanceof RandomAccess)) {
            for (int i=0; i<srcSize; i++)
                dest.set(i, src.get(i));
        } else {
            ListIterator<? super T> di=dest.listIterator();
            ListIterator<? extends T> si=src.listIterator();
            for (int i=0; i<srcSize; i++) {
                di.next();
                di.set(si.next());
            }
        }
    }

4) 
   public void takeThing(ArrayList<? extends Animal>)
