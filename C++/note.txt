-  Deconstructors (c++) (resolved)

   A destructor is called for a class object when that object passes 
   out of scope or is explicitly deleted.

-  Operator delete (resolved)

   1) ordinary delete

   Deallocates the memory block pointer pointed by ptr(if not null)

-  How to use Class template scoped_lock??

-  How to use std::map??

-  How the "const" is used for here??

   T value() const { return iValue; }

-  How does the c++ namespace work??

-  How can I create a hash map with boost library?? probably using multimap??

   <string, <&void>, bool>

   string:  the name of the function
   &void:   the function pointer
   bool:    the running result

-   Local Classes

    A local class is declared within a function. Declarations in a local class can only use type names, enumerations, static variables from the enclosing scope.
    as well as external variables and functions.

    int x;                         // global variable
    void f()                       // function definition
    {
        static int y;            // static variable y can be used by
                                   // local class
        int x;                   // auto variable x cannot be used by
                                   // local class
        extern int g();          // extern function g can be used by
                                   // local class

        class local              // local class
        {
                int g() { return x; }      // error, local variable x
                                           // cannot be used by g
                int h() { return y; }      // valid,static variable y
                int k() { return ::x; }    // valid, global x
                int l() { return g(); }    // valid, extern function g
        };
    }

    int main()
    {
          local* z;                // error: the class local is not visible
          // ...}
    
    Member functions of a local class have to be defined within their class definition, if they are defined at all. As a result, member functions of a local class 
    are inline functions. Like all member functions, those defined within the scope of a local class do not need the keyword inline.

    A local class cannot have static data members. In the following example, an attempt to define a static member of a local class causes an error:

    void f()
    {
        class local
        {
           int f();              // error, local class has noninline
                                 // member function
           int g() {return 0;}   // valid, inline member function
           static int a;         // error, static is not allowed for
                                 // local class
           int b;                // valid, nonstatic variable
        };
    }
    //      . . .

-   What is internal namespace??

-   Is it true that a new class's static variables are not accessible by override functions in the same new class??

-   The usage of static members, static functions, static member functions, static variables.

-   Shared_Pointer

-   What is a copy constructor

    A copy constructor is a special constructor for a class/struct that is
    used to make a copy of an existing instance. According to the C++
    standard, the copy constructor for MyClass must have one of the
    following signatures:

    MyClass( const MyClass& other );
    MyClass( MyClass& other );
    MyClass( volatile const MyClass& other );
    MyClass( volatile MyClass& other );

    Note that none of the following constructors, despite the fact that
    they could do the same thing as a copy constructor, are copy
    constructors:

    MyClass( MyClass* other );
    MyClass( const MyClass* other );

    or my personal favorite way to create an infinite loop in C++

    MyClass( MyClass& other );

    why this is better than this: MyClass ( MyClass other )(??);

    -   When do you need to write a copy constructor??

        First, you should understand that if you do not declare a copy
        constructor, the compiler gives you one implicitly. The implicit
        copy constructor does a member-wise copy of the source object.
        For example, given the class:

        class MyClass {
            int x;
            char c;
            std::string s;
        };

        the compiler-provided copy constructor is exactly equivalent to:

        MyClass::MyClass( const MyClass& other ) :
           x( other.x ), c( other.c ), s( other.s )
        {}

        In many cases, this is sufficient. However, there are certain
        circumstances where the member-wise copy version is not good enough.
        By far, the most common reason the default copy constructor is not
        sufficient is because the object contains raw pointers and you need
        to take a "deep" copy of the pointer. That is, you don't want to 
        copy the pointer itself; rather you want to copy what the pointer
        points to. Why do you need to take "deep" copies? This is 
        typically because the instance owns the pointer; that is, the
        instance is responsible for calling delete on the pointer at some
        point (probably the destructor). If two objects end up calling
        delete on the same non-NULL pointer, heap corruption results.

        Rarely you will come across a class that does not contain raw
        pointers yet the default copy constructor is not sufficient.
        An example of this is when you have a reference-counted object(??).
        boost::shared_ptr<> is example.

        When passing parameters by reference to functions or constructors, be very
        careful about const correctness. Pass by non-const reference ONLY if
        the function will modify the parameter and it is the intent to change
        the caller's copy of the data, otherwise pass by const reference.

-   Non-const references cannot bind to temporary objects(??)

    There is a small clause in the C++ standard
    that says that non-const references cannot bind to temporary objects.
    A temporary object is an instance of an object that does not have a
    variable name. For example:
 
    std::string( "Hello world" );


    is a temporary, because we have not given it a variable name. This
    is not a temporary:

     
    std::string s( "Hello world" );

    because the object's name is s.

    What is the practical implication of all this? Consider the following:

    // Improperly declared function:  parameter should be const reference:
    void print_me_bad( std::string& s ) {
        std::cout << s << std::endl;
    }

    // Properly declared function: function has no intent to modify s:
    void print_me_good( const std::string& s ) {
        std::cout << s << std::endl;
    }

    std::string hello( "Hello" );

    print_me_bad( hello );  // Compiles ok; hello is not a temporary
    print_me_bad( std::string( "World" ) );  // Compile error; temporary object
    print_me_bad( "!" ); // Compile error; compiler wants to construct temporary
                         // std::string from const char*

    print_me_good( hello ); // Compiles ok
    print_me_good( std::string( "World" ) ); // Compiles ok
    print_me_good( "!" ); // Compiles ok 

    Many of the STL containers and algorithms require that an object
    be copyable. Typically, this means that you need to have the
    copy constructor that takes a const reference, for the above
    reasons.

-   
