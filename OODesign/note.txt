Chpater 1 Intro to Design Patterns

-  Design Principle 1
   
   Identify the aspects of your application that vary
   and seperate them from what stays the same.  

-  Design Principle 2

   Program to an interface, not an implementation.

-  Design Principle 3

   Favor composition over inheritance (HAS-A can be better than Is-A)

   Composition: put two classes together. Creating systems using composition
   gives you a lot more flexibility. Not only does it let you encapsulate a
   family of algorithms into their own set of classes, but it also lets you
   change behavior at run time. As long as the object you're composing with
   implements the correct behavior interface. Composition is used in many design
   patterns and you'll see a lot more about its advantage and disadvantage throughout
   the book.

-  The power of shared pattern vocabulary(??)

Chapter 2 Keeping your objects in the know.

-  Publishers + Subscribers = Observer Pattern

   -  The subject and observers define the one-to-many relationship. The observers are depedent
      on the subject such that when the subject's state chagnes, the observers get notified. 

      The Observer Pattern defined:

      The class diagram:

                              Observers
      <<interface>>        --------------->  <<interface>>
         Subject                                Observer
      registerObserver()                        update()
      removeObserver()
      notifyObservers()

      
                              subject
      ConcreteSubject      <--------------   ConcreteObserver
      registerObserver                         update()
      removeObserver                          //Other Observer specific methods
      notifyObservers
      getState()
      setState()

      Note: the arrow ------> means one-to-many relationship
            the arrow <------ means many-to-one relationship.

   -  Design Principle 4: Strive for loosely coupled designs between objects that interact. The power of Loose Coupling

      When two objects are loosely coupled, they can interact, but have little knowledge of each other.
      
      The Observer Pattern provides an object design where subjects and observers are loosely coupled. Why?

      1. The only thing the subject knows about an observer is that it implements a certain interface.
      2. We can add new observers at any time.
      3. We never need to modify the subject to add new types of observers.
      4. We can resue subjects or observers independently of each other.
      5. Changes to either the subject or an observer will not affect the other.

      Loosely coupled designs allow us to build flexible OO systems that can handle changes between they minimize
      the interdependency between objects.

   -  Using Java's built-in Observer Pattern
      
      Java already has built-in support in several of its APIs. The most general is the Observer interface and the Observable class in
      the java.util.package.

      1. For an Object to become an observer

      As usual, implement the Observer interface (this time the java.util.Observer interface) and call addObserver() on any Observable object. 
      Likewise, to remove yourself as an observer just call deleteObserver();

      2. For the Observable to send notifications

      2.1   You first must call the setChanged() method to signify that the state has changed in your object.

      2.2   Then call one of the two notifyObservers() methods:

            either notifyObservers() or notifyObservers(Object arg) <---This version takes an arbitrary data object that gets passed to each Observer when it is notified.

   -  For an Observer to receive notifications

      It implements the update method, as before, but the signature of the method is a bit different.

      update(Observer o, Object arg)

      If you want to "push" data to the observers, you can pass the data as a data object to the notifyObserver(arg) method. If not, then the Observer ahs to "pull" the data
      it wants from the Observable object passed to it.

   -  The setChanged() method is used to signify that the state has changed and that notifyObservers(), when it is called, should update its observers. 

      setChanged() {
         changed = true;
      }

      notifyObservers(Object arg) {
         if (changed) {
            for every observer on the list {
               call update(this, arg)
            }
            changed = false;
         }
      }

      notifyObservers() {
         notifyObservers(null);
      }

      Why is the necessary? The setChanged() method is meant to give you more flexibility in how you update observers by allowing you to optimize the notifications. E.g.

      If the temperature readings were constantly fluctuating, we might want to send out notifications only if the temperature changes more than half of a degree and we cann
      could call setChanged() only after that. If the functionality is useful to you, you may also want to use the clearChanged() method, which sets the changed state back
      to false, and the hasChanged() method, which tells you the current state of the changed flag.

   -  The darkside of java.util.Observable

      1. Observable is a class

         You have to subclass it. That means you can't add on the Observable behavior to an existing class that already extends another supclass(Java doesn't support multiple
         inheritance). That limits its resue potential. 

      2. Observable protects crucial methods

         The setChanged() method is protected. That means you can't call setChanged() unless you've subclassed Observable. That means you can't even create an instance of the
         Observable class and compose it with your own objects, you have to subclass. The design violates a second design principle here...favor composition over inheritance.

Chapter 3: Decorating Objects.

   -  Design Principle 5; Classes should be open for extension, but closed for modification.

   -  The Decorator Pattern defined

      -  Decorators have the same supertypes as the objects they decorate.

      -  You can use one or more decorators to wrap an object.
      
      -  Given the decorator has the same supertype as the object it decorates, we can pass around a decorated object in place of the original (wrapped) object. Key Point!

      -  Objects can be decorated at anytime, so we can decorate objects dynamically at runtime with as many decorators as we like.

      The Decorator Pattern: attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.
      
   -  Real World Decorators: Java I/O

      Java I/O isn't so different from the StarBuzz design. It also points out the downsides of the Decorator Pattern: designs using this pattern often result in a large number
      of small classes that can be overwhelming to a developer trying to use the Decorator-based API. 

Chapter 4: Baking with OO Goodness
      
   -  Declaring a factory method

      A factory method handles object creation and encapsulates it in a subclass. This decouples the client code in the 
      superclass from the object creation code in the subclass.
      
      A factory method isolates the clients (the code in the superclass, like orderPizza()) from knowing what kind of
      concrete Product is actually created:

      abstract Product factoryMethod(String type)

      Note:
      abstract:   A factory method is abstract so the subclasses are counted on to handle object creation.
      Product:    A factory method returns a Product that is typically used within methods defined in the superclass.

   -  An example

      PizzaStore
         (abstract)createPizza()
         orderPizza()

      NYPizzaStore extends PizzaStore
         createPizza()
   
      ChicagoPizzaStore extends PizzaStore
         createPizza()

      -  Classes that produce products are called concrete creator(NYPizzaStore and ChicagoPizzaStore)
      -  The createPizza() method is our factory method. It produces products.

   -  Factory Method Pattern defined

      It's time to roll out the official definition of the Factory Method Pattern:

      The Factory Method Pattern defines an interface for creating an object, but lets subclass decide which class to instantiate. Factory Method lets a class
      defer instantiation to subclasses.

      (abstract)Creator
         (abstract)factoryMethod()
         anOperation()

      ^
      |
      |
      ConcreteCreator ------> ConcreteProduct --------->(abstract)Product //All the products must implement the same interfac
         factoryMethod           //The ConcreteProduct is responsible for creating one or more concrete products. It is the only class that has the knowledge of how to create
                                 //these products

   -  The Dependency Inversion Principle

      Design Principle 6: Depend upon abstractions. Do not depend upon concrete classes.

      A "high-level" component is a class with behavior defined in terms of other "low-level" components. For example, PizzaStore is a high-level component because
      its behavior is defined in terms of pizzas - it creates all the different pizza objects, prepares, bakes, cuts and boxes them, while the pizzas it uses are
      low-level components.

      Why is called Dependency Inversion? Because now the low-level components depend on a higher level abstraction.

   -  A few guidelines to help you follow the principle:

      The following guidelines can help you avoid OO designs that violate the Dependency Inversion Principle:

      1. No variable should hold a reference to a concrete class. -> Use a factory to get around that.
      2. No class should derive from a concrete class.a -> Derive from an abstraction, like an interface or abstract class. 
      3. No method should override an implemented method of any of its base classes.

      These guidelines are built upon the fact that the class is likely to change in the future. Some Classes, e.g. the String class, are unliklely to change do not HAVE to
      follow the above guidelines.

   -  Abstract Factory Pattern defined.

      We are adding yet another pattern to our pattern family, one that lets us create families of products. 

      The Abstract Factory Pattern: provides an interface for creating families of related dependent objects without specifying their concrete classes. We've certainly seen that
      Abstract Factory allows a client to use an abstract interface to create a set of related products without knowing (or caring) about the concrete products that are actually
      produced.

   -  Method and Abstract Factory compared(What are the difference between them??).

      Abstract Factory: Provide an interface for creating families of related or depedent on objects without specifying their concrete classes.

      Factory Method: Define an interface for creating an object, but let subclasses decide which class to instantiate. 

Chapter 5 One of a Kind Objects.

   -  There are many objects we only need one of: thread pools, caches, dialog boxes, objects that handle preferences and registry settings, objects used for logging, and
      objects that act as device drivers to devices like printers and graphics cards. In fact, for many of these types of objects, if we were to instantiate more than one
      we'd run into all sorts of problems like incorrect program behavior, overuse of resources, or inconsistent results.

   -  In many ways, the Singleton Pattern is a convention for ensuring one and only one object is instantiated for a given class. 

   -  The concise definition of the pattern:

      The Singleton Pattern: ensures a class has only one instance, and provides a global point of access to it.

      The diagram:

      Singleton:

      static uniqueInstance
      //Other useful Singleton

      static getInstance()
      //Other useful Singleton methods

   -  For most Java applications, we obviously need to ensure that the Singleton work in the presence of multiple threads. But it looks fairly expensive to synchronize getInstance()
      method, so what do we do? We have a few options:

      1. Do nothing if the performance of getInstance() isn't critical to your application. 
   
         Just keep in mind that synchronizing a method can decrease performance by a factor of 100(??), so if a high traffic part of your code begins using getInstance(), you must
         have to reconsider.

      2. Move to an eagerly created instance rather than a lazily created one.

         If your application always creates and uses an instance of the Singleton or the overhead of creation and runtime aspects of the Singleton are not onerous(??).

         public class Singleton {
            private static singleton uniqueInstance = new Singleton(); //Go ahead and create an instance of Singleton in a static initializer. This code is guaranteed to be thread safe!

            private Singleton() {}

            public static Singleton getInstance() {
               return uniqueInstance;//We have already got an instance, so just return it.
            }
         }

         Using this method, we relay on the JVM to create the unique instance of the Singleton when the class is loaded. The JVM guarantees that the instance will be created before
         any thread accesses the static uniqueInstance variable.

      3. Use "double-checked locking" to reduce the use of synchronization in getInstance()

         With double-checked locking, we first check to see if an instance is created, and if not, THEN we synchronize. This way, we only synchroniza the first time through, just
         what we want.

         public class Singleton {
            private volatile static Singleton uniqueInstance; //The volatile keyword ensures that multiple threads handle the uniqueInstance variable correctly when it is being
                                                              //initialized to the Singleton instance.

            private Singleton() {}

            public static Singleton getInstance() { //Check for an instance and if there isn't one, enter a synchronized block.
               if (uniqueInstance == null) { //Note we only synchronized the first time through!
                  synchronized(Singleton.class) { //?? It passes Singleton.class to the sunchronized method??
                     if (uniqueInstance == null) {
                        uniqueInstance = new Singleton(); //Once in the block, check again and if still null, create an instance
                     }
                  }
               }
            }
         }

         This method of implementing the Singleton can drastically reduce the overhead.

      Note: If you are using a JVM earlier than 1.5, the double-checked locking implementation is not thread safe.

Chapter 6: Encapsulating Invocation

   -  Diner or a brief introduction to the Command Pattern

      Customers: createOrder()
      Waitress: takeOrder(), orderUp()
      Chef: makeBurger(), makeShake(), output()

      All the methods are based on a single object: An Order Slip

      We have a Diner with a Waitress who is decoupled from the Cook by an Order Slip, so what? 

      Think of the Dinner as a model for an OO design pattern that allows us to seperate an object making a request from the objects that receive and execute those requests.

   -  Command Pattern

              1.createCommandObject()           2. setCommand() (called by Client again)
      Client: -----------------------> Command: --------------> Invoker: setCommand()
         |                                                         ^
         |                            3.                           |
         |----------------------------------------------------------

                                          4. execute()
      (continued)Invoker: setCommand() -----------------> Receiver: action1(), action2()...

      Client:     createCommandObject()
      Invoker:    setCommand()
      Command:    execute()
      Receiver:   action1(), action2()...
      
      Note:

      1. The client creates a command object.
      2. The client does a setCommand to store the command object in the invoker.
      3. Later...the client asks the invoker to execute the command. Note: as you'll see later in this chapter, once the command
         is loaded into the invoker, it may be used and discarded, or it may remain and be used many times.
      4. At some point in the future, the invoker calls the command object's execute() method.

   -  The Command Pattern defined

      The Command Pattern: encapsulates a request as an object, thereby letting you parameterize other objects with different
      requests, queue or log requests, and support undoable operations.

      A command object encapsulates a request by binding together a set of actions on a specific receiver. To achieve this, 
      it packages the actions and the receiver up into an object that exposes just one method, execute(). When called, 
      execute() causes the actions to be invoked on the receiver.
      
      The diagram is shown below:

      Client              Invoker:  ------>Command<<interface>>:
       | |                setCommand()       execute()
       | |                                   undo()
       | |                                        |(inheritance)
       | --------->Receiver:<-------------ConcreteCommand
       |           action()                   execute()
       |-------------------------------->     undo()   


      Client:  it is reponsible for creating ConcreteCommand and setting its Receiver
      Invoker: it holds a command and at somepoint asks the command to carry out a request by calling its execute() method.
      Command: it declares an interface for all commands. A command is invoked through its execute() method, which asks a receiver to perform an action.
               we will cover undo later on.
      ConcreteCommand:  it defines a binding between an action and a receiver(!!). The invoker makes a request by calling execute() and the ConcreteCommand
                        carries it out by calling one or more actions on the Receiver.
      Receiver:   it knows how to perform the work needed to carry out the request. Any class can act as a Receiver(!!).

      Question: How does the design of the Command Pattern support the decoupling of the invoker of a request and the receiver of the request?
      
